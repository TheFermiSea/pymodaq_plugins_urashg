"""
EOM Calibration Experiment for μRASHG System

This module implements the Electro-Optic Modulator (EOM) calibration experiment
which is fundamental to all μRASHG measurements. The experiment performs:

1. PID-based power control with feedback from photodiode
2. Wavelength-dependent calibration curve generation
3. Power stability verification and validation
4. Calibration file generation for future experiments

The PID parameters are optimized for the μRASHG system:
- kp=24 (proportional gain)
- ki=3 (integral gain)
- kd=0.0125 (derivative gain)

This calibration is CRITICAL as all power-dependent experiments rely on accurate
EOM voltage-to-power conversion tables generated by this procedure.
"""

import numpy as np
import time
from typing import Dict, List, Tuple, Optional
from pathlib import Path
from datetime import datetime
import h5py
from scipy.optimize import curve_fit
from scipy.interpolate import interp2d

from qtpy import QtWidgets, QtCore
from pymodaq.utils.parameter import Parameter
from pymodaq.utils.data import DataWithAxes, DataToExport, Axis
from pymodaq.utils.data import DataActuator

from .base_experiment import URASHGBaseExperiment, ExperimentState, ExperimentError
import logging

logger = logging.getLogger(__name__)


class PIDController:
    """
    PID controller implementation for EOM voltage control.

    Optimized parameters for μRASHG system based on urashg_2 analysis:
    - kp=24: Proportional gain for immediate response
    - ki=3: Integral gain for steady-state accuracy
    - kd=0.0125: Derivative gain for stability
    """

    def __init__(self, kp=24.0, ki=3.0, kd=0.0125):
        self.kp = kp
        self.ki = ki
        self.kd = kd

        self.previous_error = 0.0
        self.integral = 0.0
        self.last_time = None

        # PID limits and constraints
        self.integral_limit = 1.0  # Prevent integral windup
        self.output_limit = (0.0, 10.0)  # EOM voltage limits

    def reset(self):
        """Reset PID controller state."""
        self.previous_error = 0.0
        self.integral = 0.0
        self.last_time = None

    def update(self, setpoint, measurement, dt=None):
        """
        Update PID controller with new measurement.

        Args:
            setpoint (float): Target photodiode voltage
            measurement (float): Current photodiode voltage
            dt (float): Time step (if None, calculated automatically)

        Returns:
            float: PID controller output (EOM voltage adjustment)
        """
        current_time = time.time()

        if self.last_time is None:
            self.last_time = current_time
            return 0.0

        if dt is None:
            dt = current_time - self.last_time

        if dt <= 0:
            return 0.0

        # Calculate error
        error = setpoint - measurement

        # Proportional term
        proportional = self.kp * error

        # Integral term with windup protection
        self.integral += error * dt
        self.integral = np.clip(
            self.integral, -self.integral_limit, self.integral_limit
        )
        integral = self.ki * self.integral

        # Derivative term
        derivative = self.kd * (error - self.previous_error) / dt

        # Calculate output
        output = proportional + integral + derivative

        # Apply output limits
        output = np.clip(output, self.output_limit[0], self.output_limit[1])

        # Update state
        self.previous_error = error
        self.last_time = current_time

        return output


class EOMCalibrationExperiment(URASHGBaseExperiment):
    """
    EOM Calibration Experiment for precise laser power control.

    This experiment creates wavelength-dependent lookup tables for EOM voltage
    to power conversion, enabling precise power control in subsequent experiments.

    The calibration process:
    1. Set laser wavelength and allow stabilization (60s default)
    2. Sweep EOM voltages across operating range
    3. Record photodiode voltage and power meter readings
    4. Use PID control to achieve target power levels
    5. Generate interpolation tables for runtime use
    6. Validate calibration accuracy and repeatability

    Required Hardware:
    - MaiTai laser for wavelength control
    - EOM for power modulation via voltage control
    - Photodiode for real-time power monitoring
    - Newport power meter for calibration verification

    Output:
    - HDF5 calibration file with interpolation tables
    - Validation report with accuracy metrics
    - Runtime-ready calibration data structures
    """

    experiment_name = "EOM Power Calibration"
    experiment_type = "eom_calibration"
    required_modules = [
        "MaiTai",
        "Newport1830C",
    ]  # Power meter required for calibration
    optional_modules = []

    def __init__(self, dashboard):
        super().__init__(dashboard)

        # PID controller for power control
        self.pid_controller = PIDController()

        # Calibration data storage
        self.calibration_results = {}
        self.voltage_sweep_data = {}
        self.power_control_data = {}

        # Current calibration state
        self.current_wavelength = None
        self.current_power_target = None

        # Add EOM-specific parameters
        self.add_eom_parameters()

    def add_eom_parameters(self):
        """Add EOM calibration specific parameters."""
        eom_params = {
            "name": "eom_calibration",
            "type": "group",
            "children": [
                {
                    "name": "wavelength_range",
                    "type": "group",
                    "children": [
                        {
                            "name": "start_nm",
                            "type": "float",
                            "value": 750.0,
                            "limits": [700, 950],
                            "suffix": "nm",
                        },
                        {
                            "name": "stop_nm",
                            "type": "float",
                            "value": 850.0,
                            "limits": [750, 1000],
                            "suffix": "nm",
                        },
                        {
                            "name": "step_nm",
                            "type": "float",
                            "value": 10.0,
                            "limits": [1, 50],
                            "suffix": "nm",
                        },
                    ],
                },
                {
                    "name": "voltage_sweep",
                    "type": "group",
                    "children": [
                        {
                            "name": "min_voltage",
                            "type": "float",
                            "value": 0.0,
                            "limits": [0, 5],
                            "suffix": "V",
                        },
                        {
                            "name": "max_voltage",
                            "type": "float",
                            "value": 8.0,
                            "limits": [3, 10],
                            "suffix": "V",
                        },
                        {
                            "name": "voltage_steps",
                            "type": "int",
                            "value": 50,
                            "limits": [10, 200],
                        },
                    ],
                },
                {
                    "name": "power_control",
                    "type": "group",
                    "children": [
                        {
                            "name": "min_power",
                            "type": "float",
                            "value": 0.001,
                            "limits": [0.0001, 0.01],
                            "suffix": "W",
                        },
                        {
                            "name": "max_power",
                            "type": "float",
                            "value": 0.020,
                            "limits": [0.005, 0.1],
                            "suffix": "W",
                        },
                        {
                            "name": "power_points",
                            "type": "int",
                            "value": 10,
                            "limits": [3, 50],
                        },
                        {"name": "logarithmic_spacing", "type": "bool", "value": True},
                    ],
                },
                {
                    "name": "pid_settings",
                    "type": "group",
                    "children": [
                        {
                            "name": "kp",
                            "type": "float",
                            "value": 24.0,
                            "limits": [0, 100],
                            "tip": "Proportional gain",
                        },
                        {
                            "name": "ki",
                            "type": "float",
                            "value": 3.0,
                            "limits": [0, 50],
                            "tip": "Integral gain",
                        },
                        {
                            "name": "kd",
                            "type": "float",
                            "value": 0.0125,
                            "limits": [0, 1],
                            "tip": "Derivative gain",
                        },
                        {
                            "name": "tolerance",
                            "type": "float",
                            "value": 0.001,
                            "limits": [0.0001, 0.01],
                            "suffix": "%",
                            "tip": "Power control tolerance",
                        },
                        {
                            "name": "max_iterations",
                            "type": "int",
                            "value": 100,
                            "limits": [10, 1000],
                        },
                        {
                            "name": "settling_time",
                            "type": "float",
                            "value": 0.1,
                            "limits": [0.01, 2.0],
                            "suffix": "s",
                        },
                    ],
                },
                {
                    "name": "validation",
                    "type": "group",
                    "children": [
                        {"name": "validate_calibration", "type": "bool", "value": True},
                        {
                            "name": "validation_points",
                            "type": "int",
                            "value": 5,
                            "limits": [3, 20],
                        },
                        {
                            "name": "repeatability_tests",
                            "type": "int",
                            "value": 3,
                            "limits": [1, 10],
                        },
                        {
                            "name": "max_error_percent",
                            "type": "float",
                            "value": 1.0,
                            "limits": [0.1, 10],
                            "suffix": "%",
                        },
                    ],
                },
            ],
        }

        # Add to existing parameters
        self.settings.addChild(eom_params)

    def initialize_specific_hardware(self):
        """Initialize EOM calibration specific hardware."""
        logger.info("Initializing EOM calibration hardware")

        # Verify MaiTai laser connection
        if "MaiTai" not in self.modules:
            raise ExperimentError("MaiTai laser module not available")

        # Verify power meter connection
        if "Newport1830C" not in self.modules:
            raise ExperimentError("Newport power meter not available")

        maitai = self.modules["MaiTai"]
        power_meter = self.modules["Newport1830C"]

        # Test laser communication
        try:
            # Get current wavelength to test communication
            current_wl = maitai.get_actuator_value()
            logger.info(f"MaiTai current wavelength: {current_wl} nm")
        except Exception as e:
            raise ExperimentError(f"Failed to communicate with MaiTai: {e}")

        # Test power meter communication
        try:
            current_power = power_meter.get_actuator_value()
            logger.info(f"Newport power meter reading: {current_power} W")
        except Exception as e:
            raise ExperimentError(f"Failed to communicate with power meter: {e}")

        # Initialize PID controller with settings
        kp = self.settings.child("eom_calibration", "pid_settings", "kp").value()
        ki = self.settings.child("eom_calibration", "pid_settings", "ki").value()
        kd = self.settings.child("eom_calibration", "pid_settings", "kd").value()

        self.pid_controller = PIDController(kp=kp, ki=ki, kd=kd)

        logger.info("EOM calibration hardware initialized successfully")

    def validate_parameters(self):
        """Validate EOM calibration parameters."""
        # Check wavelength range
        wl_start = self.settings.child(
            "eom_calibration", "wavelength_range", "start_nm"
        ).value()
        wl_stop = self.settings.child(
            "eom_calibration", "wavelength_range", "stop_nm"
        ).value()
        wl_step = self.settings.child(
            "eom_calibration", "wavelength_range", "step_nm"
        ).value()

        if wl_start >= wl_stop:
            raise ExperimentError("Wavelength start must be less than stop")

        if wl_step <= 0:
            raise ExperimentError("Wavelength step must be positive")

        # Check voltage range
        v_min = self.settings.child(
            "eom_calibration", "voltage_sweep", "min_voltage"
        ).value()
        v_max = self.settings.child(
            "eom_calibration", "voltage_sweep", "max_voltage"
        ).value()

        if v_min >= v_max:
            raise ExperimentError("Minimum voltage must be less than maximum voltage")

        # Check power range
        p_min = self.settings.child(
            "eom_calibration", "power_control", "min_power"
        ).value()
        p_max = self.settings.child(
            "eom_calibration", "power_control", "max_power"
        ).value()

        if p_min >= p_max:
            raise ExperimentError("Minimum power must be less than maximum power")

        logger.info("EOM calibration parameters validated successfully")

    def create_data_structures(self):
        """Create data structures for EOM calibration results."""
        # Get parameter values
        wl_start = self.settings.child(
            "eom_calibration", "wavelength_range", "start_nm"
        ).value()
        wl_stop = self.settings.child(
            "eom_calibration", "wavelength_range", "stop_nm"
        ).value()
        wl_step = self.settings.child(
            "eom_calibration", "wavelength_range", "step_nm"
        ).value()

        v_min = self.settings.child(
            "eom_calibration", "voltage_sweep", "min_voltage"
        ).value()
        v_max = self.settings.child(
            "eom_calibration", "voltage_sweep", "max_voltage"
        ).value()
        v_steps = self.settings.child(
            "eom_calibration", "voltage_sweep", "voltage_steps"
        ).value()

        p_min = self.settings.child(
            "eom_calibration", "power_control", "min_power"
        ).value()
        p_max = self.settings.child(
            "eom_calibration", "power_control", "max_power"
        ).value()
        p_points = self.settings.child(
            "eom_calibration", "power_control", "power_points"
        ).value()
        log_spacing = self.settings.child(
            "eom_calibration", "power_control", "logarithmic_spacing"
        ).value()

        # Create wavelength array
        wavelengths = np.arange(wl_start, wl_stop + wl_step, wl_step)

        # Create voltage array
        voltages = np.linspace(v_min, v_max, v_steps)

        # Create power array
        if log_spacing:
            powers = np.logspace(np.log10(p_min), np.log10(p_max), p_points)
        else:
            powers = np.linspace(p_min, p_max, p_points)

        # Voltage sweep data: [wavelength, voltage] -> (power, pd_voltage)
        self.voltage_sweep_data = {
            "wavelengths": wavelengths,
            "voltages": voltages,
            "measured_power": np.zeros((len(wavelengths), len(voltages))),
            "photodiode_voltage": np.zeros((len(wavelengths), len(voltages))),
            "timestamps": np.zeros((len(wavelengths), len(voltages))),
        }

        # Power control data: [wavelength, target_power] -> (achieved_power, eom_voltage, pd_voltage)
        self.power_control_data = {
            "wavelengths": wavelengths,
            "target_powers": powers,
            "achieved_power": np.zeros((len(wavelengths), len(powers))),
            "eom_voltage": np.zeros((len(wavelengths), len(powers))),
            "photodiode_voltage": np.zeros((len(wavelengths), len(powers))),
            "control_iterations": np.zeros((len(wavelengths), len(powers))),
            "control_time": np.zeros((len(wavelengths), len(powers))),
        }

        # Calculate total steps for progress tracking
        self.total_steps = len(wavelengths) * (len(voltages) + len(powers))
        logger.info(
            f"Created data structures for {len(wavelengths)} wavelengths, "
            f"{len(voltages)} voltage points, {len(powers)} power points"
        )

    def run_experiment(self):
        """Execute the EOM calibration experiment."""
        try:
            self.log_status("Starting EOM calibration experiment")

            # Phase 1: Voltage sweep calibration
            self.log_status("Phase 1: Voltage sweep calibration")
            self.run_voltage_sweep()

            # Phase 2: Power control calibration
            self.log_status("Phase 2: Power control calibration")
            self.run_power_control()

            # Phase 3: Generate calibration tables
            self.log_status("Phase 3: Generating calibration tables")
            self.generate_calibration_tables()

            # Phase 4: Validation (if enabled)
            if self.settings.child(
                "eom_calibration", "validation", "validate_calibration"
            ).value():
                self.log_status("Phase 4: Calibration validation")
                self.validate_calibration()

            # Phase 5: Save results
            self.log_status("Phase 5: Saving calibration results")
            self.save_calibration_results()

            self.log_status("EOM calibration completed successfully")

        except Exception as e:
            logger.error(f"EOM calibration failed: {e}")
            raise ExperimentError(f"EOM calibration failed: {e}")

    def run_voltage_sweep(self):
        """Run voltage sweep calibration for all wavelengths."""
        maitai = self.modules["MaiTai"]
        power_meter = self.modules["Newport1830C"]

        wavelengths = self.voltage_sweep_data["wavelengths"]
        voltages = self.voltage_sweep_data["voltages"]

        for wl_idx, wavelength in enumerate(wavelengths):
            if self._check_stop_requested():
                return

            self.log_status(f"Voltage sweep at {wavelength:.1f} nm")

            # Set wavelength and wait for stabilization
            self.set_wavelength_and_wait(wavelength)

            for v_idx, voltage in enumerate(voltages):
                if self._check_stop_requested():
                    return

                # Set EOM voltage
                self.set_eom_voltage(voltage)

                # Wait for settling
                settling_time = self.settings.child(
                    "eom_calibration", "pid_settings", "settling_time"
                ).value()
                time.sleep(settling_time)

                # Measure power and photodiode voltage
                measured_power = self.measure_power_with_averaging()
                pd_voltage = self.measure_photodiode_voltage()

                # Store results
                self.voltage_sweep_data["measured_power"][
                    wl_idx, v_idx
                ] = measured_power
                self.voltage_sweep_data["photodiode_voltage"][
                    wl_idx, v_idx
                ] = pd_voltage
                self.voltage_sweep_data["timestamps"][wl_idx, v_idx] = time.time()

                # Update progress
                step = wl_idx * len(voltages) + v_idx + 1
                progress = (step / self.total_steps) * 50  # First 50% for voltage sweep
                self.update_progress(progress)

                logger.debug(
                    f"Voltage {voltage:.2f}V -> Power {measured_power:.6f}W, PD {pd_voltage:.4f}V"
                )

    def run_power_control(self):
        """Run PID-based power control calibration."""
        wavelengths = self.power_control_data["wavelengths"]
        target_powers = self.power_control_data["target_powers"]

        for wl_idx, wavelength in enumerate(wavelengths):
            if self._check_stop_requested():
                return

            self.log_status(f"Power control at {wavelength:.1f} nm")

            # Set wavelength and wait for stabilization
            self.set_wavelength_and_wait(wavelength)

            for p_idx, target_power in enumerate(target_powers):
                if self._check_stop_requested():
                    return

                # Perform PID power control
                start_time = time.time()
                result = self.control_power_to_target(target_power, wavelength)
                control_time = time.time() - start_time

                # Store results
                self.power_control_data["achieved_power"][wl_idx, p_idx] = result[
                    "achieved_power"
                ]
                self.power_control_data["eom_voltage"][wl_idx, p_idx] = result[
                    "eom_voltage"
                ]
                self.power_control_data["photodiode_voltage"][wl_idx, p_idx] = result[
                    "pd_voltage"
                ]
                self.power_control_data["control_iterations"][wl_idx, p_idx] = result[
                    "iterations"
                ]
                self.power_control_data["control_time"][wl_idx, p_idx] = control_time

                # Update progress
                voltage_steps = len(self.voltage_sweep_data["voltages"])
                step = (
                    len(wavelengths) * voltage_steps
                    + wl_idx * len(target_powers)
                    + p_idx
                    + 1
                )
                progress = (
                    50 + (step / self.total_steps) * 50
                )  # Second 50% for power control
                self.update_progress(progress)

                logger.info(
                    f"Target {target_power:.6f}W -> Achieved {result['achieved_power']:.6f}W "
                    f"({result['iterations']} iterations, {control_time:.2f}s)"
                )

    def set_wavelength_and_wait(self, wavelength):
        """Set laser wavelength and wait for stabilization."""
        maitai = self.modules["MaiTai"]
        stabilization_time = self.settings.child(
            "hardware_settings", "stabilization_time"
        ).value()

        # Set wavelength
        target_position = DataActuator(data=[wavelength])
        maitai.move_abs(target_position)

        self.log_status(
            f"Set wavelength to {wavelength:.1f} nm, waiting {stabilization_time:.0f}s for stabilization"
        )

        # Wait for stabilization with progress updates
        start_time = time.time()
        while time.time() - start_time < stabilization_time:
            if self._check_stop_requested():
                return
            time.sleep(1.0)

        self.current_wavelength = wavelength

    def set_eom_voltage(self, voltage):
        """Set EOM voltage."""
        # TODO: Implement EOM voltage control through appropriate hardware interface
        # This would typically go through a DAQ or direct serial communication
        # For now, this is a placeholder for the hardware interface
        logger.debug(f"Setting EOM voltage to {voltage:.3f} V")

        # Simulate EOM setting delay
        time.sleep(0.01)

    def measure_power_with_averaging(self, num_samples=10):
        """Measure power with averaging for improved accuracy."""
        power_meter = self.modules["Newport1830C"]

        powers = []
        for _ in range(num_samples):
            power = power_meter.get_actuator_value()
            powers.append(power.value() if hasattr(power, "value") else float(power))
            time.sleep(0.01)  # Small delay between samples

        return np.mean(powers)

    def measure_photodiode_voltage(self, num_samples=10):
        """Measure photodiode voltage with averaging."""
        # TODO: Implement photodiode voltage measurement
        # This would typically go through a DAQ analog input
        # For now, simulate a photodiode response proportional to power

        # Simulate photodiode voltage based on current power
        # In real implementation, this would read from hardware
        simulated_voltage = np.random.normal(1.0, 0.01)  # Placeholder
        return simulated_voltage

    def control_power_to_target(self, target_power, wavelength):
        """
        Use PID control to achieve target power.

        Args:
            target_power (float): Target power in Watts
            wavelength (float): Current wavelength in nm

        Returns:
            dict: Control results with achieved power, voltage, etc.
        """
        # Reset PID controller
        self.pid_controller.reset()

        # Get control parameters
        tolerance = self.settings.child(
            "eom_calibration", "pid_settings", "tolerance"
        ).value()
        max_iterations = self.settings.child(
            "eom_calibration", "pid_settings", "max_iterations"
        ).value()
        settling_time = self.settings.child(
            "eom_calibration", "pid_settings", "settling_time"
        ).value()

        # Initial EOM voltage estimate from voltage sweep data
        initial_voltage = self.estimate_voltage_for_power(target_power, wavelength)
        self.set_eom_voltage(initial_voltage)

        # Convert target power to target photodiode voltage
        target_pd_voltage = self.power_to_pd_voltage(target_power, wavelength)

        current_voltage = initial_voltage
        iteration = 0

        for iteration in range(max_iterations):
            if self._check_stop_requested():
                break

            # Measure current power and photodiode voltage
            current_power = self.measure_power_with_averaging(5)
            current_pd_voltage = self.measure_photodiode_voltage(5)

            # Check convergence
            power_error = abs(current_power - target_power) / target_power
            if power_error < tolerance:
                logger.debug(f"PID converged in {iteration} iterations")
                break

            # Update PID controller
            voltage_adjustment = self.pid_controller.update(
                target_pd_voltage, current_pd_voltage
            )
            current_voltage += voltage_adjustment

            # Apply voltage limits
            current_voltage = np.clip(current_voltage, 0.0, 10.0)

            # Set new EOM voltage
            self.set_eom_voltage(current_voltage)

            # Wait for settling
            time.sleep(settling_time)

        # Final measurement
        final_power = self.measure_power_with_averaging(10)
        final_pd_voltage = self.measure_photodiode_voltage(10)

        return {
            "achieved_power": final_power,
            "eom_voltage": current_voltage,
            "pd_voltage": final_pd_voltage,
            "iterations": iteration + 1,
            "converged": iteration < max_iterations - 1,
        }

    def estimate_voltage_for_power(self, target_power, wavelength):
        """Estimate EOM voltage needed for target power based on voltage sweep data."""
        # Find nearest wavelength in sweep data
        wavelengths = self.voltage_sweep_data["wavelengths"]
        wl_idx = np.argmin(np.abs(wavelengths - wavelength))

        # Get power vs voltage data for this wavelength
        powers = self.voltage_sweep_data["measured_power"][wl_idx, :]
        voltages = self.voltage_sweep_data["voltages"]

        # Interpolate to find voltage for target power
        if len(powers) > 0 and np.max(powers) > target_power > np.min(powers):
            estimated_voltage = np.interp(target_power, powers, voltages)
        else:
            # Fallback to middle of voltage range
            estimated_voltage = np.mean(voltages)

        return estimated_voltage

    def power_to_pd_voltage(self, power, wavelength):
        """Convert power to expected photodiode voltage."""
        # TODO: Implement power to photodiode voltage conversion
        # This would use calibration data or a known conversion factor
        # For now, assume linear relationship (placeholder)
        conversion_factor = 100.0  # V/W (placeholder)
        return power * conversion_factor

    def generate_calibration_tables(self):
        """Generate interpolation tables for runtime power control."""
        self.log_status("Generating interpolation tables")

        wavelengths = self.power_control_data["wavelengths"]
        target_powers = self.power_control_data["target_powers"]
        eom_voltages = self.power_control_data["eom_voltage"]
        pd_voltages = self.power_control_data["photodiode_voltage"]

        # Create 2D interpolation functions
        # These will be used at runtime for power control

        # EOM voltage interpolation: (wavelength, power) -> EOM voltage
        try:
            self.eom_voltage_interpolator = interp2d(
                wavelengths,
                target_powers,
                eom_voltages.T,
                kind="linear",
                bounds_error=False,
                fill_value=np.nan,
            )
            logger.info("Created EOM voltage interpolation table")
        except Exception as e:
            logger.warning(f"Failed to create EOM voltage interpolator: {e}")
            self.eom_voltage_interpolator = None

        # Photodiode voltage interpolation: (wavelength, power) -> PD voltage
        try:
            self.pd_voltage_interpolator = interp2d(
                wavelengths,
                target_powers,
                pd_voltages.T,
                kind="linear",
                bounds_error=False,
                fill_value=np.nan,
            )
            logger.info("Created photodiode voltage interpolation table")
        except Exception as e:
            logger.warning(f"Failed to create PD voltage interpolator: {e}")
            self.pd_voltage_interpolator = None

        # Store calibration ranges for validation
        self.calibration_ranges = {
            "wavelength_min": np.min(wavelengths),
            "wavelength_max": np.max(wavelengths),
            "power_min": np.min(target_powers),
            "power_max": np.max(target_powers),
        }

    def validate_calibration(self):
        """Validate calibration accuracy with independent test points."""
        self.log_status("Validating calibration accuracy")

        validation_points = self.settings.child(
            "eom_calibration", "validation", "validation_points"
        ).value()
        repeatability_tests = self.settings.child(
            "eom_calibration", "validation", "repeatability_tests"
        ).value()
        max_error_percent = self.settings.child(
            "eom_calibration", "validation", "max_error_percent"
        ).value()

        # Generate random test points within calibration range
        wavelengths = self.calibration_ranges["wavelength_min"] + np.random.random(
            validation_points
        ) * (
            self.calibration_ranges["wavelength_max"]
            - self.calibration_ranges["wavelength_min"]
        )

        powers = self.calibration_ranges["power_min"] + np.random.random(
            validation_points
        ) * (
            self.calibration_ranges["power_max"] - self.calibration_ranges["power_min"]
        )

        validation_results = []

        for wl, target_power in zip(wavelengths, powers):
            if self._check_stop_requested():
                return

            self.log_status(f"Validating {target_power:.6f}W at {wl:.1f}nm")

            # Set wavelength
            self.set_wavelength_and_wait(wl)

            # Repeat measurement for repeatability assessment
            achieved_powers = []
            for rep in range(repeatability_tests):
                result = self.control_power_to_target(target_power, wl)
                achieved_powers.append(result["achieved_power"])

            # Calculate validation metrics
            mean_power = np.mean(achieved_powers)
            std_power = np.std(achieved_powers)
            error_percent = abs(mean_power - target_power) / target_power * 100
            repeatability_percent = std_power / mean_power * 100

            validation_result = {
                "wavelength": wl,
                "target_power": target_power,
                "achieved_powers": achieved_powers,
                "mean_power": mean_power,
                "std_power": std_power,
                "error_percent": error_percent,
                "repeatability_percent": repeatability_percent,
                "passed": error_percent < max_error_percent,
            }

            validation_results.append(validation_result)

            logger.info(
                f"Validation: Target {target_power:.6f}W -> "
                f"Achieved {mean_power:.6f}±{std_power:.6f}W "
                f"(Error: {error_percent:.2f}%, Repeatability: {repeatability_percent:.2f}%)"
            )

        # Store validation results
        self.validation_results = validation_results

        # Calculate overall validation statistics
        errors = [r["error_percent"] for r in validation_results]
        repeatabilities = [r["repeatability_percent"] for r in validation_results]
        passed_count = sum(1 for r in validation_results if r["passed"])

        self.validation_summary = {
            "total_points": len(validation_results),
            "passed_points": passed_count,
            "pass_rate": passed_count / len(validation_results) * 100,
            "mean_error_percent": np.mean(errors),
            "max_error_percent": np.max(errors),
            "mean_repeatability_percent": np.mean(repeatabilities),
            "max_repeatability_percent": np.max(repeatabilities),
        }

        logger.info(
            f"Validation summary: {passed_count}/{len(validation_results)} points passed"
        )
        logger.info(
            f"Mean error: {np.mean(errors):.2f}%, Max error: {np.max(errors):.2f}%"
        )
        logger.info(f"Mean repeatability: {np.mean(repeatabilities):.2f}%")

    def save_calibration_results(self):
        """Save calibration results to HDF5 file."""
        try:
            with h5py.File(self.data_filepath, "w") as f:
                # Save voltage sweep data
                sweep_group = f.create_group("voltage_sweep")
                for key, value in self.voltage_sweep_data.items():
                    sweep_group.create_dataset(key, data=value)

                # Save power control data
                control_group = f.create_group("power_control")
                for key, value in self.power_control_data.items():
                    control_group.create_dataset(key, data=value)

                # Save calibration ranges
                calib_group = f.create_group("calibration_info")
                for key, value in self.calibration_ranges.items():
                    calib_group.attrs[key] = value

                # Save PID parameters
                pid_group = f.create_group("pid_parameters")
                pid_group.attrs["kp"] = self.pid_controller.kp
                pid_group.attrs["ki"] = self.pid_controller.ki
                pid_group.attrs["kd"] = self.pid_controller.kd

                # Save validation results if available
                if hasattr(self, "validation_results"):
                    validation_group = f.create_group("validation")

                    # Save individual validation points
                    for i, result in enumerate(self.validation_results):
                        point_group = validation_group.create_group(f"point_{i}")
                        for key, value in result.items():
                            if isinstance(value, (list, np.ndarray)):
                                point_group.create_dataset(key, data=value)
                            else:
                                point_group.attrs[key] = value

                    # Save validation summary
                    for key, value in self.validation_summary.items():
                        validation_group.attrs[key] = value

                # Save metadata
                f.attrs["experiment_name"] = self.experiment_name
                f.attrs["experiment_type"] = self.experiment_type
                f.attrs["creation_time"] = datetime.now().isoformat()
                f.attrs["calibration_version"] = "1.0"

            logger.info(f"Calibration results saved to {self.data_filepath}")
            self.log_status(f"Calibration data saved to {self.data_filepath}")

        except Exception as e:
            logger.error(f"Failed to save calibration results: {e}")
            raise ExperimentError(f"Failed to save calibration results: {e}")

    def _check_stop_requested(self):
        """Check if experiment stop was requested."""
        if hasattr(self, "experiment_thread") and self.experiment_thread:
            return self.experiment_thread._stop_requested
        return False

    def get_calibrated_voltage(self, wavelength, power):
        """
        Get calibrated EOM voltage for specified wavelength and power.

        Args:
            wavelength (float): Laser wavelength in nm
            power (float): Target power in W

        Returns:
            float: EOM voltage in V
        """
        if (
            not hasattr(self, "eom_voltage_interpolator")
            or self.eom_voltage_interpolator is None
        ):
            raise ExperimentError("EOM calibration not available")

        # Check if values are within calibration range
        if not (
            self.calibration_ranges["wavelength_min"]
            <= wavelength
            <= self.calibration_ranges["wavelength_max"]
        ):
            logger.warning(f"Wavelength {wavelength} nm outside calibrated range")

        if not (
            self.calibration_ranges["power_min"]
            <= power
            <= self.calibration_ranges["power_max"]
        ):
            logger.warning(f"Power {power} W outside calibrated range")

        try:
            voltage = self.eom_voltage_interpolator(wavelength, power)[0]
            return float(voltage)
        except Exception as e:
            raise ExperimentError(f"Failed to interpolate EOM voltage: {e}")
