# -*- coding: utf-8 -*-
"""
PyMoDAQ Actuator Plugin for URASHG Red Pitaya PyRPL PID Controller

This plugin provides PyMoDAQ actuator functionality for controlling Red Pitaya's
hardware PID controller setpoints via the PyRPL library within the URASHG
polarimetry measurement system for laser power stabilization.

Features:
    - Hardware PID setpoint control for laser power stabilization
    - Integration with URASHG wavelength-dependent measurements
    - Multi-channel PID support (PID0/PID1/PID2)
    - Thread-safe PyRPL wrapper integration
    - Mock mode for development without hardware
    - Voltage range: ±1V with proper safety limits

Compatible Controllers:
    - Red Pitaya STEMlab 125-10/125-14
    - PyRPL firmware and library

Tested Configuration:
    - PyMoDAQ 4.0+
    - PyRPL 0.9.5+
    - Red Pitaya STEMlab 125-14
    - Ubuntu 20.04/22.04 LTS

Installation Requirements:
    - PyRPL library: `pip install pyrpl`
    - Red Pitaya network connection and PyRPL firmware
    - Proper network configuration (see documentation)

Author: Claude Code
License: MIT
"""

from typing import Union, List, Dict, Optional
from pymodaq.control_modules.move_utility_classes import (
    DAQ_Move_base, comon_parameters_fun,
    main, DataActuatorType, DataActuator
)

from pymodaq_utils.utils import ThreadCommand
from pymodaq_gui.parameter import Parameter
import logging

# Import PyRPL wrapper utilities from URASHG utils
from ..utils import (
    PyRPLManager, PyRPLConnection, PIDChannel, InputChannel, 
    OutputChannel, PIDConfiguration, ConnectionState, PYRPL_WRAPPER_AVAILABLE
)

logger = logging.getLogger(__name__)


class DAQ_Move_URASHG_PyRPL_PID(DAQ_Move_base):
    """
    PyMoDAQ Actuator Plugin for URASHG Red Pitaya PID Setpoint Control.
    
    This plugin enables precise control of Red Pitaya's hardware PID controller
    setpoints through PyMoDAQ's actuator interface for laser power stabilization
    during wavelength-dependent polarimetry measurements.
    
    The plugin treats PID setpoints as actuator positions, allowing PyMoDAQ to:
    - Set absolute setpoint values (move_abs) for target power levels
    - Make relative setpoint adjustments (move_rel) for fine tuning
    - Read current setpoint values (get_actuator_value) for feedback
    - Provide safety limits and validation for laser protection
    
    Key Features:
    - Hardware PID setpoint control with ±1V range
    - Multi-channel support (PID0, PID1, PID2) for multiple laser lines
    - Thread-safe operations via PyRPL wrapper
    - Mock mode for development without hardware
    - Comprehensive error handling and status reporting
    - Integration with URASHG wavelength scanning
    
    Attributes:
    -----------
    controller: PyRPLConnection
        The PyRPL connection object for hardware communication
    pyrpl_manager: PyRPLManager
        Centralized manager for PyRPL connections
    pid_channel: PIDChannel
        Selected PID channel (PID0/PID1/PID2)
    mock_mode: bool
        Whether to operate in mock mode without hardware
    mock_setpoint: float
        Simulated setpoint value for mock mode
    """
    
    is_multiaxes = False
    _axis_names = ['Power_Setpoint']
    _controller_units = 'V'  # Voltage units (Red Pitaya operates in ±1V range)
    _epsilon = 0.001  # 1mV precision for setpoint control
    data_actuator_type = DataActuatorType.DataActuator

    params = [
        {'title': 'Connection Settings', 'name': 'connection_settings', 'type': 'group', 'children': [
            {'title': 'RedPitaya Host:', 'name': 'redpitaya_host', 'type': 'str', 
             'value': 'rp-f08d6c.local', 'tip': 'Red Pitaya hostname or IP address'},
            {'title': 'Config Name:', 'name': 'config_name', 'type': 'str', 
             'value': 'urashg', 'tip': 'PyRPL configuration name for URASHG'},
            {'title': 'Connection Timeout (s):', 'name': 'connection_timeout', 'type': 'float', 
             'value': 10.0, 'min': 1.0, 'max': 60.0},
            {'title': 'Mock Mode:', 'name': 'mock_mode', 'type': 'bool', 'value': False,
             'tip': 'Enable mock mode for testing without hardware'},
        ]},
        
        {'title': 'PID Configuration', 'name': 'pid_config', 'type': 'group', 'children': [
            {'title': 'PID Module:', 'name': 'pid_module', 'type': 'list', 
             'limits': ['pid0', 'pid1', 'pid2'], 'value': 'pid0',
             'tip': 'Select PID controller module for laser power stabilization'},
            {'title': 'Input Channel:', 'name': 'input_channel', 'type': 'list', 
             'limits': ['in1', 'in2'], 'value': 'in1',
             'tip': 'PID input channel (photodiode signal)'},
            {'title': 'Output Channel:', 'name': 'output_channel', 'type': 'list', 
             'limits': ['out1', 'out2'], 'value': 'out1',
             'tip': 'PID output channel (laser control signal)'},
        ]},
        
        {'title': 'PID Parameters', 'name': 'pid_params', 'type': 'group', 'children': [
            {'title': 'P Gain:', 'name': 'p_gain', 'type': 'float', 
             'value': 0.1, 'min': 0.0, 'max': 10.0, 'step': 0.01,
             'tip': 'Proportional gain coefficient for laser power control'},
            {'title': 'I Gain:', 'name': 'i_gain', 'type': 'float', 
             'value': 0.01, 'min': 0.0, 'max': 1.0, 'step': 0.001,
             'tip': 'Integral gain coefficient for steady-state accuracy'},
            {'title': 'D Gain:', 'name': 'd_gain', 'type': 'float', 
             'value': 0.0, 'min': 0.0, 'max': 1.0, 'step': 0.001,
             'tip': 'Derivative gain coefficient (usually kept at 0)'},
        ]},
        
        {'title': 'Safety Limits', 'name': 'safety_limits', 'type': 'group', 'children': [
            {'title': 'Min Power Setpoint (V):', 'name': 'min_voltage', 'type': 'float', 
             'value': -1.0, 'min': -1.0, 'max': 0.0,
             'tip': 'Minimum allowed power setpoint voltage'},
            {'title': 'Max Power Setpoint (V):', 'name': 'max_voltage', 'type': 'float', 
             'value': 1.0, 'min': 0.0, 'max': 1.0,
             'tip': 'Maximum allowed power setpoint voltage'},
            {'title': 'Enable PID on Connect:', 'name': 'auto_enable_pid', 'type': 'bool', 
             'value': False, 'tip': 'Automatically enable PID output on connection'},
        ]},
        
    ] + comon_parameters_fun(is_multiaxes, axis_names=_axis_names, epsilon=_epsilon)

    def ini_attributes(self):
        """Initialize plugin attributes and connections."""
        # Check if PyRPL wrapper is available
        if not PYRPL_WRAPPER_AVAILABLE:
            logger.error("PyRPL wrapper not available - check PyRPL installation")
            
        # PyRPL connection management
        self.controller: Optional[PyRPLConnection] = None
        self.pyrpl_manager: Optional[PyRPLManager] = None
        
        # PID configuration
        self.pid_channel: Optional[PIDChannel] = None
        self.input_channel: Optional[InputChannel] = None
        self.output_channel: Optional[OutputChannel] = None
        
        # Mock mode attributes
        self.mock_mode: bool = False
        self.mock_setpoint: float = 0.0
        
        # Connection state
        self.hostname: str = ''
        self.config_name: str = 'urashg'
        self.is_pid_configured: bool = False
        
        # Initialize PyRPL manager if available
        if PYRPL_WRAPPER_AVAILABLE and PyRPLManager is not None:
            self.pyrpl_manager = PyRPLManager.get_instance()
        
        logger.debug("DAQ_Move_URASHG_PyRPL_PID attributes initialized")

    def get_actuator_value(self) -> DataActuator:
        """
        Get the current PID setpoint value from the hardware.

        Returns
        -------
        DataActuator: The current setpoint value with voltage units
        """
        if self.mock_mode:
            # Return mock setpoint
            pos = DataActuator(data=self.mock_setpoint, units='V')
        else:
            if not self.controller or not self.controller.is_connected:
                logger.warning("Controller not connected, returning 0V")
                pos = DataActuator(data=0.0, units='V')
            else:
                try:
                    setpoint = self.controller.get_pid_setpoint(self.pid_channel)
                    if setpoint is not None:
                        pos = DataActuator(data=setpoint, units='V')
                    else:
                        logger.error("Failed to read PID setpoint")
                        pos = DataActuator(data=0.0, units='V')
                except Exception as e:
                    logger.error(f"Error reading PID setpoint: {e}")
                    pos = DataActuator(data=0.0, units='V')
        
        # Apply any scaling configured by user
        pos = self.get_position_with_scaling(pos)
        return pos

    def user_condition_to_reach_target(self) -> bool:
        """
        Check if the PID setpoint has reached the target value.
        
        For PID setpoint control, we consider the target reached immediately
        after setting it, as the setpoint change is instantaneous.
        
        Returns
        -------
        bool: True if target has been reached
        """
        return True  # Setpoint changes are immediate

    def close(self):
        """Terminate the communication protocol and clean up resources."""
        if self.is_master and self.controller:
            try:
                # Safely disable PID if it was enabled
                if self.is_pid_configured and not self.mock_mode:
                    self.controller.disable_pid(self.pid_channel)
                    self.emit_status(ThreadCommand('Update_Status', 
                        [f"Disabled PID {self.pid_channel.value} before disconnect", 'log']))
                
                # Disconnect through manager
                if not self.mock_mode and self.pyrpl_manager:
                    self.pyrpl_manager.disconnect_device(
                        self.hostname, 
                        self.config_name,
                        status_callback=self._status_callback
                    )
                
                self.emit_status(ThreadCommand('Update_Status', 
                    ['URASHG PyRPL PID controller disconnected', 'log']))
                    
            except Exception as e:
                logger.error(f"Error during URASHG PyRPL PID disconnect: {e}")
                self.emit_status(ThreadCommand('Update_Status', 
                    [f"Disconnect error: {str(e)}", 'log']))
            finally:
                self.controller = None
                self.is_pid_configured = False

    def _status_callback(self, command: ThreadCommand):
        """Internal callback for status updates from PyRPL wrapper."""
        self.emit_status(command)

    def commit_settings(self, param: Parameter):
        """
        Apply consequences of parameter changes in the plugin settings.

        Parameters
        ----------
        param: Parameter
            The parameter that was changed by the user
        """
        if param.name() in ['redpitaya_host', 'config_name', 'connection_timeout']:
            # Connection parameters changed - may need reconnection
            if self.controller and self.controller.is_connected and not self.mock_mode:
                self.emit_status(ThreadCommand('Update_Status', 
                    ['Connection parameter changed - restart plugin to apply', 'log']))
        
        elif param.name() == 'mock_mode':
            self.mock_mode = param.value()
            self.emit_status(ThreadCommand('Update_Status', 
                [f"Mock mode: {'Enabled' if self.mock_mode else 'Disabled'}", 'log']))
        
        elif param.name() in ['pid_module', 'input_channel', 'output_channel']:
            # PID configuration changed - update if connected
            if self.controller and self.controller.is_connected and not self.mock_mode:
                self._update_pid_configuration()
        
        elif param.name() in ['p_gain', 'i_gain', 'd_gain', 'min_voltage', 'max_voltage']:
            # PID parameters changed - update if connected
            if self.controller and self.controller.is_connected and not self.mock_mode:
                self._update_pid_parameters()
        
        elif param.name() == 'auto_enable_pid':
            # Auto-enable setting changed
            pass  # This only affects initialization
        
        else:
            pass  # Handle other parameters as needed

    def _update_pid_configuration(self):
        """Update PID module configuration based on current parameters."""
        try:
            # Update channel selections
            self.pid_channel = PIDChannel(self.settings.child('pid_config', 'pid_module').value())
            self.input_channel = InputChannel(self.settings.child('pid_config', 'input_channel').value())
            self.output_channel = OutputChannel(self.settings.child('pid_config', 'output_channel').value())
            
            # Create new PID configuration
            pid_config = self._create_pid_configuration()
            
            # Apply configuration
            success = self.controller.configure_pid(self.pid_channel, pid_config)
            
            if success:
                self.is_pid_configured = True
                self.emit_status(ThreadCommand('Update_Status', 
                    [f"Updated PID {self.pid_channel.value} configuration", 'log']))
            else:
                self.emit_status(ThreadCommand('Update_Status', 
                    ["Failed to update PID configuration", 'log']))
                
        except Exception as e:
            logger.error(f"Error updating PID configuration: {e}")
            self.emit_status(ThreadCommand('Update_Status', 
                [f"PID configuration error: {str(e)}", 'log']))

    def _update_pid_parameters(self):
        """Update PID parameters (gains, limits) for current configuration."""
        if not self.is_pid_configured:
            return
            
        try:
            pid_config = self._create_pid_configuration()
            success = self.controller.configure_pid(self.pid_channel, pid_config)
            
            if success:
                self.emit_status(ThreadCommand('Update_Status', 
                    ["Updated PID parameters", 'log']))
            else:
                self.emit_status(ThreadCommand('Update_Status', 
                    ["Failed to update PID parameters", 'log']))
                
        except Exception as e:
            logger.error(f"Error updating PID parameters: {e}")
            self.emit_status(ThreadCommand('Update_Status', 
                [f"PID parameter update error: {str(e)}", 'log']))

    def _create_pid_configuration(self) -> PIDConfiguration:
        """Create PID configuration from current parameter values."""
        return PIDConfiguration(
            setpoint=0.0,  # Will be set by move commands
            p_gain=self.settings.child('pid_params', 'p_gain').value(),
            i_gain=self.settings.child('pid_params', 'i_gain').value(),
            d_gain=self.settings.child('pid_params', 'd_gain').value(),
            input_channel=self.input_channel,
            output_channel=self.output_channel,
            voltage_limit_min=self.settings.child('safety_limits', 'min_voltage').value(),
            voltage_limit_max=self.settings.child('safety_limits', 'max_voltage').value(),
            enabled=self.settings.child('safety_limits', 'auto_enable_pid').value()
        )

    def ini_stage(self, controller=None):
        """
        Initialize the PID controller stage for URASHG laser power stabilization.

        Parameters
        ----------
        controller: object, optional
            Shared controller object for multi-plugin setups (slave mode)

        Returns
        -------
        info: str
            Initialization information message
        initialized: bool
            True if initialization successful, False otherwise
        """
        try:
            self.emit_status(ThreadCommand('Update_Status', ['Initializing URASHG PyRPL PID Controller...', 'log']))
            
            # Check if PyRPL wrapper is available
            if not PYRPL_WRAPPER_AVAILABLE:
                error_msg = "PyRPL wrapper not available - install PyRPL library"
                self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
                return error_msg, False
            
            # Extract connection parameters
            self.hostname = self.settings.child('connection_settings', 'redpitaya_host').value()
            self.config_name = self.settings.child('connection_settings', 'config_name').value()
            self.mock_mode = self.settings.child('connection_settings', 'mock_mode').value()
            connection_timeout = self.settings.child('connection_settings', 'connection_timeout').value()
            
            # Extract PID configuration
            self.pid_channel = PIDChannel(self.settings.child('pid_config', 'pid_module').value())
            self.input_channel = InputChannel(self.settings.child('pid_config', 'input_channel').value())
            self.output_channel = OutputChannel(self.settings.child('pid_config', 'output_channel').value())
            
            if self.is_master:
                if self.mock_mode:
                    # Mock mode initialization
                    self.controller = None  # No real controller needed
                    self.mock_setpoint = 0.0
                    info = f"URASHG PyRPL PID Controller initialized in MOCK mode (PID: {self.pid_channel.value})"
                    self.emit_status(ThreadCommand('Update_Status', [info, 'log']))
                    return info, True
                
                else:
                    # Real hardware initialization
                    self.controller = self.pyrpl_manager.connect_device(
                        hostname=self.hostname,
                        config_name=self.config_name,
                        status_callback=self._status_callback,
                        connection_timeout=connection_timeout
                    )
                    
                    if not self.controller or not self.controller.is_connected:
                        error_msg = f"Failed to connect to Red Pitaya at {self.hostname} for URASHG"
                        self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
                        return error_msg, False
                    
                    # Configure PID controller
                    pid_config = self._create_pid_configuration()
                    success = self.controller.configure_pid(self.pid_channel, pid_config)
                    
                    if not success:
                        error_msg = f"Failed to configure PID {self.pid_channel.value} for URASHG"
                        self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
                        return error_msg, False
                    
                    self.is_pid_configured = True
                    
                    # Get connection info for status
                    conn_info = self.controller.get_connection_info()
                    info = (f"URASHG PyRPL PID Controller connected to {self.hostname} "
                           f"(PID: {self.pid_channel.value}, "
                           f"State: {conn_info['state']}, "
                           f"Power Stabilization Ready)")
                    
                    self.emit_status(ThreadCommand('Update_Status', [info, 'log']))
                    return info, True
            
            else:
                # Slave mode - use shared controller
                self.controller = controller
                if self.controller and hasattr(self.controller, 'is_connected'):
                    initialized = self.controller.is_connected
                else:
                    initialized = True  # Assume slave initialization is OK
                
                info = f"URASHG PyRPL PID Controller initialized in slave mode (PID: {self.pid_channel.value})"
                self.emit_status(ThreadCommand('Update_Status', [info, 'log']))
                return info, initialized
                
        except Exception as e:
            error_msg = f"URASHG PyRPL PID initialization failed: {str(e)}"
            logger.error(error_msg)
            self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
            return error_msg, False

    def move_abs(self, value: DataActuator):
        """
        Move the PID setpoint to an absolute target value for laser power control.

        Parameters
        ----------
        value: DataActuator
            Absolute target setpoint voltage value for desired power level
        """
        # Apply bounds checking
        value = self.check_bound(value)
        self.target_value = value
        
        # Apply scaling if configured
        value = self.set_position_with_scaling(value)
        
        # Extract voltage value
        voltage_value = value.value('V')
        
        if self.mock_mode:
            # Mock mode operation
            self.mock_setpoint = voltage_value
            self.emit_status(ThreadCommand('Update_Status', 
                [f"Mock URASHG PID setpoint set to {voltage_value:.3f}V", 'log']))
        else:
            if not self.controller or not self.controller.is_connected:
                error_msg = "Cannot set power setpoint: controller not connected"
                logger.error(error_msg)
                self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
                return
            
            try:
                success = self.controller.set_pid_setpoint(self.pid_channel, voltage_value)
                
                if success:
                    self.emit_status(ThreadCommand('Update_Status', 
                        [f"URASHG PID {self.pid_channel.value} power setpoint set to {voltage_value:.3f}V", 'log']))
                else:
                    error_msg = f"Failed to set power setpoint to {voltage_value:.3f}V"
                    logger.error(error_msg)
                    self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
                    
            except Exception as e:
                error_msg = f"Error setting power setpoint: {str(e)}"
                logger.error(error_msg)
                self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))

    def move_rel(self, value: DataActuator):
        """
        Move the PID setpoint by a relative amount for fine power adjustment.

        Parameters
        ----------
        value: DataActuator
            Relative change in setpoint voltage value
        """
        # Calculate new absolute position with bounds checking
        value = self.check_bound(self.current_position + value) - self.current_position
        self.target_value = value + self.current_position
        
        # Apply scaling if configured
        value = self.set_position_relative_with_scaling(value)
        
        # Calculate absolute target
        current_setpoint = self.get_actuator_value().value('V')
        new_setpoint = current_setpoint + value.value('V')
        
        if self.mock_mode:
            # Mock mode operation
            self.mock_setpoint = new_setpoint
            self.emit_status(ThreadCommand('Update_Status', 
                [f"Mock URASHG PID setpoint adjusted by {value.value('V'):+.3f}V to {new_setpoint:.3f}V", 'log']))
        else:
            if not self.controller or not self.controller.is_connected:
                error_msg = "Cannot adjust power setpoint: controller not connected"
                logger.error(error_msg)
                self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
                return
            
            try:
                success = self.controller.set_pid_setpoint(self.pid_channel, new_setpoint)
                
                if success:
                    self.emit_status(ThreadCommand('Update_Status', 
                        [f"URASHG PID {self.pid_channel.value} power setpoint adjusted by "
                         f"{value.value('V'):+.3f}V to {new_setpoint:.3f}V", 'log']))
                else:
                    error_msg = f"Failed to adjust power setpoint by {value.value('V'):+.3f}V"
                    logger.error(error_msg)
                    self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))
                    
            except Exception as e:
                error_msg = f"Error adjusting power setpoint: {str(e)}"
                logger.error(error_msg)
                self.emit_status(ThreadCommand('Update_Status', [error_msg, 'log']))

    def move_home(self):
        """
        Move the PID setpoint to the home position (zero power correction).
        
        This provides a known reference position for laser power control.
        """
        home_position = DataActuator(data=0.0, units='V')
        
        self.emit_status(ThreadCommand('Update_Status', 
            ['Moving URASHG PID power setpoint to home position (0V)', 'log']))
        
        # Use move_abs to go to zero position
        self.move_abs(home_position)

    def stop_motion(self):
        """
        Stop any ongoing motion and maintain current power setpoint.
        
        For PID setpoint control, this doesn't stop physical motion but
        ensures the current power setpoint is maintained.
        """
        if self.mock_mode:
            self.emit_status(ThreadCommand('Update_Status', 
                [f"Mock URASHG PID motion stopped at {self.mock_setpoint:.3f}V", 'log']))
        else:
            if self.controller and self.controller.is_connected:
                try:
                    # Read current setpoint to confirm it's stable
                    current_setpoint = self.controller.get_pid_setpoint(self.pid_channel)
                    if current_setpoint is not None:
                        self.emit_status(ThreadCommand('Update_Status', 
                            [f"URASHG PID {self.pid_channel.value} motion stopped at {current_setpoint:.3f}V", 'log']))
                    else:
                        self.emit_status(ThreadCommand('Update_Status', 
                            [f"URASHG PID {self.pid_channel.value} motion stopped", 'log']))
                except Exception as e:
                    logger.error(f"Error in stop_motion: {e}")
                    self.emit_status(ThreadCommand('Update_Status', 
                        [f"URASHG PID motion stopped (status read error: {str(e)})", 'log']))
            else:
                self.emit_status(ThreadCommand('Update_Status', 
                    ["URASHG PID motion stopped (controller not connected)", 'log']))


if __name__ == '__main__':
    main(__file__)