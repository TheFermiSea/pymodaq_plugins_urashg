This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    python-publish.yml
    tests.yml
    updater.yml
src/
  pymodaq_gui/
    examples/
      curves.py
      custom_viewer.py
      data_picker.py
      listwidget.py
      parameter_ex.py
    h5modules/
      __init__.py
      browsing.py
      h5browser.py
      saving.py
      utils.py
    managers/
      __init__.py
      action_manager.py
      parameter_manager.py
      roi_manager.py
    parameter/
      pymodaq_ptypes/
        __init__.py
        bool.py
        date.py
        filedir.py
        itemselect.py
        led.py
        list.py
        numeric.py
        pixmap.py
        slide.py
        table.py
        tableview.py
        text.py
      __init__.py
      ioxml.py
      utils.py
    plotting/
      data_viewers/
        __init__.py
        base.py
        viewer.py
        viewer0D.py
        viewer1D.py
        viewer1Dbasic.py
        viewer2D_basic.py
        viewer2D.py
        viewerND.py
      items/
        axis_scaled.py
        crosshair.py
        image.py
      plotter/
        plotters/
          qt_plotters.py
      utils/
        axes_viewer.py
        filter.py
        lineout.py
        plot_utils.py
      gant_chart.py
      image_viewer.py
      navigator.py
      widgets.py
    QtDesigner_Ressources/
      credit.rst
      icons.svg
    utils/
      widgets/
        __init__.py
        label.py
        lcd.py
        push.py
        qled.py
        spinbox.py
        table.py
        tree_layout.py
        tree_toml.py
        widget_bkg.py
      __init__.py
      custom_app.py
      dock.py
      file_io.py
      layout.py
      list_picker.py
      splash.py
      utils.py
    __init__.py
    config_saver_loader.py
    messenger.py
    qt_utils.py
    qvariant.py
tests/
  data/
    preset_default.xml
  h5module_test/
    saving_test.py
  managers/
    action_manager_test.py
    parameter_manager_test.py
  parameter_test/
    param_ioxml_test.py
    param_ptypes_test.py
    param_str_test.py
    param_utils_test.py
  plotting_test/
    data_viewers_test/
      ploting_data_all_test.py
      viewer0D_test.py
      viewer1D_test.py
      viewer1Dbasic_test.py
      viewer2D_basic_test.py
      viewer2D_test.py
      viewerND_test.py
    utils/
      lineout_test.py
      plot_utils_test.py
    navigator_test.py
  utils/
    widgets/
      spinbox_test.py
    config_test.py
    dock_test.py
    utils_test.py
.gitattributes
.gitignore
CITATION.cff
CREDITS.md
LICENSE
MANIFEST.in
pyproject.toml
README.rst
readthedocs.yml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/python-publish.yml">
# This workflow will upload a Python Package using Twine when a release is created
# For more information see: https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#publishing-to-package-registries

name: Upload Python Package

on:
  release:
    types: [created]

jobs:
  build:

    runs-on: ubuntu-latest
          
    steps:
    - uses: actions/checkout@v4.2.2
    - name: Set up Python
      uses: actions/setup-python@v5.6.0
      with:
        python-version: '3.11'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install hatch hatchling
    - name: Build
      run: hatch build
    - name: publish
      env:
        HATCH_INDEX_USER: ${{ secrets.PYPI_USERNAME }}
        HATCH_INDEX_AUTH: ${{ secrets.PYPI_PASSWORD }}
      run: |
        hatch publish
</file>

<file path=".github/workflows/tests.yml">
name: tests

on:
  workflow_call:
  
  pull_request:

  push:
    branches:
    - '*'
    - '!badges' # to exclude execution if someone pushes on this branch (shouldn't happen)

concurrency:
  # github.workflow: name of the workflow
  # github.event.pull_request.number || github.ref: pull request number or branch name if not a pull request
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  # Cancel in-progress runs when a new workflow with the same group name is triggered
  cancel-in-progress: true
  
jobs:
  tests:
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        os: ["ubuntu-latest", "windows-latest"]
        python-version: ["3.9", "3.10", "3.11", "3.12"]
        qt-backend: ["pyqt5", "pyqt6", "pyside6"]
    runs-on: ${{ matrix.os }}
    env:
      DISPLAY: ':99'
      QT_DEBUG_PLUGINS: 1

    steps:     
      # Get the branch name for the badge generation
      - name: Extract branch name
        shell: bash
        run: echo "branch=${GITHUB_REF#refs/heads/}" >> "${GITHUB_OUTPUT}"
        id: extract_branch
        

      - name: Checkout the repo
        uses: actions/checkout@v4.2.2
 
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest pytest-cov pytest-qt pytest-xvfb pytest-xdist setuptools wheel numpy h5py ${{ matrix.qt-backend }}
          pip install -e .    
      
      # Create folder and set permissions on Ubuntu
      - name: Create local pymodaq folder setup env (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt update
          sudo apt install -y  yaru-theme-icon libxkbcommon-x11-0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-cursor0 libxcb-randr0 libxcb-render-util0 libxcb-xinerama0 libxcb-xfixes0 x11-utils libgl1 libegl1
          export QT_DEBUG_PLUGINS=1
          
          echo "XDG_CURRENT_DESKTOP=Unity" >> $GITHUB_ENV
          echo "XDG_DATA_DIRS=/usr/share:/usr/share/icons:/usr/local/share" >> $GITHUB_ENV
          echo "GTK_THEME=Yaru" >> $GITHUB_ENV

          sudo mkdir -p /etc/.pymodaq
          sudo chmod uo+rw /etc/.pymodaq
      - name: Exporting debug variables (Windows)
        if: runner.os == 'Windows'
        run: |
          set QT_DEBUG_PLUGINS=1
      - name: Linting with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=docs
      - name: Tests with ${{ matrix.os }} ${{ matrix.python-version }} ${{ matrix.qt-backend}}
        id: tests
        run: |
          mkdir coverage
          pytest -vv --cov=pymodaq_gui -n 1
          mv .coverage coverage/coverage_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.qt-backend }}
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4.6.2
        with:
          name: coverage-${{ matrix.os }}-${{ matrix.python-version }}_${{ matrix.qt-backend }}
          path: coverage/coverage_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.qt-backend }}


     
      - name: Create destination directory
        if: ${{ always() }}
        run: |
          mkdir -p "${{ steps.extract_branch.outputs.branch }}"

      - name: generate badge (success)
        if: ${{ success() }}
        uses: emibcn/badge-action@v2.0.3
        with:
          label: ''
          status: 'passing'
          color: 'green'
          path: '${{ steps.extract_branch.outputs.branch }}/tests_${{runner.os}}_${{matrix.python-version}}_${{matrix.qt-backend}}.svg'
      - name: generate badge (fail)
        if: ${{ failure() }}
        uses: emibcn/badge-action@v2.0.3
        with:
          label: ''
          status: 'failing'
          color: 'red'
          path: '${{ steps.extract_branch.outputs.branch }}/tests_${{runner.os}}_${{matrix.python-version}}_${{matrix.qt-backend}}.svg'


      - name: Upload badge artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4.6.2
        with:
          name:  tests_${{runner.os}}_${{matrix.python-version}}_${{matrix.qt-backend}}
          path: '${{ steps.extract_branch.outputs.branch }}/tests_${{runner.os}}_${{matrix.python-version}}_${{matrix.qt-backend}}.svg'
          if-no-files-found: error 
    
    outputs:
      branch: ${{ steps.extract_branch.outputs.branch }}
     
  badge-update:
    if: github.repository_owner == 'PyMoDAQ'
    runs-on: ubuntu-latest
    needs: tests # Ensure this job runs after all matrix jobs complete
    steps:
       # switch to badges branches to commit
      - uses: actions/checkout@v4.2.2
        with:
          ref: badges
     
      - name: Download badges
        uses: actions/download-artifact@v4.3.0

      - name: Reorganize badges
        run: |
          rm -rf coverage* || true
          rm -rf $(git ls-files ${{ needs.tests.outputs.branch }}/*) || true
          git rm $(git ls-files ${{ needs.tests.outputs.branch }}/*) || true

          mkdir -p '${{ needs.tests.outputs.branch }}'
          mv tests_*/*.svg '${{ needs.tests.outputs.branch }}'
      - name: Commit badges
        continue-on-error: true
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add ${{ needs.tests.outputs.branch }}
          git commit  --allow-empty -m "Add/Update badge"

      - name: Push badges
        uses: ad-m/github-push-action@v0.8.0
        if: ${{ success() }}
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: badges
  coverage-update:
    runs-on: ubuntu-latest
    needs: tests # Ensure this job runs after all matrix jobs complete

    steps:
      - name: Checkout the repo
        uses: actions/checkout@v4.2.2

      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4.3.0
        with:
          path: ./coverage-reports

      - name: Reorganize reports
        run: |
          cd coverage-reports
          rm -rf tests_*
          for folder in *; do
            mv "${folder}"/* .;
          done;
          rmdir --ignore-fail-on-non-empty * || true
          cd ..
      # We only combine linux reports otherwise the tool complains about windows directories ...
      - name: Combine coverage reports
        run: |
          python -m pip install coverage
          coverage combine ./coverage-reports/coverage_*
          coverage xml -i

      - name: Upload combined coverage report to Codecov
        uses: codecov/codecov-action@v5.4.3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: coverage.xml
</file>

<file path=".github/workflows/updater.yml">
name: GitHub Actions Version Updater

# Controls when the action will run.
on:
  schedule:
    # Automatically run at 00:00 on day-of-month 5.
    - cron:  '0 0 5 * *'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4.2.2
        with:
          # [Required] Access token with `workflow` scope.
          token: ${{ secrets.WORKFLOW_SECRET }}

      - name: Run GitHub Actions Version Updater
        uses: saadmk11/github-actions-version-updater@v0.8.1
        with:
          # [Required] Access token with `workflow` scope.
          token: ${{ secrets.WORKFLOW_SECRET }}
</file>

<file path="src/pymodaq_gui/examples/curves.py">
class Curve(GraphicsObject)
⋮----
"""
    **Bases:** :class:`GraphicsObject <pyqtgraph.GraphicsObject>`

    Item displaying an isocurve of a 2D array. To align this item correctly with an
    ImageItem, call ``isocurve.setParentItem(image)``.
    """
⋮----
def __init__(self, pen='w')
⋮----
"""
        Create a new isocurve item.

        ==============  ===============================================================
        **Arguments:**
        data            A 2-dimensional ndarray. Can be initialized as None, and set
                        later using :func:`setData <pyqtgraph.IsocurveItem.setData>`
        level           The cutoff value at which to draw the isocurve.
        pen             The color of the curve item. Can be anything valid for
                        :func:`mkPen <pyqtgraph.mkPen>`
        axisOrder       May be either 'row-major' or 'col-major'. By default this uses
                        the ``imageAxisOrder``
                        :ref:`global configuration option <apiref_config>`.
        ==============  ===============================================================
        """
⋮----
def setData(self, data, level=None)
⋮----
"""
        Set the data/image to draw isocurves for.

        ==============  ========================================================================
        **Arguments:**
        data            A 2-dimensional ndarray.
        level           The cutoff value at which to draw the curve. If level is not specified,
                        the previously set level is used.
        ==============  ========================================================================
        """
⋮----
def setPen(self, *args, **kwargs)
⋮----
"""Set the pen used to draw the isocurve. Arguments can be any that are valid
        for :func:`mkPen <pyqtgraph.mkPen>`"""
⋮----
def setBrush(self, *args, **kwargs)
⋮----
"""Set the brush used to draw the isocurve. Arguments can be any that are valid
        for :func:`mkBrush <pyqtgraph.mkBrush>`"""
⋮----
def boundingRect(self)
⋮----
def generatePath(self)
⋮----
def paint(self, p, *args)
⋮----
def main(data_distribution='uniform')
⋮----
"""either 'uniform' or 'spread'"""
⋮----
app = QtWidgets.QApplication(sys.argv)
widget = QtWidgets.QWidget()
⋮----
widget_button = QtWidgets.QWidget()
⋮----
button = QtWidgets.QPushButton('New Data')
ndata = QtWidgets.QSpinBox()
⋮----
def print_data(data: DataToExport)
⋮----
data_to_plot = generate_uniform_data()
⋮----
prog = Viewer2D(widget)
⋮----
curve = Curve()
⋮----
def generate_uniform_data() -> DataRaw
⋮----
Nx = 100
Ny = 2 * Nx
data_random = np.random.normal(size=(Ny, Nx))
x = 0.5 * np.linspace(-Nx / 2, Nx / 2 - 1, Nx)
y = 0.2 * np.linspace(-Ny / 2, Ny / 2 - 1, Ny)
data_red = 3 * np.sin(x / 5) ** 2 * gauss2D(x, 5, Nx / 10, y, -1, Ny / 10, 1, 90) + 0.2 * data_random
data_green = 10 * gauss2D(x, -20, Nx / 10, y, -10, Ny / 20, 1, 0)
⋮----
data_to_plot = DataRaw(name='mydata', distribution='uniform',
</file>

<file path="src/pymodaq_gui/examples/custom_viewer.py">
class ViewerPointList(QObject)
⋮----
def __init__(self, area)
⋮----
@Slot(float, float)
    def double_click_action(self, posx, posy)
⋮----
data_at = self.viewer.view.get_data_at('red', (xs, ys))
⋮----
def show_data(self, data)
⋮----
def setXaxis(self, xaxis)
⋮----
def setYaxis(self, yaxis)
⋮----
def set_viewer(self)
⋮----
dock_viewer = Dock('Viewer2D')
⋮----
widget = QtWidgets.QWidget()
⋮----
def set_point_list(self)
⋮----
dock_list = Dock('List of points')
⋮----
params = [{'title': 'Positions', 'name': 'tabular_table', 'type': 'table_view',
⋮----
init_data = [[0., 0., 0.]]
⋮----
styledItemDelegate = QtWidgets.QStyledItemDelegate()
⋮----
app = QtWidgets.QApplication(sys.argv)
area = DockArea()
win = QtWidgets.QMainWindow()
⋮----
viewer = ViewerPointList(area)
⋮----
Nx = 100
Ny = 200
x = (np.linspace(0, Nx - 1, Nx) + 100) / 2
y = (np.linspace(0, Ny - 1, Ny) - 10) * 2
⋮----
data_red = 3 * gauss2D(x, np.mean(x), (np.max(x)-np.min(x)) / 5, y, np.mean(y), (np.max(y)-np.min(y)) / 5, 1)
⋮----
data_to_plot = DataFromPlugins(name='mydata', distribution='uniform', data=[data_red],
</file>

<file path="src/pymodaq_gui/examples/data_picker.py">
class DataPicker(CustomApp)
⋮----
params = [
⋮----
def __init__(self, area: DockArea)
⋮----
def setup_docks(self)
⋮----
widget = QtWidgets.QWidget()
⋮----
def setup_actions(self)
⋮----
def setup_menu(self)
⋮----
action_menu = self._menubar.addMenu('Actions')
⋮----
def connect_things(self)
⋮----
def double_click_action(self, posx: float, posy: float)
⋮----
data_at = self.viewer.view.get_data_at('red', (xs, ys))
⋮----
def show_data(self, data: DataRaw)
⋮----
def setup_table(self)
⋮----
init_data = [[0., 0., 0.]]
⋮----
styledItemDelegate = QtWidgets.QStyledItemDelegate()
⋮----
def main()
⋮----
app = mkQApp('DataPicker')
area = DockArea()
win = QtWidgets.QMainWindow()
⋮----
data_picker = DataPicker(area)
⋮----
Nx = 100
Ny = 200
x = (np.linspace(0, Nx - 1, Nx) + 100) / 2
y = (np.linspace(0, Ny - 1, Ny) - 10) * 2
⋮----
data_red = 3 * gauss2D(x, np.mean(x), (np.max(x)-np.min(x)) / 5, y, np.mean(y), (np.max(y)-np.min(y)) / 5, 1)
⋮----
data_to_plot = DataRaw(name='mydata', distribution='uniform', data=[data_red],
</file>

<file path="src/pymodaq_gui/examples/listwidget.py">
class MyListWidget(QtWidgets.QListWidget)
⋮----
def sizeHint(self)
⋮----
def main()
⋮----
app = QtWidgets.QApplication(sys.argv)
⋮----
lw = MyListWidget()
⋮----
item = QtWidgets.QListWidgetItem(f'item{ind}')
⋮----
#lw.updateGeometry()
⋮----
itemsel = ItemSelect()
</file>

<file path="src/pymodaq_gui/examples/parameter_ex.py">
"""
S Weber  2020
Examples of custome parameter types derived from pyqtgraph
"""
⋮----
class ParameterEx(ParameterManager)
⋮----
params = [
⋮----
{'title': 'An hidden group:', 'name': 'bgroup', 'type': 'group', 'children': [], 'visible': False},  # this
# visible option is not available in usual pyqtgraph group
⋮----
{'title': 'An action', 'name': 'action', 'type': 'action'},  # action whose displayed text corresponds to title
⋮----
]},  # The advantage of the Table model lies in its modularity for concrete examples see the
# TableModelTabular and the TableModelSequential custom models in the pymodaq.utils.scanner module
⋮----
def __init__(self)
⋮----
def value_changed(self, param)
⋮----
"""
        """
⋮----
limits = (param.value(),
⋮----
limits = (self.settings.child('numbers', 'linearslidefloatlimits').opts['limits'][0],
self.settings.child('numbers', 'linearslidefloatlimits').setLimits(limits) #either like this: preferred
self.settings.child('numbers', 'linearslidefloat').setOpts(bounds=limits) # or like this!
⋮----
def options_changed(self, param, data: dict)
⋮----
def limits_changed(self, param, data)
⋮----
def main()
⋮----
app = mkQApp('Parameters')
⋮----
ptree = ParameterEx()
</file>

<file path="src/pymodaq_gui/h5modules/__init__.py">

</file>

<file path="src/pymodaq_gui/h5modules/browsing.py">
# -*- coding: utf-8 -*-
"""
Created the 15/11/2022

@author: Sebastien Weber
"""
⋮----
config = Config()
logger = set_logger(get_module_name(__file__))
⋮----
class View(QObject)
⋮----
item_clicked_sig = Signal(object)
item_double_clicked_sig = Signal(object)
⋮----
def __init__(self, widget: QtWidgets.QWidget, settings_tree, settings_attributes_tree)
⋮----
def setup_ui(self, settings_tree, settings_attributes_tree)
⋮----
layout = QtWidgets.QGridLayout()
⋮----
v_splitter = QtWidgets.QSplitter(Qt.Vertical)
v_splitter2 = QtWidgets.QSplitter(Qt.Vertical)
h_splitter = QtWidgets.QSplitter(Qt.Horizontal)
⋮----
widget = QtWidgets.QWidget()
# self.ui.h5file_tree = TreeLayout(Form,col_counts=2,labels=["Node",'Pixmap'])
⋮----
def current_node_path(self)
⋮----
def add_actions(self, actions: List[QtWidgets.QAction])
⋮----
@property
    def viewer_widget(self)
⋮----
@property
    def text_list(self)
⋮----
@property
    def pixmap_widget(self)
⋮----
def clear(self)
⋮----
def add_base_item(self, base_tree_item)
⋮----
def add_widget_to_tree(self, pixmap_items)
⋮----
vLayout = QtWidgets.QVBoxLayout()
label1D = QtWidgets.QLabel()
bytes = QByteArray(item['node'].attrs['pixmap1D'])
im1 = QtGui.QImage.fromData(bytes)
a = QtGui.QPixmap.fromImage(im1)
⋮----
label2D = QtWidgets.QLabel()
bytes = QByteArray(item['node'].attrs['pixmap2D'])
im2 = QtGui.QImage.fromData(bytes)
b = QtGui.QPixmap.fromImage(im2)
⋮----
class H5Browser(QObject, ActionManager)
⋮----
"""UI used to explore h5 files, plot and export subdatas

    Parameters
    ----------
    parent: QtWidgets container
        either a QWidget or a QMainWindow
    h5file: h5file instance
        exact type depends on the backend
    h5file_path: str or Path
        if specified load the corresponding file, otherwise open a select file dialog
    backend: str
        either 'tables, 'h5py' or 'h5pyd'

    See Also
    --------
    H5Backend, H5Backend
    """
data_node_signal = Signal(str)  # the path of a node where data should be monitored, displayed...
# whatever use from the caller
status_signal = Signal(str)
⋮----
def __init__(self, parent: QtWidgets.QMainWindow, h5file=None, h5file_path=None, backend='tables')
⋮----
# toolbar = QtWidgets.QToolBar()
ActionManager.__init__(self)  # , toolbar=toolbar)
⋮----
#self.main_window.addToolBar(self.toolbar)
⋮----
# construct the UI interface
⋮----
# construct the h5 interface and load the file (or open a select file message)
⋮----
def connect_things(self)
⋮----
def get_node_and_plot(self, with_bkg, plot_all=False)
⋮----
def load_file(self, h5file=None, h5file_path=None)
⋮----
h5file_path = select_file(save=False, ext=['h5', 'hdf5'])
⋮----
def setup_menu(self)
⋮----
menubar = self.main_window.menuBar()
file_menu = menubar.addMenu('File')
⋮----
help_menu = menubar.addMenu('?')
⋮----
def setup_actions(self)
⋮----
def check_version(self)
⋮----
"""Check version of PyMoDAQ to assert if file is compatible or not with the current version of the Browser"""
⋮----
msg_box = messagebox(severity='warning', title='Invalid version',
⋮----
def add_comments(self, status: bool, comment='')
⋮----
"""Add comments to a node

        Parameters
        ----------
        status: bool
        comment: str
            The comment to be added in a comment attribute to the current node path

        See Also
        --------
        current_node_path
        """
⋮----
node = self.h5utils.get_node(self.current_node_path)
⋮----
tmp = node.attrs['comments']
⋮----
tmp = ''
⋮----
comment = text
⋮----
def get_tree_node_path(self)
⋮----
"""Get the node path of the currently selected node in the UI"""
⋮----
def export_data(self)
⋮----
"""Opens a dialog to export data

        See Also
        --------
        H5BrowserUtil.export_data
        """
⋮----
file_filter = ExporterFactory.get_file_filters()
⋮----
def save_file(self, filename=None)
⋮----
filename = select_file(save=True, ext='txt')
⋮----
def quit_fun(self)
⋮----
"""
        """
⋮----
def show_about(self)
⋮----
splash_path = os.path.join(os.path.split(os.path.split(__file__)[0])[0], 'splash.png')
splash = QtGui.QPixmap(splash_path)
⋮----
@staticmethod
    def show_log()
⋮----
@staticmethod
    def show_help()
⋮----
@staticmethod
    def add_log(txt)
⋮----
def show_h5_attributes(self, item=None)
⋮----
params = []
⋮----
QtWidgets.QApplication.processEvents()  # so that the tree associated with settings updates
params = ioxml.XML_string_to_parameter(settings)
⋮----
params = ioxml.XML_string_to_parameter(scan_settings)
⋮----
def show_pixmaps(self, pixmaps=[])
⋮----
child = self.view.pixmap_widget.layout().takeAt(0)
⋮----
labs = []
⋮----
def show_h5_data(self, item, with_bkg=False, plot_all=False)
⋮----
"""

        Parameters
        ----------
        item
        with_bkg
        plot_all

        Returns
        -------

        """
⋮----
data_with_axes = self.data_loader.load_data(node, with_bkg=with_bkg, load_all=plot_all)
⋮----
def populate_tree(self)
⋮----
"""
            | Init the ui-tree and store data into calling the h5_tree_to_Qtree convertor method

            See Also
            --------
            h5tree_to_QTree, update_status
        """
⋮----
base_node = self.h5utils.root()
⋮----
def browse_data(fname=None, ret_all=False, message=None) -> Tuple[data_saving.DataWithAxes, str, str]
⋮----
"""Browse data present in any h5 file using the H5Browser within a dialog window
    when the user has selected a given node, return its content

    Parameters
    ----------
    fname: str
    ret_all: bool
    message: str

    Returns
    -------
    data: DataWithAxes
    if argument ret_all is True, returns also:
    fname: the file name
    node_path: hte path of the selected node within the H5 file tree

    """
⋮----
fname = str(select_file(start_path=config('data_saving', 'h5file', 'save_path'), save=False, ext='h5'))
⋮----
fname = str(fname)
⋮----
form = QtWidgets.QMainWindow()
browser = H5Browser(form, h5file_path=fname)
dataloader = data_saving.DataLoader(browser.h5utils)
dialog = QtWidgets.QDialog()
vlayout = QtWidgets.QVBoxLayout()
⋮----
buttonBox = QtWidgets.QDialogButtonBox(parent=dialog)
⋮----
res = dialog.exec()
⋮----
node_path = browser.current_node_path
data = dataloader.load_data(node_path, with_bkg=True)
⋮----
data = None
node_path = None
</file>

<file path="src/pymodaq_gui/h5modules/h5browser.py">
config = Config()
⋮----
def main(h5file_path: Path = None)
⋮----
app = mkQApp('H5Browser')
⋮----
h5file_path_tmp = None
parser = argparse.ArgumentParser(description="Opens HDF5 files and navigate their contents")
⋮----
args = parser.parse_args()
⋮----
h5file_path_tmp = Path(args.input).resolve()  # Transform to absolute Path in case it is relative
⋮----
h5file_path_tmp = h5file_path
⋮----
win = QtWidgets.QMainWindow()
prog = H5Browser(win, h5file_path=h5file_path_tmp)
</file>

<file path="src/pymodaq_gui/h5modules/saving.py">
# -*- coding: utf-8 -*-
"""
Created the 15/11/2022

@author: Sebastien Weber
"""
⋮----
config = Config()
logger = set_logger(get_module_name(__file__))
⋮----
dashboard_submodules_params = [
⋮----
class H5SaverBase(H5SaverLowLevel, ParameterManager)
⋮----
"""Object containing all methods in order to save datas in a *hdf5 file* with a hierarchy
    compatible with the H5Browser. The saving parameters are contained within a **Parameter**
    object: self.settings that can be displayed on a UI using the widget self.settings_tree.
    At the creation of a new file, a node group named **Raw_data** and represented by the attribute
    ``raw_group`` is created and set with a metadata attribute:

    * 'type' given by the **save_type** class parameter

    The root group of the file is then set with a few metadata:

    * 'pymodaq_version' the current pymodaq version, e.g. 1.6.2
    * 'pymodaq_data_version' the current pymodaq_data version, e.g. 0.0.1
    * 'file' the file name
    * 'date' the current date
    * 'time' the current time

    All data will then be saved under this node in various groups

    See Also
    --------
    H5Browser

    Parameters
    ----------
    h5_file: pytables hdf5 file
             object used to save all datas and metadas
    h5_file_path: str or Path
                  Signal signal represented by a float. Is emitted each time the hardware reached the target
                  position within the epsilon precision (see comon_parameters variable)
    save_type: str
       an element of the enum module attribute SaveType
       * 'scan' is used for DAQScan module and should be used for similar application
       * 'detector' is used for DAQ_Viewer module and should be used for similar application
       * 'custom' should be used for customized applications

    Attributes
    ----------

    settings: Parameter
               Parameter instance (pyqtgraph) containing all settings (could be represented using the settings_tree widget)

    settings_tree: ParameterTree
                   Widget representing as a Tree structure, all the settings defined in the class preamble variable ``params``

    """
settings_name = 'h5saver_settings'
params = [
⋮----
def __init__(self, save_type='scan', backend='tables')
⋮----
"""

        Parameters
        ----------
        save_type (str): one of ['scan', 'detector', 'logger', 'custom']
        backend (str): either 'tables' for pytables backend, 'h5py' for h5py backends or 'h5pyd' for HSDS backend

        See Also
        --------
        https://github.com/HDFGroup/hsds
        """
⋮----
def show_settings(self, show=True)
⋮----
"""Initializes a new h5 file.
        Could set the h5_file attributes as:

        * a file with a name following a template if ``custom_naming`` is ``False`` and ``addhoc_file_path`` is ``None``
        * a file within a name set using a file dialog popup if ``custom_naming`` is ``True``
        * a file with a custom name if ``addhoc_file_path`` is a ``Path`` object or a path string

        Parameters
        ----------
        update_h5: bool
                   create a new h5 file with name specified by other parameters
                   if false try to open an existing file and will append new data to it
        custom_naming: bool
                       if True, a selection file dialog opens to set a new file name
        addhoc_file_path: Path or str
                          supplied name by the user for the new file
        metadata: dict
                    dictionnary with pair of key, value that should be saved as attributes of the root group
        Returns
        -------
        update_h5: bool
                   True if new file has been created, False otherwise
        """
datetime_now = datetime.datetime.now()
⋮----
# set the filename and path
base_name = self.settings['base_name']
⋮----
custom_naming = self.settings['custom_name']
⋮----
scan_type = self.settings['save_type'] == 'scan'
⋮----
self.h5_file_path = save_path.parent  # will remove the dataset part used for DAQ_scan datas
⋮----
addhoc_file_path = Path(addhoc_file_path)
⋮----
fullpathname = self.h5_file_path.joinpath(self.h5_file_name)
⋮----
def update_file_paths(self, update_h5=False)
⋮----
"""

        Parameters
        ----------
        update_h5: bool
                   if True, will increment the file name and eventually the current scan index
                   if False, get the current scan index in the h5 file

        Returns
        -------
        scan_path: Path
        current_filename: str
        dataset_path: Path

        """
⋮----
base_path = self.settings['base_path']
⋮----
current_scan = self.settings['current_scan_name']
⋮----
ind_dataset = None
⋮----
next_scan_index = 0
update_h5 = True  # just started the main program so one should create a new h5
⋮----
next_scan_index = self.get_scan_index()
⋮----
ind_dataset = int(os.path.splitext(self.h5_file_name)[0][-3:])
⋮----
curr_date = datetime.date.fromisoformat(self.get_attr(self.root(), 'date'))
⋮----
curr_date = parser.parse(self.get_attr(self.root(), 'date')).date()
⋮----
curr_date = datetime.date.today()
⋮----
@classmethod
    def find_part_in_path_and_subpath(cls, base_dir, part='', create=False, increment=True)
⋮----
"""
        Find path from part time.

        =============== ============ =============================================
        **Parameters**  **Type**      **Description**
        *base_dir*      Path object   The directory to browse
        *part*          string        The date of the directory to find/create
        *create*        boolean       Indicate the creation flag of the directory
        =============== ============ =============================================

        Returns
        -------
        Path object
            found path from part
        """
found_path = None
if part in base_dir.parts:  # check if current year is in the given base path
⋮----
found_path = base_dir
⋮----
tmp_path = base_dir.parents[ind]
⋮----
found_path = base_dir.parents[ind]
⋮----
else:  # if not check if year is in the subfolders
subfolders_year_name = [x.name for x in base_dir.iterdir() if x.is_dir()]
subfolders_found_path = [x for x in base_dir.iterdir() if x.is_dir()]
⋮----
found_path = base_dir.joinpath(part)
⋮----
ind_path = subfolders_year_name.index(part)
found_path = subfolders_found_path[ind_path]
⋮----
"""

        Parameters
        ----------
        base_dir
        base_name
        update_h5
        next_scan_index
        create_scan_folder
        create_dataset_folder

        Returns
        -------

        """
base_dir = Path(base_dir)
⋮----
year_path = cls.find_part_in_path_and_subpath(base_dir, part=str(curr_date.year),
⋮----
create=True)  # create directory of the year if it doen't exist and return it
day_path = cls.find_part_in_path_and_subpath(year_path, part=curr_date.strftime('%Y%m%d'),
⋮----
create=True)  # create directory of the day if it doen't exist and return it
dataset_base_name = curr_date.strftime('Dataset_%Y%m%d')
dataset_paths = sorted([path for path in day_path.glob(dataset_base_name + "*"+".h5") if path.is_file()])
⋮----
ind_dataset = 0
⋮----
ind_dataset = int(dataset_paths[-1].stem.partition(dataset_base_name + "_")[2]) + 1
⋮----
ind_dataset = int(dataset_paths[-1].stem.partition(dataset_base_name + "_")[2])
⋮----
dataset_path = cls.find_part_in_path_and_subpath(day_path,
scan_paths = sorted([path for path in dataset_path.glob(base_name + '*') if path.is_dir()])
ind_scan = next_scan_index
⋮----
def get_last_scan(self)
⋮----
"""Gets the last scan node within the h5_file and under the **raw_group**

        Returns
        -------
        scan_group: pytables group or None


        """
⋮----
def get_scan_groups(self)
⋮----
def get_scan_index(self)
⋮----
""" return the scan group index in the "scan templating": Scan000, Scan001 as an integer
        """
⋮----
last_scan = self.get_last_scan()
⋮----
def load_file(self, base_path=None, file_path=None)
⋮----
"""Opens a file dialog to select a h5file saved on disk to be used

        Parameters
        ----------
        base_path
        file_path

        See Also
        --------
        :py:meth:`init_file`

        """
⋮----
base_path = self.settings.child('base_path').value()
⋮----
base_path = None
⋮----
file_path = select_file(base_path, save=False, ext='h5')
⋮----
file_path = Path(file_path)
⋮----
def save_file(self, filename=None)
⋮----
filename = select_file(None, save=True, ext='h5')
⋮----
def value_changed(self, param)
⋮----
compression = self.settings.child('compression_options', 'h5comp_library').value()
compression_opts = self.settings.child('compression_options', 'h5comp_level').value()
⋮----
def update_status(self, status)
⋮----
class H5Saver(H5SaverBase, QObject)
⋮----
"""
    status_sig: Signal
                emits a signal of type Threadcommand in order to senf log information to a main UI
    new_file_sig: Signal
                  emits a boolean signal to let the program know when the user pressed the new file button on the UI
    """
⋮----
status_sig = Signal(utils.ThreadCommand)
new_file_sig = Signal(bool)
⋮----
def __init__(self, *args, **kwargs)
⋮----
"""

        Parameters
        ----------
        args
        kwargs
        """
⋮----
def close(self)
⋮----
def emit_new_file(self, status)
⋮----
"""Emits the new_file_sig

        Parameters
        ----------
        status: bool
                emits True if a new file has been asked by the user pressing the new file button on the UI
        """
⋮----
def show_file_content(self)
⋮----
win = QtWidgets.QMainWindow()
</file>

<file path="src/pymodaq_gui/h5modules/utils.py">
# -*- coding: utf-8 -*-
"""
Created the 19/01/2023

@author: Sebastien Weber and N Tappy
"""
</file>

<file path="src/pymodaq_gui/managers/__init__.py">

</file>

<file path="src/pymodaq_gui/managers/action_manager.py">
here = Path(__file__).parent
icon_folder = here.parent.joinpath('QtDesigner_Ressources/Icon_Library/')
⋮----
def create_icon(icon_name: Union[str, Path])
⋮----
icon = QtGui.QIcon()
if Path(icon_name).is_file(): # Test if icon is in path
⋮----
pixmap = QtGui.QPixmap(f"icons:{icon_name}.png") # Test if icon is in pymodaq's library
⋮----
if hasattr(QtGui.QIcon,'ThemeIcon') and hasattr(QtGui.QIcon.ThemeIcon, icon_name): # Test if icon is in Qt's library
icon = QtGui.QIcon.fromTheme(getattr(QtGui.QIcon.ThemeIcon, icon_name))
⋮----
class QAction(QAction)
⋮----
"""
    QAction subclass to mimic signals as pushbuttons. Done to be sure of backcompatibility
    when I moved from pushbuttons to QAction
    """
def __init__(self, *args, **kwargs)
⋮----
def click(self)
⋮----
@property
    def clicked(self)
⋮----
def connect_to(self, slot)
⋮----
def set_icon(self, icon_name: str)
⋮----
def __repr__(self)
⋮----
"""Create a new action and add it eventually to a toolbar and a menu

    Parameters
    ----------
    name: str
        Displayed name if should be displayed (for instance in menus)
    icon_name: str / Path / QtGui.QIcon / enum name
        str/Path: the png file name/path to produce the icon
        QtGui.QIcon: the instance of a QIcon element
        ThemeIcon enum: the value of QtGui.QIcon.ThemeIcon (requires Qt>=6.7)
    tip: str
        a tooltip to be displayed when hovering above the action
    checkable: bool
        set the checkable state of the action
    checked: bool
        set the current state of the action
    slot: callable
        Method or function that will be called when the action is triggered
    toolbar: QToolBar
        a toolbar where action should be added.
    menu: QMenu
        a menu where action should be added.
    visible: bool
        display or not the action in the toolbar/menu
    shortcut: str
        a string defining a shortcut for this action
    enabled: bool
        set the enabled state
    """
⋮----
action = QAction(name)
⋮----
action = QAction(icon_name, name, None)
⋮----
action = QAction(create_icon(icon_name), name, None)
⋮----
"""Create and eventually add a widget to a toolbar

    Parameters
    ----------
    klass: str or QWidget or QWidget instance
        should be a custom widget class or the name of a standard widget of QWidgets
    args: list
     variable arguments passed as is to the widget constructor
    tip: str
        a tooltip to be displayed when hovering above the widget
    toolbar: QToolBar
        a toolbar where the widget should be added.
    visible: bool
        display or not the action in the toolbar/menu
    signal_str: str
        an attribute of type Signal of the widget
    slot: Callable
        a callable connected to the signal
    kwargs: dict
        variable named arguments used as is in the widget constructor
    setters: dict
        method/value pair of the widget (for instance setMaximumWidth)
    Returns
    -------
    QtWidgets.QWidget
    """
⋮----
widget: QtWidgets.QWidget = getattr(QtWidgets, klass)(*args)
⋮----
widget = klass
⋮----
widget = klass(*args, **kwargs)
⋮----
class ActionManager
⋮----
"""MixIn Class to be used by all UserInterface to manage their QActions and the action they are connected to

    Parameters
    ----------
    toolbar: QToolbar, optional
        The toolbar to use as default
    menu: QMenu, option
        The menu to use as default
    """
def __init__(self, toolbar=None, menu=None)
⋮----
#self.setup_actions()
⋮----
def setup_actions(self)
⋮----
"""Method where to create actions to be subclassed. Mandatory

        Examples
        --------
        >>> self.add_action('Quit', 'close2', "Quit program")
        >>> self.add_action('Grab', 'camera', "Grab from camera", checkable=True)
        >>> self.add_action('Load', 'Open', "Load target file (.h5, .png, .jpg) or data from camera", checkable=False)
        >>> self.add_action('Save', 'SaveAs', "Save current data", checkable=False)

        See Also
        --------
        ActionManager.add_action
        """
⋮----
"""Create a new action and add it to toolbar and menu

        Parameters
        ----------
        short_name: str
            the name as referenced in the dict self.actions
        name: str
            Displayed name if should be displayed in
        icon_name: str / Path / QtGui.QIcon / enum name
            str/Path: the png file name/path to produce the icon
            QtGui.QIcon: the instance of a QIcon element
            ThemeIcon enum: the value of QtGui.QIcon.ThemeIcon (requires Qt>=6.7)
        tip: str
            a tooltip to be displayed when hovering above the action
        checkable: bool
            set the checkable state of the action
        checked: bool
            set the current state of the action            
        toolbar: QToolBar
            a toolbar where action should be added. Actions can also be added later see *affect_to*
        menu: QMenu
            a menu where action should be added. Actions can also be added later see *affect_to*
        visible: bool
            display or not the action in the toolbar/menu
        auto_toolbar: bool
            if True add this action to the defined toolbar
        auto_menu: bool
            if True add this action to the defined menu
        enabled: bool
            set the enabled state of this action
        See Also
        --------
        affect_to, pymodaq.resources.QtDesigner_Ressources.Icon_Library,
        pymodaq.utils.managers.action_manager.add_action
        """
⋮----
toolbar = self._toolbar
⋮----
menu = self._menu
⋮----
"""Create and add a widget to a toolbar

        Parameters
        ----------
        short_name: str
            the name as referenced in the dict self.actions
        klass: str or QWidget or QWidget instance
            should be a custom widget class or the name of a standard widget of QWidgets
        args: list
         variable arguments passed as is to the widget constructor
        tip: str
            a tooltip to be displayed when hovering above the widget
        toolbar: QToolBar
            a toolbar where the widget should be added.
        visible: bool
            display or not the action in the toolbar/menu
        signal_str: str
            an attribute of type Signal of the widget
        slot: Callable
            a callable connected to the signal
        kwargs: dict
            variable named arguments passed as is to the widget constructor
        Returns
        -------
        QtWidgets.QWidget
        """
⋮----
widget = addwidget(klass, *args, tip=tip, toolbar=toolbar, visible=visible, signal_str=signal_str,
⋮----
def set_toolbar(self, toolbar)
⋮----
"""affect a toolbar to self

        Parameters
        ----------
        toolbar:
            QtWidgets.QToolBar
        """
⋮----
def set_menu(self, menu)
⋮----
"""affect a menu to self

        Parameters
        ----------
        menu:
            QtWidgets.QMenu
        """
⋮----
def set_action_text(self, action_name: str, text: str)
⋮----
"""Convenience method to set the displayed text on an action

        Parameters
        ----------
        action_name: str
            The action name as defined in setup_actions
        text: str
            The text to display
        """
⋮----
@property
    def actions(self) -> List[QAction]
⋮----
@property
    def actions_names(self) -> list[str]
⋮----
def get_action(self, name) -> QAction
⋮----
"""Getter of a given action

        Parameters
        ----------
        name: str
            The action name as defined in setup_actions

        Returns
        -------
        QAction
        """
⋮----
def has_action(self, action_name) -> bool
⋮----
"""Check if an action has been defined
        Parameters
        ----------
        action_name: str
            The action name as defined in setup_actions

        Returns
        -------
        bool: True if the action exists, False otherwise
        """
⋮----
@property
    def toolbar(self) -> QtWidgets.QToolBar
⋮----
"""Get the default toolbar"""
⋮----
@property
    def menu(self) -> QtWidgets.QMenuBar
⋮----
"""Get the default menu"""
⋮----
def affect_to(self, action_name, obj: Union[QtWidgets.QToolBar, QtWidgets.QMenu])
⋮----
"""Affect action to an object either a toolbar or a menu

        Parameters
        ----------
        action_name: str
            The action name as defined in setup_actions
        obj: QToolbar or QMenu
            The object where to add the action
        """
⋮----
def connect_action(self, name, slot, connect=True, signal_name='')
⋮----
"""Connect (or disconnect) the action referenced by name to the given slot

        Parameters
        ----------
        name: str
            key of the action as referenced in the self._actions dict
        slot: method
            a method/function
        connect: bool
            if True connect the trigger signal of the action to the defined slot else disconnect it
        signal_name: str
            try to use it as a signal (for widgets added...) otherwise use the *triggered* signal
        """
signal = 'triggered'
⋮----
signal = signal_name
⋮----
pass  # the action was not connected
⋮----
@dispatch(str)
    def is_action_visible(self, action_name: str)
⋮----
"""Check the visibility of a given action or the list of an action"""
⋮----
@dispatch(list)
    def is_action_visible(self, actions_name: list)
⋮----
isvisible = False
⋮----
isvisible = isvisible and self.is_action_visible(action_name)
⋮----
@dispatch(str)
    def is_action_checked(self, action_name: str)
⋮----
"""Get the CheckState of a given action or a list of actions"""
⋮----
@dispatch(list)
    def is_action_checked(self, actions_name: list)
⋮----
ischecked = False
⋮----
ischecked = ischecked and self.is_action_checked(action_name)
⋮----
@dispatch(str, bool)
    def set_action_visible(self, action_name: str, visible=True)
⋮----
"""Set the visibility of a given action or a list of an action"""
⋮----
@dispatch(list, bool)
    def set_action_visible(self, actions_name: list, visible=True)
⋮----
@dispatch(str, bool)
    def set_action_checked(self, action_name: str, checked=True)
⋮----
"""Set the CheckedState of a given action or a list of actions"""
⋮----
@dispatch(list, bool)
    def set_action_checked(self, actions_name: list, checked=True)
⋮----
@dispatch(str, bool)
    def set_action_enabled(self, action_name: str, enabled=True)
⋮----
"""Set the EnabledState of a given action or a list of actions"""
⋮----
@dispatch(list, bool)
    def set_action_enabled(self, actions_name: list, enabled=True)
⋮----
@dispatch(str)
    def is_action_enabled(self, action_name: str)
⋮----
"""Get the EnabledState of a given action or a list of actions"""
⋮----
is_enabled = False
⋮----
is_enabled = is_enabled and self.is_action_enabled(action_name)
</file>

<file path="src/pymodaq_gui/managers/parameter_manager.py">
logger = set_logger(get_module_name(__file__))
⋮----
class ParameterTreeWidget(ActionManager)
⋮----
def __init__(self, action_list: tuple = ('save', 'update', 'load'))
⋮----
toolbar = QtWidgets.QToolBar()
⋮----
self.widget.header = self.tree.header  # for back-compatibility, widget behave a bit like a ParameterTree
self.widget.listAllItems = self.tree.listAllItems  # for back-compatibility
⋮----
#self.tree.setMinimumWidth(150)
#self.tree.setMinimumHeight(300)
⋮----
# Making the buttons
⋮----
# Making the splitter
⋮----
# Adding the toolbar + the parameter tree
⋮----
# Hiding toolbar
⋮----
# Adding splitter to layout
⋮----
def setup_actions(self, action_list: tuple = ('save', 'update', 'load'))
⋮----
"""
        See Also
        --------
        ActionManager.add_action
        """
# Saving action
⋮----
# Update action
⋮----
# Load action
⋮----
class ParameterManager
⋮----
"""Class dealing with Parameter and ParameterTree

    Attributes
    ----------
    params: list of dicts
        Defining the Parameter tree like structure
    settings_name: str
        The particular name to give to the object parent Parameter (self.settings)
    settings: Parameter
        The higher level (parent) Parameter
    settings_tree: QWidget
        widget Holding a ParameterTree and a toolbar for interacting with the tree
    tree: ParameterTree
        the underlying ParameterTree
    """
settings_name = 'custom_settings'
params = []
⋮----
settings_name = self.settings_name
# create a settings tree to be shown eventually in a dock
# object containing the settings defined in the preamble
⋮----
showTop=False)  # create a Parameter
⋮----
@property
    def settings_tree(self)
⋮----
@property
    def tree(self)
⋮----
@property
    def settings(self) -> Parameter
⋮----
@settings.setter
    def settings(self, settings: Union[Parameter, List[Dict[str, str]], Path])
⋮----
settings = self.create_parameter(settings)
⋮----
self.tree.setParameters(self._settings, showTop=False)  # load the tree with this parameter object
⋮----
@staticmethod
    def create_parameter(settings: Union[Parameter, List[Dict[str, str]], Path]) -> Parameter
⋮----
_settings = Parameter.create(title='Settings', name='settings', type='group',
⋮----
settings = Path(settings)
_settings = Parameter.create(title='Settings', name='settings',
⋮----
_settings = Parameter.create(title='Settings', name=settings.name(),
⋮----
def parameter_tree_changed(self, param, changes)
⋮----
path = self._settings.childPath(param)
⋮----
def value_changed(self, param: Parameter)
⋮----
"""Non-mandatory method  to be subclassed for actions to perform (methods to call) when one of the param's
        value in self._settings is changed

        For this to be triggered, the Parameter method: **setValue** should be used

        Parameters
        ----------
        param: Parameter
            the parameter whose value just changed

        Examples
        --------
        >>> if param.name() == 'do_something':
        >>>     if param.value():
        >>>         print('Do something')
        >>>         self.settings.child('main_settings', 'something_done').setValue(False)
        """
⋮----
def child_added(self, param: Parameter, data: Parameter)
⋮----
"""Non-mandatory method to be subclassed for actions to perform when a param has been
        added in the attribute settings

        For this to be triggered, one of the Parameter methods: **addChild**, **addChildren**
        or **insertChildren** should be used

        Parameters
        ----------
        param: Parameter
            the parameter where child will be added
        data: Parameter
            the child parameter
        """
⋮----
def param_deleted(self, param: Parameter)
⋮----
"""Non-mandatory method to be subclassed for actions to perform when one of the param in self.settings has been deleted

        For this to be triggered, the Parameter method: **removeChild** should be used

        Parameters
        ----------
        param: Parameter
            the parameter that has been deleted
        """
⋮----
def options_changed(self, param: Parameter, data: Dict[str, Any])
⋮----
"""Non-mandatory method to be subclassed for actions to perform when one of the options
        of any parameter in the settings attribute has been changed.

        For this to be triggered, the Parameter method: **setOpts** should be used

        Parameters
        ----------
        param: Parameter
            the parameter chose option has been changed
        data: dict
            the key is the string of the changed option
            the value depend on the type of option
        """
⋮----
def limits_changed(self, param: Parameter, data: Tuple[numbers.Number, numbers.Number])
⋮----
"""Non-mandatory method to be subclassed for actions to perform when the limits
        of any parameter in the *settings* attribute has been changed

        For this to be triggered, the Parameter method: **setLimits** should be used

        Parameters
        ----------
        param: Parameter
            the parameter chose option has been changed
        data: tuple of numbers
            tuple of float or int depending on the parameter type. For peculiar Parameter, could be
            a tuple of some other objects

        """
⋮----
def save_settings_slot(self, file_path: Path = None)
⋮----
""" Method to save the current settings using a xml file extension.

        The starting directory is the user config folder with a subfolder called settings folder

        Parameters
        ----------
        file_path: Path
            Path like object pointing to a xml file encoding a Parameter object
            If None, opens a file explorer window to save manually a file
        """
⋮----
file_path = select_file(get_set_config_dir('settings', user=True), save=True, ext='xml', filter='*.xml',
⋮----
file_path = Path(file_path)
⋮----
def _get_settings_from_file(self)
⋮----
def load_settings_slot(self, file_path: Path = None)
⋮----
""" Method to load settings into the parameter using a xml file extension.

        The starting directory is the user config folder with a subfolder called settings folder

        Parameters
        ----------
        file_path: Path
            Path like object pointing to a xml file encoding a Parameter object
            If None, opens a file explorer window to pick manually a file
        """
⋮----
file_path = self._get_settings_from_file()
⋮----
def update_settings_slot(self, file_path: Path = None)
⋮----
""" Method to update settings using a xml file extension.

        The file should define the same settings structure (names and children)

        The starting directory is the user config folder with a subfolder called settings folder

        Parameters
        ----------
        file_path: Path
            Path like object pointing to a xml file encoding a Parameter object
            If None, opens a file explorer window to pick manually a file
        """
⋮----
_settings = self.create_parameter(file_path.resolve())
# Checking if both parameters have the same structure
sameStruct = utils.compareStructureParameter(self.settings,_settings)
if sameStruct:  # Update if true
</file>

<file path="src/pymodaq_gui/managers/roi_manager.py">
data_processors = DataProcessorFactory()
⋮----
roi_path = get_set_roi_path()
logger = set_logger(get_module_name(__file__))
⋮----
class ROIPositionMapper(QtWidgets.QWidget)
⋮----
""" Widget presenting a Tree structure representing a ROI positions.
    """
⋮----
def __init__(self, roi_pos, roi_size)
⋮----
def show_dialog(self)
⋮----
dialog = QtWidgets.QDialog(self)
vlayout = QtWidgets.QVBoxLayout()
⋮----
buttonBox = QtWidgets.QDialogButtonBox(parent=self)
⋮----
res = dialog.exec()
⋮----
class ROI(pgROI)
⋮----
index_signal = Signal(int)
⋮----
def __init__(self, *args, index=0, name='roi', **kwargs)
⋮----
def emit_index_signal(self)
⋮----
@property
    def color(self)
⋮----
def center(self) -> QPointF
⋮----
""" Get the center position of the ROI """
⋮----
def set_center(self, center: Union[QPointF, Tuple[float, float]])
⋮----
size = self.size()
⋮----
def set_positions(self)
⋮----
mapper = ROIPositionMapper(self.pos(), self.size())
settings = mapper.show_dialog()
⋮----
def copy_clipboard(self)
⋮----
info = plot_utils.RoiInfo.info_from_rect_roi(self)
⋮----
def contextMenuEvent(self, event)
⋮----
def width(self) -> float
⋮----
def height(self) -> float
⋮----
class ROIBrushable(ROI)
⋮----
def __init__(self, brush=None, *args, **kwargs)
⋮----
brush = QtGui.QBrush(QtGui.QColor(0, 0, 255, 50))
⋮----
def setBrush(self, *br, **kargs)
⋮----
"""Set the brush that fills the region. Can have any arguments that are valid
        for :func:`mkBrush <pyqtgraph.mkBrush>`.
        """
⋮----
def paint(self, p, opt, widget)
⋮----
# p.save()
# Note: don't use self.boundingRect here, because subclasses may need to redefine it.
r = QtCore.QRectF(0, 0, self.state['size'][0], self.state['size'][1]).normalized()
⋮----
# p.restore()
⋮----
class LinearROI(pgLinearROI)
⋮----
def __init__(self, index=0, pos=[0, 10], name = 'roi', **kwargs)
⋮----
info = plot_utils.RoiInfo.info_from_linear_roi(self)
⋮----
def pos(self) -> Tuple[float, float]
⋮----
def center(self) -> float
⋮----
pos = self.pos()
⋮----
def setPos(self, pos: Tuple[int, int])
⋮----
def setPen(self, color)
⋮----
class EllipseROI(ROI)
⋮----
"""
    Elliptical ROI subclass with one scale handle and one rotation handle.


    ============== =============================================================
    **Arguments**
    pos            (length-2 sequence) The position of the ROI's origin.
    size           (length-2 sequence) The size of the ROI's bounding rectangle.
    **args         All extra keyword arguments are passed to ROI()
    ============== =============================================================

    """
⋮----
def __init__(self, index=0, pos=[0, 0], size=[10, 10], **kwargs)
⋮----
# QtGui.QGraphicsRectItem.__init__(self, 0, 0, size[0], size[1])
⋮----
def getArrayRegion(self, arr, img=None, axes=(0, 1), **kwds)
⋮----
"""
        Return the result of ROI.getArrayRegion() masked by the elliptical shape
        of the ROI. Regions outside the ellipse are set to 0.
        """
# Note: we could use the same method as used by PolyLineROI, but this
# implementation produces a nicer mask.
⋮----
arr = pgROI.getArrayRegion(self, arr, img, axes, **kwds)
⋮----
w = arr.shape[axes[0]]
h = arr.shape[axes[1]]
# generate an ellipsoidal mask
mask = np.fromfunction(
⋮----
# reshape to match array axes
⋮----
mask = mask.T
shape = [(n if i in axes else 1) for i, n in enumerate(arr.shape)]
mask = mask.reshape(shape)
⋮----
r = self.boundingRect()
⋮----
p.scale(r.width(), r.height())  # workaround for GL bug
r = QtCore.QRectF(r.x() / r.width(), r.y() / r.height(), 1, 1)
⋮----
def shape(self)
⋮----
class CircularROI(EllipseROI)
⋮----
class SimpleRectROI(ROI)
⋮----
r"""
    Rectangular ROI subclass with a single scale handle at the top-right corner.
    """
⋮----
def __init__(self, pos=[0, 0], size=[10, 10], centered=False, sideScalers=False, **args)
⋮----
center = [0.5, 0.5]
⋮----
center = [0, 0]
⋮----
class RectROI(ROI)
⋮----
super().__init__(pos=pos, size=size, index=index, **kwargs)  # , scaleSnap=True, translateSnap=True)
⋮----
ROI_NAME_PREFIX = 'ROI_'
ROI2D_TYPES = ['RectROI', 'EllipseROI', 'CircularROI']
⋮----
class ROIScalableGroup(GroupParameter)
⋮----
def __init__(self, roi_type='1D', **opts)
⋮----
def addNew(self, typ='')
⋮----
name_prefix = ROI_NAME_PREFIX
child_indexes = [int(par.name()[len(name_prefix) + 1:]) for par in self.children()]
⋮----
newindex = 0
⋮----
newindex = max(child_indexes) + 1
⋮----
child = {'name': ROIManager.roi_format(newindex), 'type': 'group', 'removable': True, 'renamable': False}
⋮----
children = [{'name': 'type', 'type': 'str', 'value': self.roi_type, 'readonly': True, 'visible': False}, ]
⋮----
class ROIManager(QObject)
⋮----
new_ROI_signal = Signal(int, str, str)
remove_ROI_signal = Signal(str)
roi_value_changed = Signal(str, tuple)
color_signal = Signal(list)
roi_update_children = Signal(list)
roi_changed = Signal()
color_list = np.array(plot_colors)
⋮----
def __init__(self, viewer_widget=None, ROI_type='1D')
⋮----
self.viewer_widget = viewer_widget  # either a PlotWidget or a ImageWidget
⋮----
@staticmethod
    def roi_format(index)
⋮----
@property
    def ROIs(self)
⋮----
def __len__(self)
⋮----
def get_roi_from_index(self, index: int) -> ROI
⋮----
def _set_roi_from_index(self, index: int, roi)
⋮----
def get_roi(self, roi_key)
⋮----
def emit_colors(self)
⋮----
def add_roi_programmatically(self, roitype=ROI2D_TYPES[0])
⋮----
def remove_roi_programmatically(self, index: int)
⋮----
def setupUI(self)
⋮----
params = [
⋮----
def roi_tree_changed(self, param, changes)
⋮----
path = self.settings.childPath(param)
⋮----
childName = '.'.join(path)
⋮----
childName = param.name()
if change == 'childAdded':  # new roi to create
par: Parameter = data[0]
newindex = int(par.name()[-2:])
roi_type = ''
⋮----
pos = self.viewer_widget.plotItem.vb.viewRange()[0]
pos = pos[0] + np.diff(pos)*np.array([2,4])/6
newroi = LinearROI(index=newindex, pos=pos)
⋮----
roi_type = par.child('roi_type').value()
xrange = self.viewer_widget.plotItem.vb.viewRange()[0]
yrange = self.viewer_widget.plotItem.vb.viewRange()[1]
width = np.max(((xrange[1] - xrange[0]) / 10, 2))
height = np.max(((yrange[1] - yrange[0]) / 10, 2))
pos = [int(np.mean(xrange) - width / 2), int(np.mean(yrange) - width / 2)]
⋮----
newroi = RectROI(index=newindex, pos=pos,
⋮----
newroi = EllipseROI(index=newindex, pos=pos,
⋮----
newroi = CircularROI(index=newindex, pos=pos,
⋮----
parent_name = putils.get_param_path(param)[putils.get_param_path(param).index('ROIs')+1]
⋮----
roi = self._ROIs.pop(param.name())
⋮----
def update_use_channel(self, channels: List[str])
⋮----
val = self.settings['ROIs', self.roi_format(ind), 'use_channel']
⋮----
def update_roi(self, roi_key, param)
⋮----
pos = self._ROIs[roi_key].pos()
poss = [param.value(), pos[1]]
⋮----
poss = [pos[0], param.value()]
⋮----
size = self._ROIs[roi_key].size()
⋮----
@Slot(int)
    def update_roi_tree(self, index)
⋮----
roi = self.get_roi_from_index(index)
par = self.settings.child(*('ROIs', self.roi_format(index)))
⋮----
pos = roi.getRegion()
⋮----
pos = roi.pos()
size = roi.size()
angle = roi.angle()
⋮----
def save_ROI(self)
⋮----
data = ioxml.parameter_to_xml_string(self.settings.child(('ROIs')))
path = select_file(start_path=Path.home(), ext='xml', save=True, force_save_extension=True)
⋮----
def clear_ROI(self)
⋮----
indexes = [roi.index for roi in self._ROIs.values()]
⋮----
# self.settings.sigTreeStateChanged.connect(self.roi_tree_changed)
⋮----
def load_ROI(self, path=None, params=None)
⋮----
path = select_file(start_path=Path.home(), save=False, ext='xml', filter='XML files (*.xml)')
⋮----
params = Parameter.create(title='Settings', name='settings', type='group',
⋮----
def set_roi(self, roi_params, roi_params_new)
⋮----
class ROISaver
⋮----
def __init__(self, msgbox=False, det_modules=[])
⋮----
msgBox = QtWidgets.QMessageBox()
⋮----
cancel_button = msgBox.addButton(QtWidgets.QMessageBox.StandardButton.Cancel)
modify_button = msgBox.addButton('Modify', QtWidgets.QMessageBox.ButtonRole.AcceptRole)
⋮----
ret = msgBox.exec()
⋮----
path = select_file(start_path=roi_path, save=False, ext='xml')
⋮----
else:  # cancel
⋮----
def set_file_roi(self, filename, show=True)
⋮----
"""

        """
⋮----
children = ioxml.XML_file_to_parameter(filename)
⋮----
det_children = [child for child in self.roi_presets.children() if 'det' in child.opts['name']]
det_names = [child.child('detname').value() for child in self.roi_presets.children() if
det_module_names = [det.title for det in self.detector_modules]
⋮----
det_module = self.detector_modules[det_module_names.index(det_names[ind_det])]
viewer_children = [child for child in det_roi.children() if 'viewer' in child.opts['name']]
⋮----
rois_params = [child for child in viewer_children[ind_viewer].children() if 'ROI' in child.opts['name']]
⋮----
if hasattr(viewer, 'activate_roi'):  # because for viewer 0D it is irrelevant
⋮----
def set_new_roi(self, file=None)
⋮----
file = 'roi_default'
⋮----
det_param = Parameter.create(name=f'det_{ind_det:03d}', type='group', children=[
⋮----
viewer_param = Parameter.create(
⋮----
def show_rois(self)
⋮----
dialog = QtWidgets.QDialog()
⋮----
tree = ParameterTree()
⋮----
buttonBox = QtWidgets.QDialogButtonBox(parent=dialog)
⋮----
# save managers parameters in a xml file
# start = os.path.split(os.path.split(os.path.realpath(__file__))[0])[0]
# start = os.path.join("..",'daq_scan')
⋮----
app = QtWidgets.QApplication(sys.argv)
⋮----
im = ImageWidget()
im = PlotWidget()
prog = ROIManager(im, '2D')
widget = QtWidgets.QWidget()
layout = QtWidgets.QHBoxLayout()
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/__init__.py">
SimpleParameter, GroupParameter, GroupParameterItem)  # to be imported from elsewhere
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/bool.py">
class BoolPushParameterItem(WidgetParameterItem)
⋮----
"""Registered parameter type which displays a QLineEdit"""
⋮----
def makeWidget(self)
⋮----
opts = self.param.opts
w = QtWidgets.QPushButton()
⋮----
# w.setMaximumWidth(50)
⋮----
class BoolPushParameter(SimpleParameter)
⋮----
itemClass = BoolPushParameterItem
⋮----
def __init__(self, *args, **kwargs)
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/date.py">
class WidgetParameterItem(WidgetParameterItem)
⋮----
def updateDisplayLabel(self, value=None)
⋮----
"""Update the display label to reflect the value of the parameter."""
⋮----
value = self.param.value()
⋮----
class DateParameterItem(WidgetParameterItem)
⋮----
"""Registered parameter type which displays a QLineEdit"""
⋮----
def makeWidget(self)
⋮----
opts = self.param.opts
w = QtWidgets.QDateEdit(QtCore.QDate(QtCore.QDate.currentDate()))
⋮----
class DateTimeParameterItem(WidgetParameterItem)
⋮----
w = QtWidgets.QDateTimeEdit(QtCore.QDateTime(QtCore.QDate.currentDate(),
⋮----
class QTimeCustom(QtWidgets.QTimeEdit)
⋮----
def __init__(self, *args, **kwargs)
⋮----
def setTime(self, time)
⋮----
hours = time.hour()
minutes = time.minute()
⋮----
minutes = int(np.round(minutes / self.minutes_increment) * self.minutes_increment)
⋮----
minutes = 0
⋮----
def setMinuteIncrement(self, minutes_increment)
⋮----
@QtCore.Slot(QtCore.QTime)
    def updateTime(self, time)
⋮----
class TimeParameterItem(WidgetParameterItem)
⋮----
w = QTimeCustom(QtCore.QTime(QtCore.QTime.currentTime()))
⋮----
def optsChanged(self, param, opts)
⋮----
"""

        """
⋮----
class DateParameter(SimpleParameter)
⋮----
itemClass = DateParameterItem
⋮----
def _interpretValue(self, v)
⋮----
class DateTimeParameter(SimpleParameter)
⋮----
itemClass = DateTimeParameterItem
⋮----
class TimeParameter(SimpleParameter)
⋮----
itemClass = TimeParameterItem
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/filedir.py">
class FileDirWidget(QtWidgets.QWidget)
⋮----
"""
        ================ =========================
        **Attributes**    **Type**
        *value_changed*   instance of pyqt Signal
        *path*            string
        ================ =========================

        See Also
        --------
        browse_path
    """
value_changed = QtCore.Signal(str)
⋮----
def __init__(self, init_path='D:/Data', file_type=False)
⋮----
def browse_path(self)
⋮----
"""
            Browse the path attribute if exist.

            See Also
            --------
            set_path
        """
⋮----
folder_name = QtWidgets.QFileDialog.getOpenFileName(None, 'Choose File', os.path.split(self.path)[0])[0]
⋮----
folder_name = QtWidgets.QFileDialog.getExistingDirectory(None, 'Choose Folder', self.path)
⋮----
folder_name = QtWidgets.QFileDialog.getSaveFileName(None, 'Enter a Filename', os.path.split(self.path)[0])[
⋮----
if not (not(folder_name)):  # execute if the user didn't cancel the file selection
⋮----
def set_path(self, path_file)
⋮----
"""
            Set the base path attribute with the given path_file.

            =============== =========== ===========================
            **Parameters**    **Type**    **Description**
            *path_file*       string      the pathname of the file
            =============== =========== ===========================
        """
⋮----
path_file = str(path_file)
⋮----
def get_value(self)
⋮----
"""
            Get the value of the base_path_edit attribute.

            Returns
            -------
            string
                the path name
        """
⋮----
def initUI(self)
⋮----
"""
            Init the User Interface.
        """
⋮----
icon3 = QtGui.QIcon()
⋮----
verlayout = QtWidgets.QVBoxLayout()
⋮----
class FileDirParameterItem(WidgetParameterItem)
⋮----
def makeWidget(self)
⋮----
"""
            Make an initialized file_browser object with parameter options dictionnary ('readonly' key)0

            Returns
            -------
            w : filebrowser
                The initialized file browser.

            See Also
            --------
            file_browser
        """
⋮----
# if 'tip' in self.param.opts:
#     self.w.setToolTip(self.param.opts['tip'])
⋮----
class FileDirParameter(Parameter)
⋮----
"""
        Editable string; displayed as large text box in the tree.
        See Also
        --------
        file_browserParameterItem
    """
itemClass = FileDirParameterItem
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/itemselect.py">
class ItemSelect_pb(QtWidgets.QWidget)
⋮----
def __init__(self,checkbox=False,)
⋮----
def initUI(self, checkbox=False,)
⋮----
#### Widgets ###
# ListWidget
⋮----
# Pushbutton Add
⋮----
icon3 = QtGui.QIcon()
⋮----
# Pushbutton Remove
⋮----
#### Layout ###
⋮----
class ItemSelect(QtWidgets.QListWidget)
⋮----
def __init__(self, hasCheckbox=True)
⋮----
self.hasCheckbox = hasCheckbox # Boolean indicating if listwidget item uses checkbox ot not
self.selItems = []  # Dummy variable to keep track of click order
⋮----
def doubleClickSelection(self, item: QtWidgets.QListWidgetItem)
⋮----
"""
            Function to select item. The selection depends if the item uses checkbox or not.
        """
⋮----
def get_value(self)
⋮----
"""
            Get the dictionnary of values contained in the QtWidget attribute.

            Returns
            -------
            dictionnary
                The dictionnary of all_items compared to the selectedItems.                                
        """
allitems = [item.text() for item in self.all_items()]
⋮----
# Clean up list with non existing entries
⋮----
if item.checkState() != QtCore.Qt.CheckState(0): # Item is selected
if item.text() not in self.selItems: # if item not in list then add it
⋮----
else: # Item is not selected
if item.text() in self.selItems:  # if item in list then remove it
⋮----
selitems = self.selItems.copy() #need to copy to correctly emit signal when changed
⋮----
# selitems = [item.text() for item in self.all_items() if item.checkState()!=0]
⋮----
selitems = [item.text() for item in self.selectedItems()]
⋮----
def all_items(self) -> list
⋮----
"""
            Get the all_items list from the self QtWidget attribute.

            Returns
            -------
            list
                The item list.
        """
⋮----
def select_item(self, item: QtWidgets.QListWidgetItem, doSelect:bool = False)
⋮----
item.setCheckState(QtCore.Qt.CheckState(int(2*doSelect)))  # 2=QtCore.Qt.Checked, 0=QtCore.Qt.Unchecked
⋮----
def set_value(self, values: dict)
⋮----
"""
            Set values to the all_items attributes filtering values by the 'selected' key.

            =============== ============== =======================================
            **Parameters**    **Type**       **Description**
            *values*          dictionnary    the values dictionnary to be setted.
            =============== ============== =======================================
        """
# Remove values in selected if they do not exist in all
values = deepcopy(values)
⋮----
allitems_text = []
# Check existing items and remove unused ones
⋮----
if item.text() not in values['all_items']:  # Remove items from list if text not
# in values
item = self.takeItem(self.row(item))
⋮----
allitems_text.append(item.text())  # Add items to list
⋮----
# Create items if needed
for value in values['all_items']:  # Loop through all values
if value not in allitems_text:  # Test if object already exists
item = QtWidgets.QListWidgetItem(value) # Create object
if self.hasCheckbox:  # Add checkbox if required
⋮----
# Make sure item is not selected (checkbox not appearing somehow without)
self.addItem(item)  # Add object to widget
⋮----
allitems = self.all_items()  # All selectable items
# Selection process
⋮----
for value in values['selected']:  # Loop through selected to retain selection order
item = allitems[[item.text() for item in allitems].index(value)]
⋮----
def sizeHint(self)
⋮----
class ItemSelectParameterItem(WidgetParameterItem)
⋮----
def makeWidget(self)
⋮----
"""
            | Make and initialize an instance of ItemSelect_pb with itemselect value.
            | Connect the created object with the plus and minus buttonClicked function.

        """
⋮----
opts = self.param.opts
⋮----
w = ItemSelect_pb(checkbox=opts['checkbox'])
⋮----
w = ItemSelect_pb()
⋮----
# w.itemselect.setMinimumHeight(opts.get('min_height', 0))
# w.itemselect.setMaximumHeight(opts.get('height', 70))
⋮----
def pb_buttonClicked(self)
⋮----
"""
           Append to the param attribute the dictionnary obtained from the QtWidget add parameter procedure.
        """
⋮----
all = self.param.value()['all_items']
⋮----
sel = self.param.value()['selected']
⋮----
val = dict(all_items=all, selected=sel)
⋮----
def mb_buttonClicked(self)
⋮----
"""
           Remove the selected Qwidget items by removing the entries in the parameter attribute.
        """
items_to_be_removed = self.widget.itemselect.selectedItems()
⋮----
def optsChanged(self, param, opts)
⋮----
"""
            Called when any options are changed that are not name, value, default, or limits.

            See Also
            --------
            optsChanged
        """
# print "opts changed:", opts
⋮----
def valueChanged(self, param, val, force=False)
⋮----
class ItemSelectParameter(Parameter)
⋮----
"""
        Editable string; displayed as large text box in the tree.

        =============== ======================================
        **Attributes**    **Type**
        *itemClass*       instance of ItemSelectParameterItem
        *sigActivated*    instance of pyqt Signal
        =============== ======================================
    """
itemClass = ItemSelectParameterItem
sigActivated = QtCore.Signal(object)
⋮----
def activate(self)
⋮----
"""
            Activate the "Activated" signal attribute0
        """
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/led.py">
class LedParameterItem(WidgetParameterItem)
⋮----
"""Registered parameter type which displays a QLineEdit"""
⋮----
def makeWidget(self)
⋮----
w = QLED()
⋮----
class LedPushParameterItem(LedParameterItem)
⋮----
class LedParameter(SimpleParameter)
⋮----
itemClass = LedParameterItem
⋮----
def _interpretValue(self, v)
⋮----
class LedPushParameter(SimpleParameter)
⋮----
itemClass = LedPushParameterItem
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/list.py">
class Combo_pb(QtWidgets.QWidget)
⋮----
def __init__(self, items=[])
⋮----
def initUI(self)
⋮----
"""
            Init the User Interface.
        """
⋮----
icon3 = QtGui.QIcon()
⋮----
class ListParameterItem(ListParameterItem)
⋮----
"""
        WidgetParameterItem subclass providing comboBox that lets the user select from a list of options.

    """
⋮----
def __init__(self, param, depth)
⋮----
def makeWidget(self)
⋮----
"""
            Make a widget from self parameter options, connected to the buttonClicked function.

            Returns
            -------
            w:widget
                the initialized widget

            See Also
            --------
            buttonClicked, limitsChanged,
        """
opts = self.param.opts
t = opts['type']
w = Combo_pb()
⋮----
w.setMaximumHeight(20)  # # set to match height of spin box and line edit
⋮----
self.widget = w  # # needs to be set before limits are changed
⋮----
def buttonClicked(self)
⋮----
"""
            |
            | Append the self limits attributes an added parameter with string value.
            | Update parameter and call the limitschanged method to map the added parameter.

            See Also
            --------
            limitsChanged,
        """
⋮----
def optsChanged(self, param, opts)
⋮----
"""
            Called when any options are changed that are not name, value, default, or limits.

            =============== ================================== =======================================
            **Parameters**    **Type**                           **Description**
            *param*           instance of pyqtgraph parameter    The parameter to be checked
            *opts*            string list                        The option dictionnary to be checked
            =============== ================================== =======================================

            See Also
            --------
            optsChanged
        """
⋮----
class ListParameter(ListParameter)
⋮----
"""
        =============== =======================================
        **Attributes**    **Type**
        *itemClass*       instance of ListParameterItem_custom
        *sigActivated*    instance of pyqt Signal
        =============== =======================================
    """
itemClass = ListParameterItem
sigActivated = QtCore.Signal(object)
⋮----
def __init__(self, **opts)
⋮----
def activate(self)
⋮----
"""
            Emit the Activated signal.
        """
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/numeric.py">
class NumericParameter(SimpleParameter)
⋮----
itemClass = NumericParameterItem
⋮----
def __init__(self, **opts)
⋮----
def setLimits(self, limits)
⋮----
curVal = self.value()
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/pixmap.py">
class PixmapCheckData
⋮----
def __init__(self, data: np.ndarray, path: str = '', checked: bool = False, info: str = '')
⋮----
data = data / np.max(data) * 255
data = data.astype(np.uint8)
⋮----
def __eq__(self, other)
⋮----
status = np.all(np.isclose(self.data, other.data))
status = status and self.checked == other.checked
status = status and self.path == other.path
⋮----
class PixmapCheckWidget(QtWidgets.QWidget)
⋮----
""" value of this parameter is a PixmapCheckData

    See Also
    --------
    PixmapCheckedData
    """
⋮----
def __init__(self)
⋮----
def initUI(self)
⋮----
"""
            Init the User Interface.
        """
⋮----
ver_widget = QtWidgets.QWidget()
⋮----
# self.info.setReadOnly(True)
⋮----
def setValue(self, data: PixmapCheckData)
⋮----
im = QtGui.QImage(data.data, *data.data.shape, QtGui.QImage.Format_Indexed8)
a = QtGui.QPixmap.fromImage(im)
⋮----
def value(self)
⋮----
class PixmapParameterItem(WidgetParameterItem)
⋮----
"""Registered parameter type which displays a QPixmap in a QLabel"""
⋮----
def makeWidget(self)
⋮----
w = QtWidgets.QLabel()
⋮----
class PixmapCheckParameterItem(WidgetParameterItem)
⋮----
"""Registered parameter type which displays a PixmapCheckWidget custom widget"""
⋮----
w = PixmapCheckWidget()
⋮----
class PixmapCheckParameter(SimpleParameter)
⋮----
itemClass = PixmapCheckParameterItem
⋮----
def __init__(self, **kwargs)
⋮----
class PixmapParameter(SimpleParameter)
⋮----
itemClass = PixmapParameterItem
⋮----
def main_widget()
⋮----
app = QtWidgets.QApplication(sys.argv)
prog = PixmapCheckWidget()
⋮----
data = np.arange(128 * 256).reshape((256, 128))
⋮----
def print_toggled(status)
⋮----
def main_parameter()
⋮----
class PixmapParameter(ParameterManager)
⋮----
params = {'title': 'Overlays', 'name': 'overlays', 'type': 'group', 'children': [
⋮----
def value_changed(self, param)
⋮----
prog = PixmapParameter()
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/slide.py">
class SliderSpinBox(QtWidgets.QWidget)
⋮----
def __init__(self, *args, subtype='linear', **kwargs)
⋮----
self.valueChanged = self.spinbox.valueChanged  # (value)  for compatibility with QSpinBox
self.sigValueChanged = self.spinbox.sigValueChanged  # (self)
self.sigValueChanging = self.spinbox.sigValueChanging  # (self, value)  sent immediately; no delay.
⋮----
@property
    def opts(self)
⋮----
@opts.setter
    def opts(self, **opts)
⋮----
def setOpts(self, **opts)
⋮----
def insert_widget(self ,widget, row=0)
⋮----
def initUI(self, *args, **kwargs)
⋮----
"""
            Init the User Interface.
        """
⋮----
value = kwargs.pop('value')
⋮----
value = kwargs['bounds'][0]
⋮----
value = 1
⋮----
value = 0
⋮----
self.spinbox.valueChanged.emit(value) #Initializing slider from value
⋮----
def get_bounds(self,)
⋮----
""" Convert bounds from opts into list of floats

        Returns:
            list of floats
        """
⋮----
def update_spinbox(self, val)
⋮----
"""
        val is a percentage [0-100] used in order to set the spinbox value between its min and max
        """
⋮----
val_out = scroll_log(val, min_val, max_val)
⋮----
val_out = scroll_linear(val, min_val, max_val)
⋮----
def update_slide(self, val)
⋮----
"""
        val is the spinbox value between its min and max
        """
⋮----
value = np.rint((val - min_val) / (max_val - min_val) * 100)
⋮----
value = 50
⋮----
value = np.rint((np.log10(val) - np.log10(min_val)) / (np.log10(max_val) - np.log10(min_val)) * 100)
⋮----
value  = 50
value = int(value)
⋮----
def setValue(self, val)
⋮----
def value(self)
⋮----
class SliderParameterItem(WidgetParameterItem)
⋮----
"""Registered parameter type which displays a QLineEdit"""
⋮----
def makeWidget(self)
⋮----
opts = self.param.opts
defs = {
#Update relevant opts
⋮----
#Additional changes according to user syntax
⋮----
defs['bounds'] = [0., float(self.param.value() or 1)]  # max value set to default value when no max given or 1 if no default
⋮----
w = SliderSpinBox(subtype=opts['subtype'],**defs)
⋮----
def updateDisplayLabel(self, value=None)
⋮----
# Reimplement display label to show the spinbox text with its suffix
⋮----
value = self.widget.spinbox.text()
⋮----
def showEditor(self)
⋮----
# Reimplement show Editor to specifically select the numbers
⋮----
def optsChanged(self, param, opts)
⋮----
# Reimplement optsChanged to correctly update spinbox opts when changed
⋮----
sbOpts = {}
⋮----
lim = opts.pop('bounds')
⋮----
def limitsChanged(self, param, limits)
⋮----
class SliderParameter(SimpleParameter)
⋮----
itemClass = SliderParameterItem
⋮----
def __init__(self, **kwargs)
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/table.py">
class TableWidget(QtWidgets.QTableWidget)
⋮----
"""
        ============== ===========================
        *Attributes**    **Type**
        *valuechanged*   instance of pyqt Signal
        *QtWidgets*      instance of QTableWidget
        ============== ===========================
    """
⋮----
valuechanged = QtCore.Signal(OrderedDict)
⋮----
def __init__(self)
⋮----
def get_table_value(self)
⋮----
"""
            Get the contents of the self coursed table.

            Returns
            -------
            data : ordered dictionnary
                The getted values dictionnary.
        """
data = OrderedDict([])
⋮----
item0 = self.item(ind, 0)
item1 = self.item(ind, 1)
⋮----
def set_table_value(self, data_dict)
⋮----
"""
            Set the data values dictionnary to the custom table.

            =============== ====================== ================================================
            **Parameters**    **Type**               **Description**
            *data_dict*       ordered dictionnary    the contents to be stored in the custom table
            =============== ====================== ================================================
        """
⋮----
item0 = QtWidgets.QTableWidgetItem(key)
⋮----
item1 = QtWidgets.QTableWidgetItem('{:.3e}'.format(value))
⋮----
item1 = QtWidgets.QTableWidgetItem(str(value))
⋮----
# self.valuechanged.emit(data_dict)
⋮----
class TableParameterItem(WidgetParameterItem)
⋮----
# def treeWidgetChanged(self):
#     """
#         Check for changement in the Widget tree.
⋮----
#     # # TODO: fix so that superclass method can be called
#     # # (WidgetParameter should just natively support this style)
#     # WidgetParameterItem.treeWidgetChanged(self)
#     self.treeWidget().setFirstItemColumnSpanned(self.subItem, True)
#     self.treeWidget().setItemWidget(self.subItem, 0, self.widget)
#
#     # for now, these are copied from ParameterItem.treeWidgetChanged
#     self.setHidden(not self.param.opts.get('visible', True))
#     self.setExpanded(self.param.opts.get('expanded', True))
⋮----
def makeWidget(self)
⋮----
"""
            Make and initialize an instance of TableWidget.

            Returns
            -------
            table : instance of TableWidget.
                The initialized table.

            See Also
            --------
            TableWidget
        """
⋮----
opts = self.param.opts
w = TableWidget()
⋮----
# self.table.setReadOnly(self.param.opts.get('readonly', False))
⋮----
class TableParameter(Parameter)
⋮----
"""
        =============== =================================
        **Attributes**    **Type**
        *itemClass*       instance of TableParameterItem
        *Parameter*       instance of pyqtgraph parameter
        =============== =================================
    """
itemClass = TableParameterItem
"""Editable string; displayed as large text box in the tree."""
⋮----
# def __init(self):
#     super(TableParameter,self).__init__()
⋮----
def setValue(self, value)
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/tableview.py">
class TableViewCustom(QtWidgets.QTableView)
⋮----
"""
        ============== ===========================
        *Attributes**    **Type**
        *valuechanged*   instance of pyqt Signal
        *QtWidgets*      instance of QTableWidget
        ============== ===========================
    """
⋮----
valueChanged = QtCore.Signal(list)
add_data_signal = QtCore.Signal(int)
remove_row_signal = QtCore.Signal(int)
load_data_signal = QtCore.Signal()
save_data_signal = QtCore.Signal()
⋮----
def __init__(self, menu=False)
⋮----
def setmenu(self, status)
⋮----
def clear(self)
⋮----
def add(self)
⋮----
def remove(self)
⋮----
def data_has_changed(self, topleft, bottomright, roles)
⋮----
def get_table_value(self)
⋮----
"""

        """
⋮----
def set_table_value(self, data_model)
⋮----
def contextMenuEvent(self, event)
⋮----
class TableViewParameterItem(WidgetParameterItem)
⋮----
def makeWidget(self)
⋮----
"""
            Make and initialize an instance of Table_custom.

            Returns
            -------
            table : instance of Table_custom.
                The initialized table.

            See Also
            --------
            Table_custom
        """
⋮----
menu = False
opts = self.param.opts
⋮----
menu = opts['menu']
w = TableViewCustom(menu=menu)
⋮----
#w.setMaximumHeight(200)
# self.table.setReadOnly(self.param.opts.get('readonly', False))
⋮----
def optsChanged(self, param, opts)
⋮----
"""
            | Called when any options are changed that are not name, value, default, or limits.
            |
            | If widget is a SpinBox, pass options straight through.
            | So that only the display label is shown when visible option is toggled.

            =============== ================================== ==============================
            **Parameters**    **Type**                           **Description**
            *param*           instance of pyqtgraph parameter    the parameter to check
            *opts*            string list                        the associated options list
            =============== ================================== ==============================

            See Also
            --------
            optsChanged
        """
# print "opts changed:", opts
⋮----
styledItemDelegate = QtWidgets.QStyledItemDelegate()
⋮----
class TableViewParameter(Parameter)
⋮----
"""
        =============== =================================
        **Attributes**    **Type**
        *itemClass*       instance of TableParameterItem
        *Parameter*       instance of pyqtgraph parameter
        =============== =================================
    """
itemClass = TableViewParameterItem
⋮----
def setValue(self, value)
</file>

<file path="src/pymodaq_gui/parameter/pymodaq_ptypes/text.py">
class PlainTextWidget(QtWidgets.QWidget)
⋮----
"""
        ================ ========================
        **Attributes**    **Type**
        *value_changed*   instance of pyqt Signal
        ================ ========================

        See Also
        --------
        initUI, emitsignal
    """
value_changed = QtCore.Signal(str)
⋮----
def __init__(self)
⋮----
def emitsignal(self)
⋮----
"""
            Emit the value changed signal from the text_edit attribute.
        """
text = self.text_edit.toPlainText()
⋮----
def set_value(self, txt)
⋮----
"""
            Set the value of the text_edit attribute.

            =============== =========== ================================
            **Parameters**    **Type**    **Description**
            *txt*             string      the string value to be setted
            =============== =========== ================================
        """
⋮----
def get_value(self)
⋮----
"""
            Get the value of the text_edit attribute.

            Returns
            -------
            string
                The string value of text_edit.
        """
⋮----
def initUI(self)
⋮----
"""
            Init the User Interface.
        """
⋮----
icon3 = QtGui.QIcon()
⋮----
verlayout = QtWidgets.QVBoxLayout()
⋮----
class PlainTextParameterItem(WidgetParameterItem)
⋮----
def __init__(self, param, depth)
⋮----
def treeWidgetChanged(self)
⋮----
# # TODO: fix so that superclass method can be called
# # (WidgetParameter should just natively support this style)
# WidgetParameterItem.treeWidgetChanged(self)
⋮----
# for now, these are copied from ParameterItem.treeWidgetChanged
⋮----
def makeWidget(self)
⋮----
"""
            Make and initialize an instance of Plain_text_pb object from parameter options dictionnary (using 'readonly' key).

            Returns
            -------
            Plain_text_pb object
                The initialized object.

            See Also
            --------
            Plain_text_pb, buttonClicked
        """
⋮----
def buttonClicked(self)
⋮----
class PlainTextPbParameter(Parameter)
⋮----
"""Editable string; displayed as large text box in the tree."""
itemClass = PlainTextParameterItem
sigActivated = QtCore.Signal(object)
⋮----
def activate(self)
⋮----
"""
            Send the Activated signal.
        """
</file>

<file path="src/pymodaq_gui/parameter/__init__.py">
class ParameterTree(ParameterTree)
⋮----
def __init__(self, *args, **kwargs)
⋮----
#self.header().setMinimumSectionSize(150)
</file>

<file path="src/pymodaq_gui/parameter/ioxml.py">
def walk_parameters_to_xml(parent_elt=None, param=None)
⋮----
"""
        To convert a parameter object (and children) to xml data tree.

        =============== ================================ ==================================
        **Parameters**   **Type**                         **Description**

        *parent_elt*     XML element                      the root element
        *param*          instance of pyqtgraph parameter  Parameter object to be converted
        =============== ================================ ==================================

        Returns
        -------
        XML element : parent_elt
            XML element with subelements from Parameter object

        See Also
        --------
        add_text_to_elt, walk_parameters_to_xml, dict_from_param

    """
⋮----
opts = dict_from_param(param)
parent_elt = ET.Element(param.name(), **opts)
⋮----
params_list = param.children()
⋮----
elt = ET.Element(param.name(), **opts)
⋮----
def add_text_to_elt(elt, param)
⋮----
"""Add a text filed in a xml element corresponding to the parameter value

    Parameters
    ----------
    elt: XML elt
    param: Parameter

    See Also
    --------
    add_text_to_elt, walk_parameters_to_xml, dict_from_param
    """
param_type = str(param.type())
⋮----
text = '1'
⋮----
text = '0'
⋮----
str(param.value()['all_items']))  # use list(eval(val_str[1:-1])) to get back a list of strings
text = str(param.value()['selected'])  # use list(eval(val_str[1:-1])) to get back a list of strings
⋮----
text = str(None)
⋮----
text = str([param.value().red(), param.value().green(), param.value().blue(), param.value().alpha()])
⋮----
text = "str('{}')".format(param.value())
⋮----
text = 'int({})'.format(param.value())
⋮----
text = 'float({})'.format(param.value())
⋮----
text = str(param.value())
⋮----
if param.value() is True:  # known bug is True should be clearly specified here
val = 1
⋮----
val = param.value()
text = str(val)
⋮----
text = str(param.value().toMSecsSinceEpoch())
⋮----
text = str(QDateTime(param.value(), QTime()).toMSecsSinceEpoch())
⋮----
data = dict(classname=param.value().__class__.__name__,
text = json.dumps(data)
⋮----
text = ''
⋮----
def dict_from_param(param)
⋮----
"""Get Parameter properties as a dictionary

    Parameters
    ----------
    param: Parameter

    Returns
    -------
    opts: dict

    See Also
    --------
    add_text_to_elt, walk_parameters_to_xml, dict_from_param
    """
opts = dict([])
⋮----
title = param.opts['title']
⋮----
title = param.name()
⋮----
visible = '1'
⋮----
visible = '0'
⋮----
removable = '1'
⋮----
removable = '0'
⋮----
readonly = '0'
⋮----
readonly = '1'
⋮----
# if 'limits' in param.opts:
#     values = str(param.opts['limits'])
#     opts.update(dict(values=values))
⋮----
limits = str(param.opts['limits'])
⋮----
# opts.update(dict(values=limits))
⋮----
addList = str(param.opts['addList'])
⋮----
addText = str(param.opts['addText'])
⋮----
detlist = str(param.opts['detlist'])
⋮----
movelist = str(param.opts['movelist'])
⋮----
label = str(param.opts['label'])
⋮----
show_pb = '1'
⋮----
show_pb = '0'
⋮----
filetype = '1'
⋮----
filetype = '0'
⋮----
def elt_to_dict(el)
⋮----
"""Convert xml element attributes to a dictionnary

    Parameters
    ----------
    el

    Returns
    -------

    """
param = dict([])
⋮----
# name=el.tag, title=title, type=param_type, value=param_value, values=[param_value],
#              visible=visible, removable=removable, readonly=readonly, show_pb=show_pb)
⋮----
param_type = el.get('type')
⋮----
title = el.get('title')
⋮----
title = el.tag
⋮----
visible = True
⋮----
visible = bool(int(el.get('visible')))
⋮----
removable = False
⋮----
removable = bool(int(el.get('removable')))
⋮----
readonly = False
⋮----
readonly = bool(int(el.get('readonly')))
⋮----
show_pb = bool(int(el.get('show_pb')))
⋮----
show_pb = False
⋮----
filetype = bool(int(el.get('filetype')))
⋮----
detlist = eval(el.get('detlist'))
⋮----
movelist = eval(el.get('movelist'))
⋮----
addList = eval(el.get('addList'))
⋮----
addText = str(el.get('addText'))
⋮----
label = str(el.get('label'))
⋮----
# if 'limits' in el.attrib.keys():
#     try:
#         values = list(eval(el.get('limits')))  # make sure the evaluated values are returned as list (in case another
#     # iterator type has been used
#         param.update(dict(values=values))
#     except:
#         pass
⋮----
limits = eval(el.get('limits'))
⋮----
def parameter_to_xml_string(param)
⋮----
""" Convert  a Parameter to a XML string.

    Parameters
    ----------
    param: Parameter

    Returns
    -------
    str: XMl string

    See Also
    --------
    add_text_to_elt, walk_parameters_to_xml, dict_from_param

    Examples
    --------
    >>> from pyqtgraph.parametertree import Parameter
    >>>    #Create an instance of Parameter
    >>> settings=Parameter(name='settings')
    >>> converted_xml=parameter_to_xml_string(settings)
    >>>    # The converted Parameter
    >>> print(converted_xml)
    b'<settings title="settings" type="None" />'
    """
xml_elt = walk_parameters_to_xml(param=param)
⋮----
def parameter_to_xml_file(param, filename: Union[str, Path], overwrite=True)
⋮----
"""
        Convert the given parameter to XML element and update the given XML file.

        =============== ================================= ================================
        **Parameters**    **Type**                          **Description**
        *param*           instance of pyqtgraph parameter   the parameter to be added
        *filename*        string                            the filename of the XML file
        *overwrite*       boolean                           raise Error is False and file exists
        =============== ================================= ================================

        See Also
        --------
        walk_parameters_to_xml

        Examples
        --------
    """
⋮----
filename = Path(filename)
parent = filename.parent
filename = filename.stem
fname = parent.joinpath(filename + ".xml")  # forcing the right extension on the filename
⋮----
tree = ET.ElementTree(xml_elt)
⋮----
def walk_xml_to_parameter(params=[], XML_elt=None)
⋮----
""" To convert an XML element (and children) to list of dict enabling creation of parameter object.

        =============== ================== =======================================
        **Parameters**   **Type**            **Description**

        *params*         dictionnary list    the list to create parameter object
        *XML_elt*        XML object          the XML object to be converted
        =============== ================== =======================================

        Returns
        -------
        params : dictionnary list
            list of dict to create parameter object

        Examples
        -------
        >>> from pyqtgraph.parametertree import Parameter, ParameterItem
        >>> import xml.etree.ElementTree as ET
        >>> tree = ET.parse('text_bis.xml')
        >>> root = tree.getroot()
        >>> params=walk_xml_to_parameter(XML_elt=root)
        >>> settings_xml=Parameter.create(name='Settings XML', type='group', children=params)
        >>> settings=Parameter.create(name='Settings', type='group', children=params)

        See Also
        --------
        walk_parameters_to_xml
    """
⋮----
param_dict = set_dict_from_el(XML_elt)
⋮----
param_dict = set_dict_from_el(el)
⋮----
param_dict['type'] = 'group'  # in case the custom group has been defined somewhere but not
# registered again in this session
⋮----
children = []
⋮----
subparams = []
children = walk_xml_to_parameter(subparams, el)
⋮----
except Exception as e:  # to be able to debug when there's an issue
⋮----
def set_dict_from_el(el)
⋮----
"""Convert an element into a dict
    ----------
    el: xml element
    param_dict: dictionnary from which the parameter will be constructed
    """
param_dict = elt_to_dict(el)
⋮----
def set_txt_from_elt(el, param_dict)
⋮----
"""
    get the value of the parameter from the text value of the xml element
    Parameters
    ----------
    el: xml element
    param_dict: dictionnary from which the parameter will be constructed

    """
val_text = el.text
param_type = param_dict['type']
# param_type = el.get('type') # Redundancy (param_dict already has this attribute)
⋮----
param_value = float(val_text)
⋮----
param_value = int(float(val_text))
⋮----
param_value = dict(all_items=[], selected=[])
⋮----
param_value = dict(all_items=eval(el.get('all_items', val_text)), selected=eval(val_text))
elif 'bool' in param_type or 'led' in param_type: # covers 'bool' 'bool_push',  'led' and 'led_push'types
param_value = bool(int(val_text))
⋮----
param_value = QDateTime.fromMSecsSinceEpoch(int(val_text))
⋮----
param_value = QDateTime.fromMSecsSinceEpoch(int(val_text)).date()
⋮----
param_value = eval(val_text)
⋮----
param_value = QtGui.QColor(*eval(val_text))
⋮----
param_value = val_text  # for back compatibility
⋮----
data_dict = json.loads(val_text)
mod = importlib.import_module(data_dict['module'])
_cls = getattr(mod, data_dict['classname'])
param_value = _cls(data_dict['data'], header=data_dict['header'])
⋮----
param_value = None
⋮----
param_value = val_text
⋮----
def XML_file_to_parameter(file_name: Union[str, Path]) -> list
⋮----
""" Convert a xml file into pyqtgraph parameter object.

    Returns
    -------
    params : list of dictionary
        a list of dictionary defining a Parameter object and its children

    See Also
    --------
    walk_parameters_to_xml

    Examples
    --------
    """
tree = ET.parse(str(file_name))
⋮----
root = tree.getroot()
params = walk_xml_to_parameter(params=[], XML_elt=root)
⋮----
def XML_string_to_parameter(xml_string)
⋮----
"""
        Convert a xml string into a list of dict for initialize pyqtgraph parameter object.

        =============== =========== ================================
        **Parameters**   **Type**    **Description**

        xml_string       string      the xml string to be converted
        =============== =========== ================================

        Returns
        -------
        params: a parameter list of dict to init a parameter

        See Also
        --------
        walk_parameters_to_xml

        Examples
        --------
    """
root = ET.fromstring(xml_string)
tree = ET.ElementTree(root)
⋮----
# tree.write('test.xml')
⋮----
def XML_string_to_pobject(xml_string) -> Parameter
⋮----
"""
    return a Parameter object from its *translated* version as a XML string
    Parameters
    ----------
    xml_string: (str) string representation of a Parameter Object

    Returns
    -------
    Parameter

    See Also
    --------
    parameter_to_xml_string
    """
</file>

<file path="src/pymodaq_gui/parameter/utils.py">
ser_factory = SerializableFactory()
⋮----
@SerializableFactory.register_decorator()
class ParameterWithPath(SerializableBase)
⋮----
""" holds together a Parameter object and its full path

    To be used when communicating between TCPIP to reconstruct properly the Parameter

    Parameters
    ----------
    parameter: Parameter
        a Parameter object
    path: full path of the parameter, if None it is constructed from the parameter parents
    """
def __init__(self, parameter: Parameter, path: List[str] = None)
⋮----
path = get_param_path(parameter)
⋮----
def __repr__(self)
⋮----
@property
    def parameter(self) -> Parameter
⋮----
@property
    def path(self) -> List[str]
⋮----
def value(self)
⋮----
@staticmethod
    def serialize(param: 'ParameterWithPath') -> bytes
⋮----
"""

        """
bytes_string = b''
path = param.path
param_as_xml = ioxml.parameter_to_xml_string(param.parameter)
⋮----
"""Convert bytes into a ParameterWithPath object

        Returns
        -------
        ParameterWithPath: the decoded object
        bytes: the remaining bytes string if any
        """
⋮----
param_dict = ioxml.XML_string_to_parameter(param_as_xml)
param_obj = Parameter(**param_dict[0])
⋮----
def get_widget_from_tree(parameter_tree, widget_instance)
⋮----
widgets = []
⋮----
def get_param_path(param: Parameter) -> List[str]
⋮----
""" Get the parameter path from its highest parent down to the given parameter including its
    identifier (name)

    Parameters
    ----------
    param: Parameter
        The parameter object

    Returns
    -------
    List[str]: the path as a list of parameter identifiers
    """
path = [param.name()]
⋮----
param = param.parent()
⋮----
def getOpts(param:Parameter,) -> OrderedDict
⋮----
"""Return an OrderedDict with tree structures of all opts for all children of this parameter
        Parameters
        ----------
        param: Parameter
        Returns
        -------
        OrderedDict
    """
vals = OrderedDict()
⋮----
def getStruct(param:Parameter,) -> OrderedDict
⋮----
"""Return an OrderedDict with tree structures of all children of this parameter
        Parameters
        ----------
        param: Parameter
        Returns
        -------
        OrderedDict    
    """
⋮----
def getValues(param:Parameter,) -> OrderedDict
⋮----
"""Return an OrderedDict with tree structures of all values for all children of this parameter
        Parameters
        ----------
        param: Parameter
        Returns
        -------
        OrderedDict    
    """
⋮----
def compareParameters(param1:Parameter, param2:Parameter, opts: list = [])-> bool
⋮----
"""Compare the structure and the opts of two parameters with their children,
     return True if structure and all opts are identical
        Parameters
        ----------
        param1: Parameter
        param2: Parameter   
        
        Returns
        -------
        Bool    
    """
⋮----
def compareStructureParameter(param1:Parameter,param2:Parameter,)-> bool
⋮----
"""Compare the structure of two parameters with their children, return True if structure is identical
        Parameters
        ----------
        param1: Parameter
        param2: Parameter   
        
        Returns
        -------
        Bool    
    """
⋮----
def compareValuesParameter(param1:Parameter,param2:Parameter,)-> bool
⋮----
"""Compare the structure and the values of two parameters with their children, return True if structures and values are identical
        Parameters
        ----------
        param1: Parameter
        param2: Parameter   
        
        Returns
        -------
        Bool    
    """
⋮----
def iter_children(param, childlist=[], filter_type=(), filter_name=(), select_filter=False)-> list
⋮----
"""
    Get a list of parameters' name under a given Parameter (see iter_children_params)

    Returns
    -------
    list
        The list of the children name from the given node.       
    """
⋮----
def iter_children_params(param, childlist=[], output_type=None, filter_type=(), filter_name=(), select_filter=False)-> list
⋮----
"""
    Get a list of parameters under a given Parameter.

    Parameters
    ----------
    param : Parameter (pyqtgraph)
        the root node to be coursed
    childlist: list
        the child/output list
    output_type: str
        the attribute of parameter that will be added to the output list
    filter_type: list
        filter children sharing those types
    filter_name: list
        filter children sharing those names
    select_filter: bool
        if True, add filtered parameters to output list. 
        if False (default), add non-filtered parameter to output list.

    Returns
    -------
    list
        The list of the children from the given node.    
    """
⋮----
# XNOR Gate
is_filtered = child.type() in filter_type or child.name() in filter_name
add_selected_child = select_filter and is_filtered
add_notselected_child = not select_filter and not is_filtered
⋮----
output = getattr(child,output_type)()
⋮----
output = child
⋮----
def get_param_from_name(parent, name) -> Parameter
⋮----
"""Get Parameter under parent whose name is name

    Parameters
    ----------
    parent: Parameter
    name: str

    Returns
    -------
    Parameter
    """
⋮----
ch = get_param_from_name(child, name)
⋮----
def is_name_in_dict(dict_tmp, name)
⋮----
def get_param_dict_from_name(parent_list, name, pop=False)
⋮----
"""Get dict under parent whose name is name. The parent_list structure is the one used to init a Parameter object

    Parameters
    ----------
    parent_list: (list of dicts) as defined to init Parameter object
    name: (str) value to find for the key: name
    pop: (bool) if True remove the matched dict from parent

    Returns
    -------
    dict the matched dict
    """
⋮----
ch = get_param_dict_from_name(parent_dict['children'], name, pop)
⋮----
def set_param_from_param(param_old, param_new)
⋮----
"""
        Walk through parameters children and set values using new parameter values.
    """
⋮----
# try:
path = param_old.childPath(child_old)
child_new = param_new.child(*path)
param_type = child_old.type()
⋮----
if 'group' not in param_type:  # covers 'group', custom 'groupmove'...
# try:
if 'list' in param_type:  # check if the value is in the limits of the old params
# (limits are usually set at initialization) but carefull as such paramater limits can be a list or a
# dict object
⋮----
new_limits = child_old.opts['limits'].copy()
⋮----
child_new_key = find_keys_from_val(child_new.opts['limits'], child_new.value())[0]
⋮----
if child_new.value() != "":  # to make sure one doesnt overwrite something
⋮----
# except Exception as e:
#    print(str(e))
⋮----
# except Exception as e:
#    print(str(e))
⋮----
def scroll_log(scroll_val, min_val, max_val)
⋮----
"""
    Convert a scroll value [0-100] to a log scale between min_val and max_val
    Parameters
    ----------
    scroll
    min_val
    max_val
    Returns
    -------

    """
⋮----
value = scroll_val * (np.log10(max_val) - np.log10(min_val)) / 100 + np.log10(min_val)
⋮----
def scroll_linear(scroll_val, min_val, max_val)
⋮----
"""
    Convert a scroll value [0-100] to a linear scale between min_val and max_val
    Parameters
    ----------
    scroll
    min_val
    max_val
    Returns
    -------

    """
⋮----
value = scroll_val * (max_val - min_val) / 100 + min_val
⋮----
if __name__ == '__main__':              # pragma: no cover
parent = [
⋮----
d = get_param_dict_from_name(parent, 'lines')
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/__init__.py">
DATA_TYPES = ['Data0D', 'Data1D', 'Data2D', 'DataND']
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/base.py">
class ViewerError(Exception)
⋮----
class ViewersEnum(BaseEnum)
⋮----
"""enum relating a given viewer with data type"""
Viewer0D = 'Data0D'
Viewer1D = 'Data1D'
Viewer2D = 'Data2D'
ViewerND = 'DataND'
ViewerSequential = 'DataSequential'
⋮----
def get_dim(self)
⋮----
def increase_dim(self, ndim: int)
⋮----
dim = self.get_dim()
⋮----
dim_as_int = int(dim) + ndim
⋮----
dim = 'N'
⋮----
dim = str(dim_as_int)
⋮----
@classmethod
    def from_n_axes(cls, n_axes: int)
⋮----
viewer = 'Viewer0D'
⋮----
viewer = 'Viewer1D'
⋮----
viewer = 'Viewer2D'
⋮----
viewer = 'ViewerND'
⋮----
@staticmethod
    def get_viewers_enum_from_data(dwa: DataWithAxes) -> 'ViewersEnum'
⋮----
class ViewerBase(QObject)
⋮----
"""Base Class for data viewers implementing all common functionalities

    Parameters
    ----------
    parent: QtWidgets.QWidget
    title: str

    Attributes
    ----------
    view: QObject
        Ui interface of the viewer

    data_to_export_signal: Signal[DataToExport]
    ROI_changed: Signal
    crosshair_dragged: Signal[float, float]
    crosshair_clicked: Signal[bool]
    sig_double_clicked: Signal[float, float]
    status_signal: Signal[str]
    """
data_to_export_signal = Signal(DataToExport)
_data_to_show_signal = Signal(DataWithAxes)
⋮----
ROI_changed = Signal()
crosshair_dragged = Signal(float, float)  # Crosshair position in units of scaled top/right axes
status_signal = Signal(str)
crosshair_clicked = Signal(bool)
sig_double_clicked = Signal(float, float)
ROI_select_signal = Signal(QRectF)  # deprecated: use roi_select_signal
roi_select_signal = Signal(RoiInfo)
⋮----
def __init__(self, parent: QtWidgets.QWidget = None, title='')
⋮----
parent = QtWidgets.QWidget()
⋮----
@property
    def has_action(self)
⋮----
"""Convenience method"""
⋮----
@property
    def is_action_checked(self)
⋮----
@property
    def is_action_visible(self)
⋮----
@property
    def set_action_checked(self)
⋮----
@property
    def set_action_visible(self)
⋮----
@property
    def get_action(self)
⋮----
@property
    def toolbar(self)
⋮----
"""Convenience property"""
⋮----
@property
    def viewer_type(self)
⋮----
"""str: the viewer data type see DATA_TYPES"""
⋮----
def show_data(self, data: DataWithAxes, **kwargs)
⋮----
"""Entrypoint to display data into the viewer

        Parameters
        ----------
        data: data_mod.DataFromPlugins
        """
⋮----
def show_data_temp(self, data: DataWithAxes, **kwargs)
⋮----
"""Entrypoint to display temporary data into the viewer

        No processed data signal is emitted from the viewer

        Parameters
        ----------
        data: data_mod.DataFromPlugins
        """
⋮----
def _show_data(self, data: DataWithAxes, *args, **kwargs)
⋮----
"""Specific viewers should implement it"""
⋮----
def add_attributes_from_view(self)
⋮----
"""Convenience function to add attributes from the view to self"""
⋮----
def trigger_action(self, action_name: str)
⋮----
"""Convenience function to trigger programmatically one of the action of the related view"""
⋮----
def activate_roi(self, activate=True)
⋮----
"""Activate the Roi manager using the corresponding action"""
⋮----
def setVisible(self, show=True)
⋮----
"""convenience method to show or hide the parent widget"""
⋮----
@property
    def roi_target(self) -> Union[InfiniteLine.InfiniteLine, ROI.ROI]
⋮----
"""To be implemented if necessary (Viewer1D and above)"""
⋮----
def move_roi_target(self, pos: Iterable[float] = None, **kwargs)
⋮----
"""move a specific read only ROI at the given position on the viewer"""
⋮----
def show_roi_target(self, show=True)
⋮----
"""Show/Hide a specific read only ROI"""
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/viewer.py">
config_viewers = {}
⋮----
logger = set_logger(get_module_name(__file__))
⋮----
def get_viewer_enum_from_axes(Naxes: int)
⋮----
viewer_enum = ViewersEnum['Viewer0D']
⋮----
viewer_enum = ViewersEnum['Viewer1D']
⋮----
viewer_enum = ViewersEnum['Viewer2D']
⋮----
viewer_enum = ViewersEnum['ViewerND']
⋮----
class ViewerFactory(ObjectFactory)
⋮----
def get(self, viewer_name, **kwargs)
⋮----
@property
    def viewers(self)
⋮----
@ViewerFactory.register('Viewer0D')
def create_viewer0D(parent: QtWidgets.QWidget = None, **_ignored)
⋮----
@ViewerFactory.register('Viewer1D')
def create_viewer1D(parent: QtWidgets.QWidget, **_ignored)
⋮----
@ViewerFactory.register('Viewer2D')
def create_viewer2D(parent: QtWidgets.QWidget, **_ignored)
⋮----
@ViewerFactory.register('ViewerND')
def create_viewerND(parent: QtWidgets.QWidget, **_ignored)
⋮----
# @ViewerFactory.register('ViewerSequential')
# def create_viewer_sequential(widget: QtWidgets.QWidget, **_ignored):
#     return data_viewers.viewer_sequential.ViewerSequential(widget)
⋮----
viewer_factory = ViewerFactory()
⋮----
class ViewerDispatcher
⋮----
"""MixIn class to add easy control for adding multuiple data viewers in docks depending on
    data to be plotted

    Parameters
    ----------
    dockarea: DockArea
    title: str
    next_to_dock: Dock
        (deprecated) has no effect
    direction: str
        either 'right', 'left', 'bottom', 'top'.

    """
⋮----
dockarea = DockArea()
⋮----
@property
    def viewers(self) -> List[ViewerBase]
⋮----
@property
    def viewer_docks(self) -> List[Dock]
⋮----
@property
    def viewer_widgets(self) -> List[QtWidgets.QWidget]
⋮----
@property
    def viewer_types(self) -> List[ViewersEnum]
⋮----
def remove_viewers(self, Nviewers_to_leave: int = 0)
⋮----
"""Remove viewers from the list after index Nviewers_to_leave

        Parameters
        ----------
        Nviewers

        Returns
        -------

        """
⋮----
widget = self.viewer_widgets.pop()
⋮----
dock = self.viewer_docks.pop()
⋮----
def add_viewer(self, viewer_type: ViewersEnum, dock_viewer=None, dock_name=None)
⋮----
viewer_type = enum_checker(ViewersEnum, viewer_type)
⋮----
dock_name = f'{self._title}_Viewer_{len(self.viewer_docks) + 1}'
dock_viewer = Dock(dock_name, size=(350, 350), closable=False)
⋮----
# if len(self.viewer_docks) == 1:
#     if self._next_to_dock is not None:
#         self.dockarea.addDock(self.viewer_docks[-1], 'right', self._next_to_dock)
#     else:
#         self.dockarea.addDock(self.viewer_docks[-1])
# else:
#     self.dockarea.addDock(self.viewer_docks[-1], 'right', self.viewer_docks[-2])
⋮----
"""

        Parameters
        ----------
        viewers_type: List[ViewersEnum]
        viewers_name: List[str] or None
        force: bool
            if True remove all viewers before update else check if new viewers type are compatible with old ones

        Returns
        -------

        """
⋮----
Nviewers_to_leave = 0
⋮----
# check if viewers are compatible with new data dim
⋮----
ind_loop = 0
⋮----
def close(self)
⋮----
def show_data(self, data: DataToExport, **kwargs)
⋮----
""" Convenience method. Display each dwa in a dedicated data viewer"""
viewer_types = [ViewersEnum.get_viewers_enum_from_data(dwa) for dwa in data]
viewer_names = [dwa.name for dwa in data]
⋮----
LABEL = 'A Label'
UNITS = 'units'
OFFSET = -20.4
SCALING = 0.22
SIZE = 20
DATA = OFFSET + SCALING * np.linspace(0, SIZE - 1, SIZE)
⋮----
DATA0D = np.array([2.7])
DATA1D = np.arange(0, 10)
DATA2D = np.arange(0, 5 * 6).reshape((5, 6))
DATAND = np.arange(0, 5 * 6 * 3).reshape((5, 6, 3))
Nn0 = 10
Nn1 = 5
⋮----
def init_axis(data=None, index=0)
⋮----
data = DATA
⋮----
data = DATA2D
⋮----
def ini_data_to_export()
⋮----
dat1 = init_data(data=DATA2D, Ndata=2, name='data2D')
dat2 = init_data(data=DATA1D, Ndata=3, name='data1D')
data = DataToExport(name='toexport', data=[dat1, dat2])
⋮----
app = QtWidgets.QApplication(sys.argv)
⋮----
prog = ViewerDispatcher(dockarea=dockarea, title='Dispatcher')
⋮----
# N = 2
# viewers = ['Viewer0D', 'Viewer1D', 'Viewer2D']
# viewers = [ViewersEnum[random.choice(viewers)] for ind in range(N)]
# viewers = ['Viewer2D', 'Viewer2D', ]
# print(viewers)
# prog.update_viewers(viewers)
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/viewer0D.py">
logger = set_logger(get_module_name(__file__))
PLOT_COLORS = [dict(color=color) for color in utils.plot_colors]
⋮----
class DataDisplayer(QObject)
⋮----
"""
    This Object deals with the display of 0D data  on a plotitem
    """
⋮----
updated_item = Signal(list)
labels_changed = Signal(list)
⋮----
def __init__(self, plotitem: pyqtgraph.PlotItem, plot_colors=PLOT_COLORS)
⋮----
axis = self._plotitem.getAxis('bottom')
⋮----
def update_colors(self, colors: List[QtGui.QPen])
⋮----
@property
    def legend(self) -> pyqtgraph.LegendItem
⋮----
@property
    def legend_names(self) -> List[str]
⋮----
@property
    def axis(self)
⋮----
def clear_data(self)
⋮----
def update_axis(self, history_length: int)
⋮----
@property
    def Ndata(self)
⋮----
def update_data(self, data: data_mod.DataWithAxes, force_update=False)
⋮----
def update_display_items(self, data: data_mod.DataWithAxes = None)
⋮----
plot_item = self._plotitem.removeItem(self._plot_items.pop(0))
⋮----
max_line = pyqtgraph.InfiniteLine(angle=0,
min_line = pyqtgraph.InfiniteLine(angle=0,
⋮----
def show_min_max(self, show=True)
⋮----
class View0D(ActionManager, QObject)
⋮----
self.get_action('Nhistory').setValue(200) #default history length
⋮----
def setup_actions(self)
⋮----
def _setup_widgets(self)
⋮----
splitter_hor = QtWidgets.QSplitter(Qt.Horizontal)
⋮----
font = QtGui.QFont()
⋮----
def _connect_things(self)
⋮----
def _prepare_ui(self)
⋮----
"""add here everything needed at startup"""
⋮----
def get_double_clicked(self)
⋮----
@property
    def plotitem(self)
⋮----
def display_data(self, data: data_mod.DataWithAxes, displayer: str = None, **kwargs)
⋮----
def show_data_list(self, state=None)
⋮----
state = self.is_action_checked('show_data_as_list')
⋮----
def add_data_displayer(self, displayer_name: str, plot_colors=PLOT_COLORS)
⋮----
def remove_data_displayer(self, displayer_name: str)
⋮----
displayer = self.other_data_displayers.pop(displayer_name, None)
⋮----
class Viewer0D(ViewerBase)
⋮----
"""this plots 0D data on a plotwidget with history. Display as numbers in a table is possible.

    Datas and measurements are then exported with the signal data_to_export_signal
    """
⋮----
def __init__(self, parent=None, title='', show_toolbar=True, no_margins=False)
⋮----
def update_colors(self, colors: list, displayer=None)
⋮----
@property
    def labels(self)
⋮----
@labels.setter
    def labels(self, labels)
⋮----
@Slot(list)
    def _show_data(self, data: data_mod.DataRaw)
⋮----
def main_view()
⋮----
app = QtWidgets.QApplication(sys.argv)
widget = QtWidgets.QWidget()
prog = View0D(widget)
⋮----
def main()
⋮----
prog = Viewer0D(widget, show_toolbar=False)
⋮----
x = np.linspace(0, 200, 201)
y1 = gauss1D(x, 75, 25) + 0.1*np.random.rand(len(x))
y2 = 0.7 * gauss1D(x, 120, 50, 2) + 0.2*np.random.rand(len(x))
⋮----
if __name__ == '__main__':  # pragma: no cover
#main_view()
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/viewer1D.py">
logger = set_logger(get_module_name(__file__))
⋮----
PLOT_COLORS = utils.plot_colors
⋮----
class DataDisplayer(QObject)
⋮----
"""
    This Object deals with the display of 1D data  on a plotitem
    """
⋮----
updated_item = Signal(list)
labels_changed = Signal(list)
⋮----
def __init__(self, plotitem: pg.PlotItem, flip_axes=False, plot_colors=PLOT_COLORS)
⋮----
@property
    def Ndata(self)
⋮----
def update_colors(self, colors: list)
⋮----
@property
    def legend(self)
⋮----
def update_axis(self, axis: Axis)
⋮----
if self._axis.get_data() is None:  # create real data vector once here for subsequent use
⋮----
def get_axis(self) -> Axis
⋮----
def get_plot_items(self)
⋮----
def get_plot_item(self, index: int)
⋮----
force_update = True
⋮----
def update_xy(self, do_xy=False)
⋮----
def update_sort(self, do_sort=False)
⋮----
def update_scatter(self, do_scatter=False)
⋮----
def update_errors(self, show_errors=False)
⋮----
def update_plot(self, do_xy=True, data=None, sort_data=False, scatter=False, show_errors=False)
⋮----
data = self._data
⋮----
data = data.sort_data()
⋮----
symbol_size = data.symbol_size
⋮----
symbol_size = 5
⋮----
symbol = data.symbol
⋮----
symbol = 'o'
⋮----
color = data.color
⋮----
color = None
⋮----
def update_xyplot(self, do_xy=True, dwa: DataWithAxes=None)
⋮----
dwa = self._data
_axis = dwa.get_axis_from_index(0)[0]
_axis_array = _axis.get_data()
⋮----
axis = self._plotitem.getAxis('bottom')
⋮----
axis = self._plotitem.getAxis('left')
⋮----
def plot_with_scatter(self, with_scatter=True, symbol_size=5, symbol='o', color=None)
⋮----
color = self._plot_colors[ind]
⋮----
pen = None
symbol_type = symbol
brush = color
⋮----
pen = color
symbol_type = None
brush = None
⋮----
def update_display_items(self, data: DataWithAxes = None, show_errors=False)
⋮----
b_items = self._boundary_items.pop(0)
⋮----
@property
    def labels(self)
⋮----
def legend_items(self)
⋮----
def show_overlay(self, show=True)
⋮----
pen = pg.mkPen(color=self._plot_colors[ind], style=Qt.CustomDashLine)
⋮----
class View1D(ActionManager, QObject)
⋮----
def add_data_displayer(self, displayer_name: str, plot_colors=PLOT_COLORS)
⋮----
def remove_data_displayer(self, displayer_name: str)
⋮----
displayer = self.other_data_displayers.pop(displayer_name, None)
⋮----
@Slot(int, str, str)
    def add_roi_displayer(self, index, roi_type='', roi_name='')
⋮----
color = self.roi_manager.ROIs[roi_name].color
⋮----
@Slot(str)
    def remove_roi_displayer(self, roi_name='')
⋮----
def move_roi_target(self, pos: Iterable[float], **kwargs)
⋮----
def get_double_clicked(self)
⋮----
def display_roi_lineouts(self, roi_dte: DataToExport)
⋮----
@property
    def axis(self)
⋮----
"""Get the current axis used to display data"""
⋮----
@property
    def plotitem(self)
⋮----
def get_crosshair_signal(self)
⋮----
"""Convenience function from the Crosshair"""
⋮----
def get_crosshair_position(self)
⋮----
def set_crosshair_position(self, *positions)
⋮----
def display_data(self, data: Union[DataWithAxes, DataToExport], displayer: str = None)
⋮----
def prepare_ui(self)
⋮----
def do_math(self)
⋮----
@Slot(int, str)
    def update_roi_channels(self, index, roi_type='')
⋮----
"""Update the use_channel setting each time a ROI is added"""
⋮----
def setup_widgets(self)
⋮----
splitter_hor = QtWidgets.QSplitter(Qt.Horizontal)
⋮----
def connect_things(self)
⋮----
def process_xyplot(self)
⋮----
""" Uncheck things if xyplot is active"""
⋮----
def show_ROI_select(self)
⋮----
def setup_actions(self)
⋮----
def lock_aspect_ratio(self)
⋮----
def update_crosshair_data(self, crosshair_dte: DataToExport)
⋮----
dwa = crosshair_dte[0]
string = "y="
⋮----
@Slot(bool)
    def show_hide_crosshair(self, show=True)
⋮----
range = self.plotitem.vb.viewRange()
⋮----
def add_plot_item(self, item)
⋮----
class Viewer1D(ViewerBase)
⋮----
""" DataWithAxis of type Data1D can be plotted using this data viewer

    Methods
    -------
    show_data:
        parameter:
        * dwa: a DataWithaxis
        * scatter_dwa: an optional extra DataWithAxis to be plotted with scatter points
          it could define extra_attributes such as symbol: str (to define the symbol layout
          default: 'o') and symbol_size: int (to define the symbol size)

    """
⋮----
def update_colors(self, colors: List, displayer=None)
⋮----
@property
    def roi_manager(self)
⋮----
"""Convenience method """
⋮----
@property
    def roi_target(self) -> pg.InfiniteLine
⋮----
def move_roi_target(self, pos: Iterable[float] = None)
⋮----
"""move a specific read only ROI at the given position on the viewer"""
⋮----
@property
    def crosshair(self)
⋮----
def set_crosshair_position(self, xpos, ypos=0)
⋮----
"""Convenience method to set the crosshair positions"""
⋮----
def process_crosshair_lineouts(self, crosshair_dte: DataToExport)
⋮----
def process_roi_lineouts(self, roi_dte: DataToExport)
⋮----
roi_dte_bis = roi_dte.deepcopy()
⋮----
def prepare_connect_ui(self)
⋮----
def selected_region_changed(self)
⋮----
def double_clicked(self, posx, posy=0)
⋮----
def roi_changed(self)
⋮----
def crosshair_changed(self)
⋮----
def activate_roi(self, activate=True)
⋮----
@labels.setter
    def labels(self, labels)
⋮----
def get_axis_from_view(self, data: DataWithAxes)
⋮----
def update_status(self, txt)
⋮----
def main()
⋮----
app = QtWidgets.QApplication(sys.argv)
Form = QtWidgets.QWidget()
prog = Viewer1D(Form)
⋮----
x = np.linspace(0, 200, 201)
y1 = gauss1D(x, 75, 25)
y2 = gauss1D(x, 120, 50, 2)
tau_half = 27
tau2 = 100
x0 = 50
dx = 20
ydata_expodec = np.zeros((len(x)))
⋮----
ydata_expodec[50:] = 1 * np.exp(-(x[50:] - x0) / (tau_half / np.log(2)))  # +1*np.exp(-(x[50:]-x0)/tau2)
⋮----
# x = np.sin(np.linspace(0,6*np.pi,201))
# y = np.sin(np.linspace(0, 6*np.pi, 201)+np.pi/2)
data = DataRaw('mydata', data=[y1, ydata_expodec, -ydata_expodec, -y1,
⋮----
def print_data(data: DataToExport)
⋮----
#prog.data_to_export_signal.connect(print_data)
⋮----
def main_unsorted()
⋮----
widget = QtWidgets.QWidget()
prog = Viewer1D(widget)
⋮----
xaxis = np.concatenate((x, x[::-1]))
y = gauss1D(x, 75, 25)
yaxis = np.concatenate((y, -y))
data = DataRaw('mydata', data=[yaxis],
⋮----
def main_random()
⋮----
x = np.random.randint(201, size=201)
⋮----
data = DataRaw('mydata', data=[y1, y2],
⋮----
def main_extra_scatter()
⋮----
xlow = np.linspace(0, 200, 21)
⋮----
ylow = gauss1D(xlow, 75, 25)
⋮----
data = DataRaw('mydata', data=[y],
scatter_dwa = DataRaw('scatter', data=[ylow],
⋮----
def main_errors()
⋮----
def main_view1D()
⋮----
prog = View1D(widget)
⋮----
def main_nans()
⋮----
def main_xy()
⋮----
if __name__ == '__main__':  # pragma: no cover
#main()
# main_random()
#main_errors()
#main_extra_scatter()
⋮----
#main_view1D()
#main_nans()
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/viewer1Dbasic.py">
logger = set_logger(get_module_name(__file__))
⋮----
class Viewer1DBasic(QObject)
⋮----
"""this plots 1D data on a plotwidget. one linear region to select data, one infinite line to select point
    """
roi_region_signal = Signal(tuple)
roi_line_signal = Signal(float)
⋮----
def __init__(self, parent=None, show_region=False, show_line=False)
⋮----
"""

        Parameters
        ----------
        parent

        Attributes
        ----------
        parent: (QWidget)
        roi_region: (pyqtgraph LinerrRegionItem)
        roi_line: (pyqtgraph InfiniteLine graphitem)
        Properties
        ----------
        labels: (list of str)
        x_axis: (Axis or dict)

        """
⋮----
parent = QtWidgets.QWidget()
⋮----
def show(self, state=True)
⋮----
def setup_ui(self)
⋮----
vboxlayout = QtWidgets.QVBoxLayout()
⋮----
def get_line_position(self)
⋮----
def show_roi_region(self, show=True)
⋮----
def show_roi_line(self, show=True)
⋮----
def update_region(self, item)
⋮----
def update_line(self, item)
⋮----
@property
    def labels(self)
⋮----
@labels.setter
    def labels(self, labels)
⋮----
def update_labels(self, labels=[])
⋮----
labels_tmp = labels[:]
⋮----
flag = True
⋮----
items = [item[1].text for item in self.legend.items]
⋮----
flag = False
⋮----
@Slot(list)
    def show_data(self, datas)
⋮----
if self.plot_channels is None:  # initialize data and plots
⋮----
def ini_data_plots(self, Nplots)
⋮----
channels = []
⋮----
channel = self.plotwidget.plot()
⋮----
def remove_plots(self)
⋮----
def set_axis_label(self, axis_settings=dict(orientation='bottom', label='x axis', units='pxls'))
⋮----
axis = self.plotwidget.plotItem.getAxis(axis_settings['orientation'])
⋮----
@property
    def x_axis(self)
⋮----
@x_axis.setter
    def x_axis(self, x_axis)
⋮----
label = 'Pxls'
units = ''
⋮----
xdata = x_axis['data']
⋮----
label = x_axis['label']
⋮----
units = x_axis['units']
⋮----
xdata = x_axis
⋮----
if __name__ == '__main__':  # pragma: no cover
app = QtWidgets.QApplication(sys.argv)
⋮----
def print_region(xx)
⋮----
def print_line(x)
⋮----
Form = QtWidgets.QWidget()
prog = Viewer1DBasic(Form)
# prog.show_roi_region()
⋮----
x = np.linspace(0, 200, 201)
y1 = gauss1D(x, 75, 25)
y2 = gauss1D(x, 120, 50, 2)
tau_half = 27
tau2 = 100
x0 = 50
dx = 20
ydata_expodec = np.zeros((len(x)))
⋮----
ydata_expodec[50:] = 1 * np.exp(-(x[50:] - x0) / (tau_half / np.log(2)))  # +1*np.exp(-(x[50:]-x0)/tau2)
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/viewer2D_basic.py">
class Viewer2DBasic(ViewerBase)
⋮----
"""Very Basic 2D Viewer used as a view to add Image Items into it and use the image object directly

    Not meant to plot directly data, see Viewer2D for that

    See Also
    --------
    Navigator, UniformImageItem, SpreadImageItem

    """
⋮----
def __init__(self, parent: QtWidgets.QWidget = None, **kwargs)
⋮----
def scale_axis(self, xaxis, yaxis)
⋮----
@Slot(float, float)
    def double_clicked(self, posx, posy)
⋮----
def setup_ui(self)
⋮----
vlayout = QtWidgets.QVBoxLayout()
hsplitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
⋮----
# self.scaled_xaxis.linkToView(self.image_widget.view)
# self.scaled_yaxis.linkToView(self.image_widget.view)
⋮----
# self.image_widget.plotitem.layout.addItem(self.scaled_xaxis, *(1, 1))
# self.image_widget.plotitem.layout.addItem(self.scaled_yaxis, *(2, 2))
⋮----
# histograms
⋮----
histo_layout = QtWidgets.QHBoxLayout()
⋮----
Ntick = 3
colors_red = [(int(r), 0, 0) for r in np.linspace(0, 255, Ntick)]
colors_green = [(0, int(g), 0) for g in np.linspace(0, 255, Ntick)]
colors_blue = [(0, 0, int(b)) for b in np.linspace(0, 255, Ntick)]
colors_adaptive = [(int(b), int(b), int(b)) for b in np.linspace(0, 255, Ntick)]
cmap_red = pg.ColorMap(pos=np.linspace(0.0, 1.0, Ntick), color=colors_red)
cmap_green = pg.ColorMap(pos=np.linspace(0.0, 1.0, Ntick), color=colors_green)
cmap_blue = pg.ColorMap(pos=np.linspace(0.0, 1.0, Ntick), color=colors_blue)
cmap_adaptive = pg.ColorMap(pos=np.linspace(0.0, 1.0, Ntick), color=colors_adaptive)
⋮----
def _show_data(self, data: DataRaw)
⋮----
"""This basic viewer is not meant to plot data directly

        """
⋮----
def set_aspect_ratio(self, status=True)
⋮----
@property
    def plotitem(self)
⋮----
@property
    def histograms(self)
⋮----
def add_image_item(self, image: Union[SpreadImageItem, UniformImageItem], histogram: pg.HistogramLUTWidget = None)
⋮----
"""Adds an image item to this viewer plotitem

        Links it to an existing histogram
        """
⋮----
if __name__ == '__main__':  # pragma: no cover
⋮----
app = QtWidgets.QApplication(sys.argv)
form = QtWidgets.QWidget()
prog = Viewer2DBasic(form)
img = SpreadImageItem()
⋮----
svg_item = QtSvg.QGraphicsSvgItem()
svg_renderer = QtSvg.QSvgRenderer(
⋮----
data = np.load('../../../resources/triangulation_data.npy')
⋮----
curr_size = svg_renderer.defaultSize()
real_size = svg_item.boundingRect()
# tr = QtGui.QTransform()
# tr.translate(rect.left(), rect.top())
# tr.scale(300/rect.width(), 300/rect.height())
# svg_item.setTransform(tr)
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/viewer2D.py">
logger = set_logger(get_module_name(__file__))
⋮----
COLORS_DICT = dict(red=(255, 0, 0), green=(0, 255, 0), blue=(0, 0, 255), spread=(128, 128, 128))
⋮----
IMAGE_TYPES = ['red', 'green', 'blue']
COLOR_LIST = utils.plot_colors
crosshair_pens = make_dashed_pens(color=(255, 255, 0))
⋮----
def image_item_factory(item_type='uniform', axisOrder='row-major', pen='r') -> Union[UniformImageItem, SpreadImageItem]
⋮----
image = UniformImageItem(pen=pen)
⋮----
image = SpreadImageItem(pen=pen)
⋮----
def histogram_factory(image_item=None, gradient='red')
⋮----
"""
    Create a pyqtgraph HistogramLUTWidget widget (histogram) and link it to the corresponding image_item
    Parameters
    ----------
    image_item: (ImageItem) the image item to be linked with the histogram
    gradient: (str) either 'red', 'green', 'blue', 'spread' or one of the Gradients

    Returns
    -------
    HistogramLUTWidget instance
    """
⋮----
histo = pg.HistogramLUTWidget()
⋮----
class ImageDisplayer(QObject)
⋮----
"""
    This Object deals with the display of 2D data  with a plotitem
    """
⋮----
updated_item = Signal(dict)
⋮----
def __init__(self, plotitem, data_distribution: DataDistribution)
⋮----
def show_legend(self, show=True)
⋮----
@property
    def legend(self)
⋮----
def get_images(self)
⋮----
def get_image(self, name)
⋮----
@property
    def labels(self)
⋮----
@property
    def autolevels(self)
⋮----
def set_autolevels(self, isautolevel: bool)
⋮----
@property
    def levels_sym(self) -> bool
⋮----
def set_levels_sym(self, levels_sym: bool)
⋮----
def update_data(self, dwa: DataWithAxes)
⋮----
nav_axes = dwa.get_nav_axes()
data_array = np.stack((nav_axes[0].get_data(),
⋮----
def update_display_items(self, labels: List[str] = None)
⋮----
labels = []
⋮----
def update_image_visibility(self, are_items_visible)
⋮----
class Histogrammer(QObject)
⋮----
gradient_changed = Signal()
⋮----
def __init__(self, histogram_container: QtWidgets.QWidget, histogram_refs=IMAGE_TYPES)
⋮----
def setup_histograms(self)
⋮----
def get_histograms(self)
⋮----
def get_histogram(self, name)
⋮----
@Slot(bool)
    def set_autolevels(self, isautolevels=True)
⋮----
@Slot(bool)
    def activated(self, histo_action_checked)
⋮----
def affect_histo_to_imageitems(self, image_items)
⋮----
# TODO: if self._histogram_refs doesn't contains the same refs as image_items, we have an issue...
⋮----
def add_histogram(self, histogram)
⋮----
def show_hide_histogram(self, checked, are_items_visible)
⋮----
def set_gradient(self, histo='red', gradient='grey')
⋮----
"""
        Change the color gradient of the specified histogram
        Parameters
        ----------
        histo: (str) either 'red', 'green', 'blue', 'spread' or 'all'
        gradient: (str or Gradient)
        """
⋮----
class IsoCurver(QObject)
⋮----
def __init__(self, image_source, histogram_parent)
⋮----
def setup_iso_curve(self, parent_image_item='red')
⋮----
# # Isocurve drawing
⋮----
# # Draggable line for setting isocurve level
⋮----
self._isoLine.setZValue(1000)  # bring iso line above contrast controls
⋮----
def update_image_source(self, image_source)
⋮----
def update_histogram_parent(self, histogram)
⋮----
histogram.vb.setMouseEnabled(y=False)  # makes user interaction a little easier
⋮----
def update_isocurve(self)
⋮----
def set_isocurve_data(self, data)
⋮----
@Slot(bool)
    def show_hide_iso(self, show=True)
⋮----
class View2D(ActionManager, QtCore.QObject)
⋮----
lineout_types = ['hor', 'ver', 'int']
⋮----
def __init__(self, parent_widget=None)
⋮----
def clear_plot_item(self)
⋮----
def set_image_displayer(self, data_distribution: DataDistribution)
⋮----
def show_roi_target(self, show=True)
⋮----
def move_scale_roi_target(self, pos=None, size=None)
⋮----
"""
        Move and scale the target ROI (used to display a particular area,
        for instance the currently scanned points
        during a scan
        Parameters
        ----------
        pos: (iterable) setting the central position of the ROI in the view
        size: (iterable) setting the size of the ROI
        """
⋮----
size = list(np.divide(list(size), [x_scaling, y_scaling]))
⋮----
pos = self.unscale_axis(*list(pos))
pos = list(pos)
⋮----
def setup_widgets(self)
⋮----
vertical_layout = QtWidgets.QVBoxLayout()
⋮----
splitter_vertical = QtWidgets.QSplitter(QtCore.Qt.Vertical)
⋮----
def setup_graphs(self, graphs_layout)
⋮----
def setup_actions(self)
⋮----
def update_colors(self, colors: list)
⋮----
def connect_things(self)
⋮----
@Slot(int, str, str)
    def add_roi_displayer(self, index, roi_type='', roi_name='')
⋮----
color = self.roi_manager.ROIs[roi_name].color
⋮----
@Slot(str)
    def remove_roi_displayer(self, roi_name='')
⋮----
@Slot(int, str, str)
    def update_roi_channels(self, index, roi_type='')
⋮----
"""Update the use_channel setting each time a ROI is added"""
⋮----
def prepare_ui(self)
⋮----
@Slot(DataRaw)
    def display_images(self, datas)
⋮----
def display_roi_lineouts(self, roi_dte: DataToExport)
⋮----
dwa = roi_dte.get_data_from_name_origin(lineout_type, displayer_name)
⋮----
def display_crosshair_lineouts(self, crosshair_dte: DataToExport)
⋮----
dwa = crosshair_dte.get_data_from_name(lineout_type)
⋮----
def show_lineout_widgets(self)
⋮----
state = self.is_action_checked('roi') or self.is_action_checked('crosshair')
⋮----
@Slot(bool)
    def roi_clicked(self, isroichecked=True)
⋮----
def get_visible_images(self)
⋮----
are_items_visible = []
⋮----
def notify_visibility_data_displayer(self)
⋮----
are_items_visible = self.get_visible_images()
⋮----
@Slot(bool)
    def show_hide_histogram(self, show=True)
⋮----
def prepare_image_widget_for_lineouts(self, ratio=0.7)
⋮----
def collapse_lineout_widgets(self)
⋮----
def get_view_range(self)
⋮----
def get_data_at(self, name='red', xy=(0, 0))
⋮----
def lock_aspect_ratio(self)
⋮----
lock = self.is_action_checked('aspect_ratio')
⋮----
ratio = x_scaling / y_scaling
⋮----
@Slot(int, int)
    def move_left_splitter(self, pos, index)
⋮----
@Slot(int, int)
    def move_right_splitter(self, pos, index)
⋮----
def get_double_clicked(self)
⋮----
def get_axis(self, position='left') -> AxisItem_Scaled
⋮----
@property
    def plotitem(self)
⋮----
def get_image_item(self, color='red')
⋮----
def get_crosshair_signal(self)
⋮----
"""Convenience function from the Crosshair"""
⋮----
def get_crosshair_position(self)
⋮----
def set_crosshair_position(self, *positions)
⋮----
@Slot(bool)
    def show_hide_crosshair(self, show=True)
⋮----
range = self.get_view_range()
⋮----
def show_ROI_select(self)
⋮----
rect = self.data_displayer.get_image('red').boundingRect()
⋮----
def set_image_labels(self, labels: List[str])
⋮----
action_names =['red', 'green', 'blue']
⋮----
def set_axis_label(self, position, label='', units='')
⋮----
"""
        Convenience method to set label and unit of any view axes
        Parameters
        ----------
        position: (str) any of AXIS_POSITIONS
        label: (str) text of the axis label
        units: (str) units of the axis label
        """
axis = self.get_axis(position)
⋮----
def get_axis_label(self, position)
⋮----
def set_axis_scaling(self, position='top', scaling=1, offset=0, label='', units='Pxls')
⋮----
"""
        Method used to update the scaling of the right and top axes in order to translate pixels to real coordinates
        Parameters
        ----------
        position: (str) axis position either one of AXIS_POSITIONS
        scaling: (float) scaling of the axis
        offset: (float) offset of the axis
        label: (str) text of the axis label
        units: (str) units of the axis label
        """
⋮----
scaling = 1
⋮----
offset = 0
⋮----
def scale_axis(self, xaxis, yaxis)
⋮----
"""scale view coordinates from the regular axes to the scaled/offset ones"""
⋮----
def unscale_axis(self, xaxis, yaxis)
⋮----
"""scale view coordinates from the scaled/offset axes to the regular ones"""
⋮----
def _get_axis_scaling_offset(self)
⋮----
x_offset = self.get_axis('top').axis_offset
x_scaling = self.get_axis('top').axis_scaling
y_offset = self.get_axis('right').axis_offset
y_scaling = self.get_axis('right').axis_scaling
⋮----
class Viewer2D(ViewerBase)
⋮----
"""Object managing plotting and manipulation of 2D data using a View2D"""
⋮----
def __init__(self, parent: QtWidgets.QWidget = None, title='')
⋮----
@property
    def roi_manager(self)
⋮----
"""Convenience method """
⋮----
@property
    def roi_target(self) -> pgROI
⋮----
def move_roi_target(self, pos: Iterable[float] = None, size: Iterable[float] = (1, 1))
⋮----
"""move a specific read only ROI at the given position on the viewer"""
⋮----
@property
    def crosshair(self)
⋮----
@property
    def image_widget(self)
⋮----
def get_data_at(self)
⋮----
def set_crosshair_position(self, xpos, ypos)
⋮----
"""Convenience method to set the crosshair positions"""
⋮----
def activate_roi(self, activate=True)
⋮----
"""Activate the Roi manager using the corresponding action"""
⋮----
def roi_changed(self, *args, **kwargs)
⋮----
def crosshair_changed(self)
⋮----
def set_gradient(self, image_key, gradient)
⋮----
"""convenience function"""
⋮----
def _show_data(self, data: DataWithAxes, *args, **kwargs)
⋮----
"""Data to be plotted and eventually filtered using ROI...

        Parameters
        ----------
        data: DataWithAxes

        """
⋮----
self.get_axes_from_view(data)  # in case axes were not specified into data, one try to get them from the view
⋮----
def autolevels_first(self)
⋮----
def get_axes_from_view(self, data: DataWithAxes)
⋮----
"""Obtain axes info from the view

        Only for uniform data
        """
⋮----
axis_view = self.view.get_axis('right')
axis = Axis(axis_view.axis_label, units=axis_view.axis_units,
⋮----
axis_view = self.view.get_axis('top')
⋮----
def update_data(self)
⋮----
def set_image_transform(self) -> DataRaw
⋮----
"""
        Deactivate some tool buttons if data type is "spread" then apply transform_image
        """
data = copy.deepcopy(self._raw_data)
⋮----
data = self.transform_image(data)
⋮----
def transform_image(self, dwa: DataWithAxes)
⋮----
dwa = np.flipud(dwa)
⋮----
dwa = np.fliplr(dwa)
⋮----
dwa = np.flipud(np.transpose(dwa))
⋮----
dwa = -dwa
⋮----
def set_visible_items(self)
⋮----
def show_roi(self, show=True, show_roi_widget=True)
⋮----
"""convenience function to control roi"""
⋮----
def update_crosshair_data(self, crosshair_dte: DataToExport)
⋮----
dat = f'({posx_scaled:.1e}{posy_scaled:.1e})\n'
dwa_int = crosshair_dte.get_data_from_name('int')
⋮----
def prepare_connect_ui(self)
⋮----
# todo : self.view.lineout_plotter.roi_changed.connect(self.roi_changed)
⋮----
def selected_region_changed(self)
⋮----
pos = self.view.ROIselect.pos()
size = self.view.ROIselect.size()
# self.ROI_select_signal.emit(QtCore.QRectF(pos[0], pos[1], size[0], size[1]))
⋮----
@Slot(float, float)
    def double_clicked(self, posx, posy)
⋮----
#scale positions of double_click with respect to real axes
⋮----
@property
    def x_axis(self)
⋮----
@x_axis.setter
    def x_axis(self, axis: Axis = None)
⋮----
@property
    def y_axis(self)
⋮----
@y_axis.setter
    def y_axis(self, axis: Axis = None)
⋮----
@Slot(DataToExport)
    def process_crosshair_lineouts(self, dte)
⋮----
def process_roi_lineouts(self, roi_dte: DataToExport)
⋮----
roi_dte_bis = roi_dte.deepcopy()
⋮----
dwa = roi_dte_bis.get_data_from_name_origin(f'Integrated_{roi_name}', roi_name)
⋮----
def main_spread()
⋮----
app = QtWidgets.QApplication(sys.argv)
widget = QtWidgets.QWidget()
prog = Viewer2D(widget)
⋮----
def print_data(data: DataToExport)
⋮----
data_spread = np.load('../../../resources/triangulation_data.npy')
⋮----
def main(data_distribution='uniform')
⋮----
"""either 'uniform' or 'spread'"""
⋮----
widget_button = QtWidgets.QWidget()
⋮----
button = QtWidgets.QPushButton('New Data')
ndata = QtWidgets.QSpinBox()
⋮----
data_to_plot = generate_uniform_data()
⋮----
data_to_plot = DataRaw(name='mydata', distribution='spread', data=[data_spread[:,2]],
⋮----
def generate_uniform_data() -> DataRaw
⋮----
Nx = 100
Ny = 2 * Nx
data_random = np.random.normal(size=(Ny, Nx))
x = 0.5 * np.linspace(-Nx / 2, Nx / 2 - 1, Nx)
y = 0.2 * np.linspace(-Ny / 2, Ny / 2 - 1, Ny)
x0 = 5
data_red = 3 * np.cos((x-x0) / 5) * gauss2D(x, x0, Nx / 10, y, -1, Ny / 10, 1, 90) + 0.5 * data_random
⋮----
data_green = 10 * gauss2D(x, -20, Nx / 10, y, -10, Ny / 20, 1, 0)
⋮----
data_to_plot = DataRaw(name='mydata', distribution='uniform',
⋮----
def plot_data(viewer2D: Viewer2D, ndata: int = 2)
⋮----
dwa = generate_uniform_data()
⋮----
def print_roi_select(rect)
⋮----
def main_view()
⋮----
form = QtWidgets.QWidget()
prog = View2D(form)
⋮----
if __name__ == '__main__':  # pragma: no cover
⋮----
#main_view()
⋮----
#main('spread')
</file>

<file path="src/pymodaq_gui/plotting/data_viewers/viewerND.py">
from scipy.spatial import QhullError  # works for newer version of scipy
⋮----
from scipy.spatial.qhull import QhullError  # works for old version of scipy
⋮----
logger = set_logger(get_module_name(__file__))
data_processors = DataProcessorFactory()
⋮----
DEBUG_VIEWER = False
⋮----
class BaseDataDisplayer(QObject)
⋮----
data_dim_signal = Signal(str)
processor_changed = Signal(object)
distribution: DataDistribution = abstractproperty()
⋮----
@property
    def data_shape(self)
⋮----
def update_filter(self, filter_type: str)
⋮----
def update_processor(self, math_processor: DataProcessorFactory)
⋮----
def update_data(self, data: DataRaw, force_update=False)
⋮----
def show_nav_integration(self, show=True)
⋮----
@abstractmethod
    def init_rois(self, data: DataRaw)
⋮----
"""Init crosshairs and ROIs in viewers if needed"""
⋮----
@abstractmethod
    def init(self)
⋮----
"""init viewers or postprocessing once new data are loaded"""
⋮----
@abstractmethod
    def update_viewer_data(self, **kwargs)
⋮----
""" Update the signal display depending on the position of the crosshair in the navigation panels

        """
⋮----
def updated_nav_integration(self)
⋮----
""" Means the ROI select of the 2D viewer has been moved """
⋮----
@abstractmethod
    def update_nav_data(self, x, y, width=None, height=None)
⋮----
"""Display navigator data potentially postprocessed from filters in the signal viewers"""
⋮----
@abstractmethod
    def get_nav_data(self, data: DataWithAxes, x, y, width=None, height=None) -> DataWithAxes
⋮----
"""Get filtered data"""
⋮----
def update_nav_data_from_roi(self, roi: Union[SimpleRectROI, LinearROI])
⋮----
@staticmethod
    def get_out_of_range_limits(x, y, width, height)
⋮----
width = width + x
x = 0
⋮----
height = height + y
y = 0
⋮----
def update_nav_indexes(self, nav_indexes: List[int])
⋮----
def update_nav_limits(self, x, y, width=None, height=None)
⋮----
class UniformDataDisplayer(BaseDataDisplayer)
⋮----
"""Specialized object to filter and plot linearly spaced data in dedicated viewers

    Meant for any navigation axes and up to signal data dimensionality of 2 (images)
    """
distribution = DataDistribution['uniform']
⋮----
def __init__(self, *args, **kwargs)
⋮----
def init(self, data: DataRaw)
⋮----
processor: DataProcessorFactory = data_processors
⋮----
scaled_axes = np.array(self._viewer2D.view.unscale_axis(np.array(sig_axis_limits[1]),
⋮----
def update_viewer_data(self, posx=0, posy=0)
⋮----
""" Update the signal display depending on the position of the crosshair in the navigation panels

        Parameters
        ----------
        posx: float
            from the 1D or 2D Navigator crosshair or from one of the navigation axis viewer (in that case
            nav_axis tells from which navigation axis the position comes from)
        posy: float
            from the 2D Navigator crosshair
        """
⋮----
data = self._data
⋮----
nav_axis = self._data.axes_manager.get_nav_axes()[0]
⋮----
ind_x = nav_axis.find_index(posx)
⋮----
data: DataCalculated = self._data.inav[ind_x]
⋮----
ind_x0 = max(0, int(nav_axis.find_index(x0)))
ind_x1 = min(int(nav_axis.max()), int(nav_axis.find_index(x1)))
⋮----
nav_x = self._data.axes_manager.get_nav_axes()[1]
nav_y = self._data.axes_manager.get_nav_axes()[0]
⋮----
ind_x = nav_x.find_index(posx)
ind_y = nav_y.find_index(posy)
⋮----
data = self._data.inav[ind_y, ind_x]
⋮----
ind_x0 = max(0, int(self._navigator2D.view.ROIselect.x()))
ind_y0 = max(0, int(self._navigator2D.view.ROIselect.y()))
ind_x1 = min(int(nav_x.max()), ind_x0 + int(self._navigator2D.view.ROIselect.size().x()))
ind_y1 = min(int(nav_y.max()), ind_y0 + int(self._navigator2D.view.ROIselect.size().y()))
⋮----
data = self._data.inav.__getitem__(self._axes_viewer.get_indexes())
⋮----
if len(self._data.axes_manager.sig_shape) == 0:  # means 0D data, plot on 0D viewer
⋮----
elif len(self._data.axes_manager.sig_shape) == 1:  # means 1D data, plot on 1D viewer
⋮----
elif len(self._data.axes_manager.sig_shape) == 2:  # means 2D data, plot on 2D viewer
⋮----
_data_sig = data.isig[y: y + height, x: x + width]
⋮----
def update_nav_data(self, x, y, width=None, height=None)
⋮----
nav_data = self.get_nav_data(self._data, x, y, width, height)
⋮----
nav_data.nav_indexes = ()  # transform nav axes in sig axes for plotting
⋮----
def get_nav_data(self, data: DataRaw, x, y, width=None, height=None)
⋮----
navigator_data = None
if len(data.axes_manager.sig_shape) == 0:  # signal data is 0D
navigator_data = data.deepcopy()
⋮----
elif len(data.axes_manager.sig_shape) == 1:  # signal data is 1D
⋮----
navigator_data = self._processor.get(self._filter_type).process(data.isig[indx:indy])
⋮----
elif len(data.axes_manager.sig_shape) == 2:  # signal data is 2D
⋮----
navigator_data = self._processor.get(self._filter_type).process(data.isig[y: y + height, x: x + width])
⋮----
class SpreadDataDisplayer(BaseDataDisplayer)
⋮----
"""Specialized object to filter and plot non uniformly spaced data in dedicated viewers

    Meant for any navigation axes and up to signal data dimensionality of 2 (images)
    """
distribution = DataDistribution['spread']
⋮----
def init(self, data: DataWithAxes)
⋮----
processor = data_processors  # if len(data.axes_manager.sig_shape) > 1 else math_processors1D
⋮----
""" Update the signal display depending on the position of the crosshair in the navigation panels

        Spread data can be customly represented using:
        if signal data is 0D:
            * A viewer 1D with non-linearly spaced data points (for 1 navigation axis)
            * A viewer 2D with its SpreadImage item (for 2 navigation axis)
            * A double panel: viewer for signal data and viewer 1D for all nav axes as a function of index in the data
        otherwise:
            * A double panel: viewer for signal data and viewer 1D for all nav axes as a function of index in the data
            series

        Parameters
        ----------
        posx: float
            from the 1D or 2D Navigator crosshair or from one of the navigation axis viewer (in that case
            nav_axis tells from which navigation axis the position comes from)
        posy: float
            from the 2D Navigator crosshair
        """
⋮----
nav_axes = sorted(self._data.get_nav_axes_with_data(), key=lambda axis: axis.spread_order)
⋮----
# signal data plotted as a function of nav_axes[0] so get the index corresponding to
# the position posx
ind_nav = nav_axes[0].find_index(posx)
data = self._data.inav[ind_nav]
⋮----
# signal data plotted as a function of nav_axes[0] and nav_axes[1] so get the common
# index corresponding to the position posx and posy
⋮----
# navigation plotted as a function of index all nav_axes so get the index corresponding to
⋮----
data = self._data.inav[int(posx)]
⋮----
nav_axes = nav_data.get_nav_axes_with_data()
⋮----
#nav_data.nav_indexes = ()
⋮----
#Triangulation(np.array([axis.get_data() for axis in nav_data.get_nav_axes()]))
⋮----
data_arrays = [axis.get_data() for axis in nav_axes]
labels = [axis.label for axis in nav_axes]
nav_data = DataCalculated('nav', data=data_arrays, labels=labels)
⋮----
navigator_data = data
⋮----
ind_x = data.get_axis_from_index(data.sig_indexes[0])[0].find_index(x)
ind_y = data.get_axis_from_index(data.sig_indexes[0])[0].find_index(y)
navigator_data = self._processor.get(self._filter_type).process(data.isig[ind_x:ind_y])
⋮----
def get_nav_position(self, posx=0, posy=None)
⋮----
"""
        crosshair position from the "spread" data viewer. Should return scan index where the scan was closest to posx,
        posy coordinates
        Parameters
        ----------
        posx
        posy

        See Also
        --------
        update_viewer_data
        """
# todo adapt to new layout
⋮----
nav_axes = self.get_selected_axes()
⋮----
datas = nav_axes[0]['datas']
xaxis = datas[0]
⋮----
yaxis = datas[1]
ind_scan = utils.find_common_index(xaxis, yaxis, posx, posy)
⋮----
ind_scan = mutils.find_index(xaxis, posx)[0]
⋮----
class ViewerND(ParameterManager, ActionManager, ViewerBase)
⋮----
params = [
⋮----
def __init__(self, parent: QtWidgets.QWidget = None, title='')
⋮----
def update_data_displayer(self, distribution: DataDistribution)
⋮----
def _show_data(self, data: DataRaw, **kwargs)
⋮----
force_update = False
⋮----
force_update = True
⋮----
force_update = kwargs['force_update']
⋮----
def set_data_test(self, data_shape='3D')
⋮----
data_tri = np.load('../../../resources/triangulation_data.npy')
axes = [Axis(data=data_tri[:, 0], index=0, label='x_axis', units='xunits', spread_order=0)]
⋮----
data = data_tri[:, 2]
⋮----
x = np.linspace(-50, 50, 100)
data = np.zeros((data_tri.shape[0], len(x)))
⋮----
y = np.linspace(-200, 200, 75)
data = np.zeros((data_tri.shape[0], len(y), len(x)))
⋮----
#data[ind, :] = data_tri[ind, 2] * mutils.gauss2D(0.01*x, 0.1*ind - 20, 20, y, 0.1*ind-20, 10)
⋮----
# data[ind, :] = data_tri[ind, 2] * mutils.gauss2D(0.01*x, 0.1*ind - 20, 20, y, 0.1*ind-20, 10)
⋮----
dataraw = DataRaw('NDdata', distribution='spread', dim='DataND',
⋮----
x = mutils.linspace_step(-10, 10, 0.2)
y = mutils.linspace_step(-30, 30, 2)
t = mutils.linspace_step(-200, 200, 2)
z = mutils.linspace_step(-50, 50, 0.5)
data = np.zeros((len(y), len(x), len(t), len(z)))
amp = mutils.gauss2D(x, 0, 5, y, 0, 4) + 0.1 * np.random.rand(len(y), len(x))
amp = np.ones((len(y), len(x), len(t), len(z)))
⋮----
dataraw = DataRaw('NDdata', data=data, dim='DataND', nav_indexes=[0, 1],
⋮----
data = [np.sum(data, axis=2)]
⋮----
data = [np.sum(data, axis=(2, 3))]
dataraw = DataRaw('NDdata', data=data, dim='DataND', nav_indexes=[0],
⋮----
data = [np.sum(data, axis=(0, 1, 2))]
dataraw = DataRaw('NDdata', data=data, dim='DataND', nav_indexes=[],
⋮----
nav_indexes = data.nav_indexes
⋮----
#nav_axes = data.get_nav_axes()
⋮----
n_nav_axes = len(data.get_nav_axes())
⋮----
def update_filters(self, processor: DataProcessorFactory)
⋮----
def show_settings(self, show: bool = True)
⋮----
def prepare_ui(self)
⋮----
def setup_actions(self)
⋮----
def reshape_data(self)
⋮----
_nav_indexes = [int(index) for index in
⋮----
def connect_things(self)
⋮----
def setup_widgets(self)
⋮----
viewer0D_widget = QtWidgets.QWidget()
⋮----
viewer1D_widget = QtWidgets.QWidget()
⋮----
viewer2D_widget = QtWidgets.QWidget()
⋮----
navigator1D_widget = QtWidgets.QWidget()
⋮----
navigator2D_widget = QtWidgets.QWidget()
⋮----
nav_axes_widget = QtWidgets.QWidget()
⋮----
def update_data_dim(self, dim: str)
⋮----
def main()
⋮----
app = QtWidgets.QApplication(sys.argv)
widget = QtWidgets.QWidget()
prog = ViewerND(widget)
⋮----
def spread_main()
⋮----
param = np.linspace(1, 10, 10)
⋮----
# generating Npts of spread 2D data
N = 100
⋮----
x_axis_array = np.random.randint(-20, 50, size=N)
y_axis_array = np.random.randint(20, 40, size=N)
⋮----
x_axis = Axis('xaxis', 'm', data=x_axis_array, index=0, spread_order=0)
y_axis = Axis('yaxis', 'm', data=y_axis_array, index=0, spread_order=1)
param_axis = Axis('Param', 'eV', data=param, index=1)
⋮----
data_spread_1x2 = []
⋮----
data_list = []
⋮----
data_array = np.squeeze(np.array(data_list))
⋮----
data_spread_1x2 = np.array(data_spread_1x2).T
⋮----
data_2D_1x2_spread = DataRaw('data2DSpread', data=[data_spread_1x2],
</file>

<file path="src/pymodaq_gui/plotting/items/axis_scaled.py">
AXIS_POSITIONS = ['top', 'bottom', 'right', 'left']
⋮----
class AxisItem_Scaled(pg.AxisItem)
⋮----
"""
    Subclass of pg.AxisItem enabling scaling of the tick values with respect to the linked viewbox
    """
⋮----
def __init__(self, *args, scaling=1, offset=0, **kwargs)
⋮----
"""
        ==============  ===============================================================
        **Arguments:**
        orientation     one of 'left', 'right', 'top', or 'bottom'
        scaling         multiplicative coeff applied to the ticks
        offset          offset applied to the ticks after scaling
        maxTickLength   (px) maximum length of ticks to draw. Negative values draw
                        into the plot, positive values draw outward.
        linkView        (ViewBox) causes the range of values displayed in the axis
                        to be linked to the visible range of a ViewBox.
        showValues      (bool) Whether to display values adjacent to ticks
        pen             (QPen) Pen used when drawing ticks.
        ==============  ===============================================================
        """
⋮----
def axis_data(self, Npts)
⋮----
def set_scaling_and_label(self, axis_info: Axis)
⋮----
@property
    def axis_label(self)
⋮----
@axis_label.setter
    def axis_label(self, label: str)
⋮----
@property
    def axis_units(self)
⋮----
@axis_units.setter
    def axis_units(self, units: str)
⋮----
@property
    def axis_scaling(self)
⋮----
@axis_scaling.setter
    def axis_scaling(self, scaling_factor=1)
⋮----
@property
    def axis_offset(self)
⋮----
@axis_offset.setter
    def axis_offset(self, offset=0)
⋮----
def linkedViewChanged(self, view=None, newRange=None)
⋮----
view = self.linkedView()
⋮----
newRange = [pos * self._scaling + self._offset for pos in view.viewRange()[1]]
⋮----
newRange = [pos * self._scaling + self._offset for pos in newRange]
⋮----
newRange = [pos * self._scaling + self._offset for pos in view.viewRange()[0]]
</file>

<file path="src/pymodaq_gui/plotting/items/crosshair.py">
class Crosshair(pg.GraphicsObject)
⋮----
crosshair_dragged = Signal(float, float, name='crosshair_dragged')
# signal used to pass crosshair position to other methods
⋮----
def __init__(self, plotitem, orientation='both', pen=None)
⋮----
# in case one pass a plot or image widget
⋮----
# self.crosshair_dragged[float,float].connect(self.print_pos) #exemple on how to use the crosshair_dragged signal
⋮----
def show_hide_crosshair(self)
⋮----
def set_crosshair_position(self, xpos=0, ypos=0)
⋮----
def update_hline(self)
⋮----
p = self.vLine.getYPos() - self.vLine.cursorOffset[1]
⋮----
def get_positions(self)
⋮----
def update_vline(self)
⋮----
p = self.hLine.getXPos() - self.hLine.cursorOffset[0]
⋮----
def hide(self)
⋮----
def show(self)
⋮----
def value(self)
⋮----
"""
        value returns a tuple containing (x,y) positions of the crosshair
        """
⋮----
def setVisible(self, state)
⋮----
def isVisible(self)
</file>

<file path="src/pymodaq_gui/plotting/items/image.py">
class PymodaqImage(pg.ImageItem)
⋮----
def __init__(self, image=None, pen='r', **kargs)
⋮----
def get_val_at(self, xy)
⋮----
"""

        Parameters
        ----------
        xy: (tuple) containing x and y position of the point which you want the value

        Returns
        -------
        float: the value at the given position in the image
        """
⋮----
class UniformImageItem(PymodaqImage)
⋮----
def __init__(self, image=None, **kargs)
⋮----
# def setRect(self, rect):
#     """Scale and translate the image to fit within rect (must be a QRect or QRectF)."""
#     self.resetTransform()
#     self._dataTransform.translate(rect.left(), rect.top())
#     self._dataTransform.scale(rect.width() / self.width(), rect.height() / self.height())
⋮----
def setImage(self, image=None, autoLevels=None, levels_sym=False, **kargs)
⋮----
"""
        Updates the image displayed by this ImageItem. For more information on how the image
        is processed before displaying, see :func:`~pyqtgraph.makeARGB`.

        For backward compatibility, image data is assumed to be in column-major order (column, row) by default.
        However, most data is stored in row-major order (row, column). It can either be transposed before assignment::

            imageitem.setImage(imagedata.T)

        or the interpretation of the data can be changed locally through the ``axisOrder`` keyword or by changing the
        `imageAxisOrder` :ref:`global configuration option <apiref_config>`

        All keywords supported by :func:`~pyqtgraph.ImageItem.setOpts` are also allowed here.

        Parameters
        ----------
        image: np.ndarray, optional
            Image data given as NumPy array with an integer or floating
            point dtype of any bit depth. A 2-dimensional array describes single-valued (monochromatic) data.
            A 3-dimensional array is used to give individual color components. The third dimension must
            be of length 3 (RGB) or 4 (RGBA).
        rect: QRectF or QRect or array_like, optional
            If given, sets translation and scaling to display the image within the
            specified rectangle. If ``array_like`` should be the form of floats
            ``[x, y, w, h]`` See :func:`~pyqtgraph.ImageItem.setRect`
        autoLevels: bool, optional
            If `True`, ImageItem will automatically select levels based on the maximum and minimum values encountered
            in the data. For performance reasons, this search subsamples the images and may miss individual bright or
            or dark points in the data set.

            If `False`, the search will be omitted.

            The default is `False` if a ``levels`` keyword argument is given, and `True` otherwise.
        levelSamples: int, default 65536
            When determining minimum and maximum values, ImageItem
            only inspects a subset of pixels no larger than this number.
            Setting this larger than the total number of pixels considers all values.
        levels_sym: bool, optional
            if true and autolevels is True, will symetrize the levels from -abs(max(min_data, max_data) to abs(max(min_data, max_data)
        """
profile = debug.Profiler()
⋮----
gotNewData = False
⋮----
old_xp = self._xp
cp = getCupy()
⋮----
gotNewData = True
processingSubstrateChanged = old_xp != self._xp
⋮----
shapeChanged = (processingSubstrateChanged or self.image is None or image.shape != self.image.shape)
image = image.view()
⋮----
autoLevels = False
⋮----
autoLevels = True
⋮----
level_samples = kargs.pop('levelSamples', 2**16)
⋮----
# mn and mx can still be NaN if the data is all-NaN
⋮----
mn = 0
mx = 255
⋮----
levels = self._defferedLevels
⋮----
class SpreadImageItem(PymodaqImage)
⋮----
"""
    **Bases:** :class:`GraphicsObject <pyqtgraph.GraphicsObject>`

    GraphicsObject displaying an image. Optimized for rapid update (ie video display).
    This item displays either a 2D numpy array (height, width) or
    a 3D array (height, width, RGBa). This array is optionally scaled (see
    :func:`setLevels <pyqtgraph.ImageItem.setLevels>`) and/or colored
    with a lookup table (see :func:`setLookupTable <pyqtgraph.ImageItem.setLookupTable>`)
    before being displayed.

    ImageItem is frequently used in conjunction with
    :class:`HistogramLUTItem <pyqtgraph.HistogramLUTItem>` or
    :class:`HistogramLUTWidget <pyqtgraph.HistogramLUTWidget>` to provide a GUI
    for controlling the levels and lookup table used to display the image.
    """
⋮----
"""
        See :func:`setImage <pyqtgraph.ImageItem.setImage>` for all allowed initialization arguments.
        """
⋮----
def width(self)
⋮----
def height(self)
⋮----
def boundingRect(self)
⋮----
"""
        Update the image displayed by this item. For more information on how the image
        is processed before displaying, see :func:`makeARGB <pyqtgraph.makeARGB>`

        =================  =========================================================================
        **Arguments:**
        image             (numpy array) 2D array of: points coordinates (dim 0 is number of points)
                          (dim 1 is x, y coordinates and point value) image.shape = (N, 3)

                           Specifies the image data. May be 2D (width, height) or
                           3D (width, height, RGBa). The array dtype must be integer or floating
                           point of any bit depth. For 3D arrays, the third dimension must
                           be of length 3 (RGB) or 4 (RGBA). See *notes* below.

        autoLevels         (bool) If True, this forces the image to automatically select
                           levels based on the maximum and minimum values in the data.
                           By default, this argument is true unless the levels argument is
                           given.
        lut                (numpy array) The color lookup table to use when displaying the image.
                           See :func:`setLookupTable <pyqtgraph.ImageItem.setLookupTable>`.
        levels             (min, max) The minimum and maximum values to use when rescaling the image
                           data. By default, this will be set to the minimum and maximum values
                           in the image. If the image array has dtype uint8, no rescaling is necessary.
        levels_sym: bool, optional
            if true and autolevels is True, will symetrize the levels from -abs(max(min_data, max_data) to abs(max(min_data, max_data)
        opacity            (float 0.0-1.0)
        compositionMode    See :func:`setCompositionMode <pyqtgraph.ImageItem.setCompositionMode>`
        border             Sets the pen used when drawing the image border. Default is None.
        autoDownsample     (bool) If True, the image is automatically downsampled to match the
                           screen resolution. This improves performance for large images and
                           reduces aliasing.
        =================  =========================================================================


        **Notes:**

        For backward compatibility, image data is assumed to be in column-major order (column, row).
        However, most image data is stored in row-major order (row, column) and will need to be
        transposed before calling setImage()::

            imageitem.setImage(imagedata.T)

        This requirement can be changed by calling ``image.setOpts(axisOrder='row-major')`` or
        by changing the ``imageAxisOrder`` :ref:`global configuration option <apiref_config>`.


        """
⋮----
shapeChanged = (self.image is None or image.shape != self.image.shape)
image = image.view(np.ndarray)
⋮----
img = self.image
⋮----
img = img[::2, ...]
⋮----
"""

        Parameters
        ----------
        xy: (tuple) containing x and y position of the point which you want the value

        Returns
        -------
        flaot: the mean value of the three points surrounding the point
        """
triangle_ind = self.triangulation.find_simplex(xy)
val = np.mean(self.image[self.triangulation.simplices[triangle_ind]], axis=0)[2]
⋮----
def render(self)
⋮----
# Convert data to QImage for display.
⋮----
lut = self.lut(self.image)
⋮----
lut = self.lut
⋮----
# reduce dimensions of image based on screen resolution
o = self.mapToDevice(QtCore.QPointF(0, 0))
x = self.mapToDevice(QtCore.QPointF(1, 0))
y = self.mapToDevice(QtCore.QPointF(0, 1))
w = Point(x - o).length()
h = Point(y - o).length()
⋮----
xds = max(1, int(1.0 / w))
yds = max(1, int(1.0 / h))
axes = [1, 0] if self.axisOrder == 'row-major' else [0, 1]
# TODO adapt downsample
# image = fn.downsample(self.image, xds, axis=axes[0])
# image = fn.downsample(image, yds, axis=axes[1])
⋮----
image = self.image
⋮----
# if the image data is a small int, then we can combine levels + lut
# into a single lut for better performance
levels = self.levels
⋮----
# Assume images are in column-major order for backward compatibility
# (most images are in row-major order)
⋮----
polygons = makePolygons(self.triangulation)
⋮----
def get_points_at(self, axis='x', val=0)
⋮----
"""
        get all triangles values whose 'x' value is val or 'y' value is val
        1) compute triangle centroids
        2) set one of the coordinates as val
        3) check if this new point is still in the corresponding triangle
        4) if yes add point
        Parameters
        ----------
        axis: (str) either x or y if the set coordinates is x or y
        val: (float) the value of the x or y axis

        Returns
        -------
        ndarray: barycenter coordinates and triangles data values
        """
⋮----
centroids = self.compute_centroids()
points_to_test = centroids.copy()
⋮----
simplex = self.triangulation.find_simplex(points_to_test)
good_indexes = np.where(simplex == np.linspace(0, len(simplex) - 1, len(simplex), dtype=int))
⋮----
def compute_centroids(self)
⋮----
def dataTransform(self)
⋮----
"""Return the transform that maps from this image's input array to its
        local coordinate system.

        This transform corrects for the transposition that occurs when image data
        is interpreted in row-major order.
        """
# Might eventually need to account for downsampling / clipping here
tr = QtGui.QTransform()
⋮----
def setLookupTable(self, lut, update=True)
⋮----
lu = np.mean(self.lut(self.image), axis=0).astype(np.uint8)
⋮----
lu = list(lu)
⋮----
lu = [255, 255, 255]
⋮----
def paint(self, p, *args)
⋮----
def save(self, fileName, *args)
⋮----
"""Save this image to file. Note that this saves the visible image (after scale/color changes), not the original data."""
⋮----
def getHistogram(self, bins='auto', step='auto', targetImageSize=200, targetHistogramSize=500, **kwds)
⋮----
"""Returns x and y arrays containing the histogram values for the current image.
        For an explanation of the return format, see numpy.histogram().

        The *step* argument causes pixels to be skipped when computing the histogram to save time.
        If *step* is 'auto', then a step is chosen such that the analyzed data has
        dimensions roughly *targetImageSize* for each axis.

        The *bins* argument and any extra keyword arguments are passed to
        np.histogram(). If *bins* is 'auto', then a bin number is automatically
        chosen based on the image characteristics:

        * Integer images will have approximately *targetHistogramSize* bins,
          with each bin having an integer width.
        * All other types will have *targetHistogramSize* bins.

        This method is also used when automatically computing levels.
        """
⋮----
step = int(np.ceil(self.image.shape[0] / targetImageSize))
stepData = self.image[::step, 2:]
⋮----
mn = stepData.min()
mx = stepData.max()
step = np.ceil((mx - mn) / 500.)
bins = np.arange(mn, mx + 1.01 * step, step, dtype=np.int)
⋮----
bins = [mn, mx]
⋮----
bins = 500
⋮----
stepData = stepData[np.isfinite(stepData)]
hist = np.histogram(stepData, **kwds)
⋮----
def getPixmap(self)
</file>

<file path="src/pymodaq_gui/plotting/plotter/plotters/qt_plotters.py">
logger = set_logger(get_module_name(__file__))
config = configmod.Config()
⋮----
@PlotterFactory.register()
class Plotter(PlotterBase)
⋮----
backend = 'qt'
⋮----
def __init__(self, **_ignored)
⋮----
def plot(self, data: Union[DataWithAxes, DataToExport], viewer=None, **kwargs) -> ViewerBase
⋮----
"""

        Parameters
        ----------
        data
        viewer
        kwargs

        Returns
        -------

        """
do_exit = False
qapp = QtWidgets.QApplication.instance()
⋮----
do_exit = True
qapp = start_qapplication()
⋮----
widget = DockArea()
viewer = ViewerDispatcher(widget, title=data.name)
⋮----
widget = QtWidgets.QWidget()
viewer_enum = ViewersEnum.get_viewers_enum_from_data(data)
viewer = viewer_factory.get(viewer_enum.name, parent=widget)
⋮----
plotter_factory = PlotterFactory()
⋮----
x = np.random.randint(201, size=201)
y1 = gauss1D(x, 75, 25)
y2 = gauss1D(x, 120, 50, 2)
⋮----
dwa = data_mod.DataRaw('mydata', data=[y1, y2],
</file>

<file path="src/pymodaq_gui/plotting/utils/axes_viewer.py">
# -*- coding: utf-8 -*-
"""
Created the 26/01/2023

@author: Sebastien Weber
"""
⋮----
class AxesViewer(QtCore.QObject)
⋮----
navigation_changed = QtCore.Signal()
⋮----
def __init__(self, parent_widget: QtWidgets.QWidget)
⋮----
def clear_viewers(self)
⋮----
viewer = self.nav_axes_viewers.pop(0)
⋮----
def add_viewers(self, nviewers: int)
⋮----
widgets = []
⋮----
def set_nav_viewers(self, axes: List[Axis])
⋮----
def _emit_nav_signal(self)
⋮----
def get_crosshairs(self)
⋮----
def get_indexes(self)
⋮----
def setVisible(self, show=True)
⋮----
"""convenience method to show or hide the paretn widget"""
⋮----
app = QtWidgets.QApplication(sys.argv)
⋮----
widget = QtWidgets.QWidget()
prog = AxesViewer(widget)
⋮----
labels = ['']
N = 2
axes = [Axis(label=f'Axis{ind:02d}', units='s', data=np.random.rand(50)) for ind in range(N)]
⋮----
def print_positions()
</file>

<file path="src/pymodaq_gui/plotting/utils/filter.py">
logger = set_logger(get_module_name(__file__))
⋮----
data_processors = DataProcessorFactory()
⋮----
class Filter
⋮----
def __init__(self)
⋮----
def register_activation_signal(self, activation_signal)
⋮----
def register_target_slot(self, slot)
⋮----
@Slot(bool)
    def set_active(self, activate=True)
⋮----
def filter_data(self, data: data_mod.DataRaw)
⋮----
filtered_data = self._filter_data(data)
⋮----
def _filter_data(self, data: data_mod.DataRaw) -> DataToExport
⋮----
class Filter1DFromCrosshair(Filter)
⋮----
def __init__(self, crosshair: Crosshair)
⋮----
"""
        Extract data along a crosshair using coordinates and data displayed in graph_items such as  imageItems
        Parameters
        ----------
        crosshair : Crosshair
        """
⋮----
def update_axis(self, axis: data_mod.Axis)
⋮----
dte = DataToExport('Crosshair')
⋮----
axis = data.get_axis_from_index(0, create=False)[0]
⋮----
dwa = data.isig[data.axes[0].find_indexes([self._x])[0]]
⋮----
# for label, dat in zip(data.labels, data.data):
# dte.append(DataFromRoi('crosshair', data=[np.array([dat[ind_x]]) for dat in data.data],
#                        axes=[Axis(data=np.array([self._axis.get_data()[ind_x]]))],
#                        labels=data.labels))
⋮----
class Filter2DFromCrosshair(Filter)
⋮----
def __init__(self, crosshair: Crosshair, graph_items, image_keys)
⋮----
"""
        Extract data along a crosshair using coordinates and data displayed in graph_items such as  imageItems
        Parameters
        ----------
        crosshair : (Crosshair)
        graph_items : (dict)
        image_keys : (list) list of string identifier to link datas to their graph_items. This means that in
            _filter_data, datas['data'][key] is plotted on graph_items[key] for key in image_keys
        """
⋮----
def set_graph_items(self, graph_items)
⋮----
def _filter_data(self, dwa: data_mod.DataRaw) -> DataToExport
⋮----
data_type = dwa.distribution
⋮----
dte = self.get_data_from_uniform(dwa)
⋮----
dte = self.get_data_from_spread(dwa)
⋮----
def get_data_from_uniform(self, dwa: DataWithAxes) -> DataToExport
⋮----
data_H_index = slice(None, None, 1)
data_V_index = slice(None, None, 1)
H_indexes = (utils.rint(indy), data_H_index)
V_indexes = (data_V_index, utils.rint(indx))
⋮----
dwa_hor = dwa.isig[H_indexes]
⋮----
dwa_ver = dwa.isig[V_indexes]
⋮----
dwa_int = dwa.isig[utils.rint(indy), utils.rint(indx)]
⋮----
def get_data_from_spread(self, dwa: DataWithAxes) -> DataToExport
⋮----
hor_data = []
ver_data = []
int_data = []
hor_axis = None
ver_axis = None
⋮----
x_sorted_indexes = np.argsort(points[:, 0])
hor_axis = points[x_sorted_indexes, 0][data_H_index]
⋮----
y_sorted_indexes = np.argsort(points[:, 1])
ver_axis = points[y_sorted_indexes, 1][data_V_index]
⋮----
def mapfromview(self, x, y, item_key='red')
⋮----
"""
        get item coordinates from view coordinates
        Parameters
        ----------
        x: (float) x coordinate in the view reference frame
        y: (float) y coordinate in the view refernece frame

        Returns
        -------
        x: (float) coordinate in the item reference frame
        y: (float) coordinate in the item reference frame
        """
point = self._graph_items[item_key].mapFromView(QPointF(x, y))
⋮----
class Filter1DFromRois(Filter)
⋮----
"""

    Parameters
    ----------
    roi_manager:ROIManager
    graph_item: PlotItems
    """
def __init__(self, roi_manager: ROIManager)
⋮----
dte = DataToExport('roi1D')
⋮----
data_index = list(range(len(data.labels)))
⋮----
data_index = [data.labels.index(self._roi_settings['ROIs', roi_key,
⋮----
data_index = [0]
dte_tmp = self.get_data_from_roi(roi, self._roi_settings.child('ROIs', roi_key),
⋮----
def get_data_from_roi(self, roi: LinearROI,  roi_param: Parameter, data: data_mod.DataWithAxes) -> DataToExport
⋮----
dte = DataToExport('ROI1D')
_slice = self.get_slice_from_roi(roi, data)
sub_data: DataFromRoi = data.isig[_slice]
⋮----
processed_data = data_processors.get(roi_param['math_function']).process(sub_data)
⋮----
processed_data = None
⋮----
def get_slice_from_roi(self, roi: RectROI, data: data_mod.DataWithAxes) -> slice
⋮----
size = data.get_axis_from_index(0)[0].size
ind_x_min = int(min(max(ind_x_min, 0), size))
ind_x_max = int(max(0, min(ind_x_max, size)))
⋮----
class Filter2DFromRois(Filter)
⋮----
"""Filters 2D data using 2D ROIs

    Parameters
    ----------
    roi_manager: ROIManager
    graph_item: UniformImageItem or SpreadImageItem
        The graphical item where data and ROIs are plotted
    image_keys : (list) list of string identifier to link datas to their graph_items. This means that in
        _filter_data, datas.data[key] is plotted on graph_items[key] for key in image_keys
    """
def __init__(self, roi_manager: ROIManager, graph_item: UniformImageItem, image_keys)
⋮----
dte = DataToExport('ROI')
⋮----
labels = []
⋮----
label = self._roi_settings['ROIs', roi_key, 'use_channel']
⋮----
sub_data = dwa.deepcopy()
⋮----
sub_data = dwa
dte_temp = self.get_xydata_from_roi(roi, sub_data,
⋮----
def get_slices_from_roi(self, roi: RectROI, data_shape: tuple) -> Tuple[slice, slice]
⋮----
ind_x_min = int(min(max(x, 0), size_x))
ind_y_min = int(min(max(y, 0), size_y))
ind_x_max = int(max(0, min(x+width, size_x)))
ind_y_max = int(max(0, min(y+height, size_y)))
⋮----
def get_xydata_from_roi(self, roi: RectROI, dwa: DataWithAxes, math_function: str) -> DataToExport
⋮----
dte = DataToExport(roi.name)
⋮----
labels = [f'{roi.name}/{label}' for label in dwa.labels]
⋮----
ind_xaxis = np.argsort(xvals)
ind_yaxis = np.argsort(yvals)
xvals = xvals[ind_xaxis]
yvals = yvals[ind_yaxis]
data_H = data[ind_xaxis]
data_V = data[ind_yaxis]
int_data = np.array([np.mean(data)])
⋮----
_x_axis = dwa.get_axis_from_index_spread(0, 0)
x_axis = Axis(_x_axis.label, _x_axis.units, data=xvals, index=0, spread_order=0)
_y_axis = dwa.get_axis_from_index_spread(0, 1)
y_axis = Axis(_y_axis.label, _y_axis.units, data=yvals, index=0, spread_order=0)
sub_data_hor = DataFromRoi('hor', distribution='spread', data=[data_H], axes=[x_axis],)
sub_data_ver = DataFromRoi('ver', distribution='spread', data=[data_V], axes=[y_axis])
math_data = DataFromRoi('int', data=int_data)
⋮----
slices = self.get_slices_from_roi(roi, dwa.shape)
sub_data: DataFromRoi = dwa.isig[slices[0], slices[1]]
sub_data_hor = sub_data.mean(0)
sub_data_ver = sub_data.mean(1)
math_data = data_processors.get(math_function).process(sub_data)
⋮----
#TODO possibly not used anymore to be deleted
#
# def get_xydata(self, data: np.ndarray, roi: RectROI):
#     data, coords = self.data_from_roi(data, roi)
⋮----
#     if data is not None:
#         xvals = np.linspace(np.min(np.min(coords[1, :, :])), np.max(np.max(coords[1, :, :])),
#                             data.shape[1])
#         yvals = np.linspace(np.min(np.min(coords[0, :, :])), np.max(np.max(coords[0, :, :])),
#                             data.shape[0])
#     else:
#         xvals = yvals = data = np.array([])
#     return xvals, yvals, data
⋮----
# def data_from_roi(self, data, roi):
#     data, coords = roi.getArrayRegion(data, self._graph_item, self.axes, returnMappedCoords=True)
#     return data, coords
⋮----
def get_xydata_spread(self, data, roi)
⋮----
xvals = []
yvals = []
data_out = []
⋮----
# invoke the QPainterpath of the ROI (from the shape method)
⋮----
data_out = np.array(data_out)
xvals = np.array(xvals)
yvals = np.array(yvals)
⋮----
class FourierFilterer(QObject)
⋮----
filter_changed = Signal(dict)
⋮----
def __init__(self, parent=None)
⋮----
parent = QtWidgets.QWidget()
⋮----
def setUI(self)
⋮----
form = QtWidgets.QWidget()
⋮----
icon = QtGui.QIcon()
⋮----
vbox = self.viewer1D.parent.layout()
widg = QtWidgets.QWidget()
hbox = QtWidgets.QHBoxLayout()
⋮----
def calculate_fft(self)
⋮----
def show_data(self, data)
⋮----
"""
        show data and fft
        Parameters
        ----------
        data: (dict) with keys 'data', optionally 'xaxis' and 'yaxis'
        """
⋮----
# self.viewer1D.ROI.setRegion((np.min(self.xaxis), np.max(self.xaxis)))
⋮----
def set_data(self)
⋮----
xlimits = self.viewer1D.ROI.getRegion()
indexes = mutils.find_index(self.raw_data['xaxis'], xlimits)
⋮----
def update_filter(self)
⋮----
index = np.argmax(self.filter * self.data_fft)
⋮----
def update_plot(self)
⋮----
app = QtWidgets.QApplication(sys.argv)
prog = FourierFilterer()
⋮----
xdata = np.linspace(0, 400, 401)
x0 = 50
dx = 20
tau = 27
tau2 = 100
ydata_gauss = 10 * gauss1D(xdata, x0, dx) + np.random.rand(len(xdata))
ydata_expodec = np.zeros((len(xdata)))
⋮----
ydata_expodec[50:] = 10 * np.exp(-(xdata[50:] - x0) / tau)  # +10*np.exp(-(xdata[50:]-x0)/tau2)
⋮----
ydata_sin = 10 + 2 * np.sin(2 * np.pi * 0.1 * xdata - np.deg2rad(55)) + np.sin(
</file>

<file path="src/pymodaq_gui/plotting/utils/lineout.py">
# -*- coding: utf-8 -*-
"""
Created the 03/11/2022

@author: Sebastien Weber
"""
⋮----
logger = set_logger(get_module_name(__file__))
IMAGE_TYPES = ['red', 'green', 'blue']
COLOR_LIST = list(utils.plot_colors)
COLORS_DICT = dict(red=(255, 0, 0), green=(0, 255, 0), blue=(0, 0, 255), spread=(128, 128, 128))
⋮----
def curve_item_factory(pen='red')
⋮----
"""
    Create a PlotCurveItem with the given pen
    Parameters
    ----------
    pen: any type of arguments accepted by pyqtgraph.function.mkColor or one of the COLORS_DICT key

    Returns
    -------
    PlotCurveItem
    """
⋮----
pen = COLORS_DICT[pen]
⋮----
class LineoutPlotter(QObject)
⋮----
"""Base class to manage and display data filtered out into lineouts (1D, 0D)

    Should be inherited and subclass some methods as appropriate

    Parameters
    ----------
    graph_widgets: OrderedDict
        Includes plotwidgets to display data
    roi_manager:
        The ROIManager to create ROIs and manage their properties
    crosshair:
        The Crosshair object
    """
⋮----
roi_changed = Signal(dict)
crosshair_lineout_plotted = Signal(dict)
roi_lineout_plotted = Signal(dict)
⋮----
lineout_widgets = ['int']  # should be reimplemented see viewer2D
⋮----
def __init__(self, graph_widgets: OrderedDict, roi_manager: ROIManager, crosshair: Crosshair)
⋮----
def plot_roi_lineouts(self, roi_dicts)
⋮----
# for roi_key, lineout_data in roi_dicts.items():
#     if roi_key in self._roi_curves:
#         self._roi_curves[roi_key]['int'].setData(self.integrated_data.xaxis,
#                                                  self.integrated_data.datas[roi_key])
# self.plot_other_lineouts(roi_dicts)
#
# logger.debug('roi lineouts plotted')
# self.roi_lineout_plotted.emit(roi_dicts)
⋮----
def plot_other_lineouts(self, roi_dicts)
⋮----
def plot_crosshair_lineouts(self, crosshair_dict)
⋮----
def plot_other_crosshair_lineouts(self, crosshair_dict)
⋮----
def get_lineout_widget(self, name)
⋮----
@Slot(str, tuple)
    def update_roi(self, roi_key, param_changed)
⋮----
@Slot(str)
    def remove_ROI(self, roi_name)
⋮----
index = int(roi_name.split('_')[1])
⋮----
@Slot(int, str)
    def add_ROI(self, newindex, roi_type)
⋮----
item = self._roi_manager.get_roi_from_index(newindex)
⋮----
item_param = self._roi_manager.settings.child('ROIs', 'ROI_{:02d}'.format(newindex))
color = item_param.child('Color').value()
⋮----
#self.add_roi_lineout_items(newindex, color)
⋮----
def add_roi_lineout_items(self, index, pen)
⋮----
"""
        Add specifics lineouts generated from ROIs
        Parameters
        ----------
        index: (int) index of the ROI generating these lineouts
        pen: (str, tuple) any argument able to generate a QPen, see pyqtgraph.functions.mkPen
        """
⋮----
def remove_roi_lineout_items(self, index)
⋮----
"""
        Remove specifics lineouts generated from ROI referenced by a unique integer
        Parameters
        ----------
        index: (int) index of the ROI generating these lineouts
        """
items = self._roi_curves.pop(f'ROI_{index:02d}')
⋮----
def add_lineout_items(self, *curve_items)
⋮----
"""
        Add Curve items sequentially to lineouts widgets: (hor, ver and int)
        Parameters
        ----------
        curve_items: (PlotCurveItem) at most 3 of them
        """
⋮----
def remove_lineout_items(self, *curve_items)
⋮----
"""
        Remove Curve items sequentially to lineouts widgets: (hor, ver and int)
        Parameters
        ----------
        curve_items: (PlotCurveItem) at most 3 of them
        """
⋮----
@Slot(bool)
    def roi_clicked(self, isroichecked=True)
⋮----
@Slot(bool)
    def crosshair_clicked(self, iscrosshairchecked=True)
⋮----
def get_roi_curves_triplet(self)
⋮----
"""
        Get the dictionary (one key by ROI) containing dicts with ROI PlotCurveItem

        Example:
        --------
        >>> roi_dict_triplet = self.get_roi_cruves_triplet()
        >>> hor_curve = roi_dict_triplet['ROI_00']['hor']  # where 'hor' is an entry of self.lineout_widgets
        """
⋮----
def get_crosshair_curves_triplet(self)
⋮----
"""
        Get the dictionary (one key by ImageItem, see IMAGE_TYPES) containing dicts with PlotCurveItem

        Example:
        --------
        >>> crosshair_dict_triplet = self.get_crosshair_curves_triplet()
        >>> hor_curve = crosshair_dict_triplet['blue']['hor']  # where 'hor' is an entry of self.lineout_widgets
        """
⋮----
def get_crosshair_curve_triplet(self, curve_name)
⋮----
def setup_crosshair(self)
⋮----
"""to reimplement if needed"""
⋮----
def show_crosshair_curves(self, curve_key, show=True)
</file>

<file path="src/pymodaq_gui/plotting/utils/plot_utils.py">
def make_dashed_pens(color: tuple, nstyle=3)
⋮----
pens = [dict(color=color)]
⋮----
class Point
⋮----
def __init__(self, *elt: IterableType[float])
⋮----
"""Initialize a geometric point in an arbitrary number of dimensions

        Parameters
        ----------
        elt: either a tuple of floats, passed as multiple parameters or a single Iterable parameter
        """
⋮----
elt = elt[0]
⋮----
@property
    def coordinates(self)
⋮----
def copy(self)
⋮----
def __getitem__(self, item: int) -> float
⋮----
def __setitem__(self, key: int, value: float)
⋮----
def __len__(self)
⋮----
def _compare_length(self, other: 'Point')
⋮----
def __eq__(self, other)
⋮----
def __add__(self, other: Union['Point', 'Vector'])
⋮----
def __sub__(self, other: 'Point')
⋮----
def __repr__(self)
⋮----
class Vector
⋮----
def __init__(self, coordinates: Union[Point, np.ndarray], origin: Point = None)
⋮----
origin = np.zeros((len(coordinates)))
⋮----
@property
    def origin(self)
⋮----
def norm(self)
⋮----
def unit_vector(self)
⋮----
def __add__(self, other: 'Vector')
⋮----
def __sub__(self, other: 'Vector')
⋮----
def __mul__(self, other: Number)
⋮----
def dot(self, other: 'Vector')
⋮----
def cross(self, other: 'Vector')
⋮----
def get_sub_segmented_positions(spacing: float, points: List[Point]) -> List[np.ndarray]
⋮----
"""Get Points coordinates spaced in between subsequent Points

    Parameters
    ----------
    spacing: float
        Distance between two subpoints
    points: List[Point]
        List of Points in arbitrary dimension forming segments one want to sample with a distance equal to spacing

    Returns
    -------
    List[np.ndarray]: The list of the coordinates of the points
    """
positions = []
⋮----
vect = Vector(points[ind+1]-points[ind], origin=points[ind])
npts = 0
⋮----
# # add_last point not taken into account
⋮----
class QVector(QtCore.QLineF)
⋮----
def __init__(self, *elt)
⋮----
def __add__(self, qvect)
⋮----
v = QVector(self.x1() + qvect.x1(), self.y1() + qvect.y1(), self.x2() + qvect.x2(), self.y2() + qvect.y2())
⋮----
def __sub__(self, qvect)
⋮----
v = QVector(self.x1() - qvect.x1(), self.y1() - qvect.y1(), self.x2() - qvect.x2(), self.y2() - qvect.y2())
⋮----
def __mul__(self, coeff=float(1))
⋮----
v = QVector(coeff * self.x1(), coeff * self.y1(), coeff * self.x2(), coeff * self.y2())
⋮----
vec = QVector()
⋮----
def vectorize(self)
⋮----
v = QVector(QtCore.QPointF(0, 0), self.p2() - self.p1())
⋮----
def unitVector(self)
⋮----
vec = self * (1 / self.length())
⋮----
def normalVector(self)
⋮----
vec = self.vectorize()
vec = QVector(0, 0, -vec.p2().y(), vec.p2().x())
⋮----
def normalVector_not_vectorized(self)
⋮----
def dot(self, qvect)
⋮----
"""
        scalar product
        """
v1 = self.vectorize()
v2 = qvect.vectorize()
prod = v1.x2() * v2.x2() + v1.y2() * v2.y2()
⋮----
def prod(self, qvect)
⋮----
"""
        vectoriel product length along z
        """
⋮----
prod = v1.x2() * v2.y2() - v1.y2() * v2.x2()
⋮----
def translate_to(self, point=QtCore.QPointF(0, 0))
⋮----
vec = self + QVector(self.p1(), point)
⋮----
def makeAlphaTriangles(data, lut=None, levels=None, scale=None, useRGBA=False)
⋮----
"""
    Convert an array of values into an ARGB array suitable for building QImages,
    OpenGL textures, etc.

    Returns the ARGB array (unsigned byte) and a boolean indicating whether
    there is alpha channel data. This is a two stage process:
        0) compute the polygons (triangles) from triangulation of the points
        1) Rescale the data based on the values in the *levels* argument (min, max).
        2) Determine the final output by passing the rescaled values through a
           lookup table.

    Both stages are optional.

    ============== ==================================================================================
    **Arguments:**
    data           numpy array of int/float types. If
    levels         List [min, max]; optionally rescale data before converting through the
                   lookup table. The data is rescaled such that min->0 and max->*scale*::

                      rescaled = (clip(data, min, max) - min) * (*scale* / (max - min))

                   It is also possible to use a 2D (N,2) array of values for levels. In this case,
                   it is assumed that each pair of min,max values in the levels array should be
                   applied to a different subset of the input data (for example, the input data may
                   already have RGB values and the levels are used to independently scale each
                   channel). The use of this feature requires that levels.shape[0] == data.shape[-1].
    scale          The maximum value to which data will be rescaled before being passed through the
                   lookup table (or returned if there is no lookup table). By default this will
                   be set to the length of the lookup table, or 255 if no lookup table is provided.
    lut            Optional lookup table (array with dtype=ubyte).
                   Values in data will be converted to color by indexing directly from lut.
                   The output data shape will be input.shape + lut.shape[1:].
                   Lookup tables can be built using ColorMap or GradientWidget.
    useRGBA        If True, the data is returned in RGBA order (useful for building OpenGL textures).
                   The default is False, which returns in ARGB order for use with QImage
                   (Note that 'ARGB' is a term used by the Qt documentation; the *actual* order
                   is BGRA).
    ============== ==================================================================================
    """
points = data[:, :2]
values = data[:, 2]
⋮----
profile = pg.debug.Profiler()
⋮----
tri = Triangulation(points)
tri_data = np.zeros((len(tri.simplices),))
⋮----
data = tri_data.copy()
⋮----
lut = np.array(lut)
⋮----
# automatically decide levels based on data dtype
⋮----
levels = np.array([0, 2 ** (data.itemsize * 8) - 1])
⋮----
s = 2 ** (data.itemsize * 8 - 1)
levels = np.array([-s, s - 1])
⋮----
levels = np.array([0, 1])
⋮----
levels = np.array(levels)
⋮----
# Decide on maximum scaled value
⋮----
scale = lut.shape[0] - 1
⋮----
scale = 255.
⋮----
# Decide on the dtype we want after scaling
⋮----
dtype = np.ubyte
⋮----
dtype = np.min_scalar_type(lut.shape[0] - 1)
⋮----
# Apply levels if given
⋮----
# we are going to rescale each channel independently
⋮----
newData = np.empty(data.shape, dtype=int)
⋮----
data = newData
⋮----
# Apply level scaling unless it would have no effect on the data
⋮----
data = pg.functions.rescaleData(data, scale / (maxVal - minVal), minVal, dtype=dtype)
⋮----
# apply LUT if given
⋮----
data = pg.functions.applyLookupTable(data, lut)
⋮----
data = np.clip(data, 0, 255).astype(np.ubyte)
⋮----
# this will be the final image array
imgData = np.empty((data.shape[0],) + (4,), dtype=np.ubyte)
⋮----
# decide channel order
⋮----
order = [0, 1, 2, 3]  # array comes out RGBA
⋮----
order = [2, 1, 0, 3]  # for some reason, the colors line up as BGR in the final image.
⋮----
# TODO check this
# copy data into image array
⋮----
# This is tempting:
#   imgData[..., :3] = data[..., np.newaxis]
# ..but it turns out this is faster:
⋮----
# add opaque alpha channel if needed
⋮----
alpha = False
⋮----
alpha = True
⋮----
def makePolygons(tri)
⋮----
polygons = []
⋮----
class Data0DWithHistory
⋮----
"""Object to store scalar values and keep a history of a given length to them"""
def __init__(self, Nsamples=200)
⋮----
@property
    def size(self)
⋮----
@property
    def length(self)
⋮----
@length.setter
    def length(self, history_length: int)
⋮----
@dispatch(data_mod.DataWithAxes)
    def add_datas(self, data: data_mod.DataWithAxes)
⋮----
datas = {data.labels[ind]: data.data[ind] for ind in range(len(data))}
⋮----
@dispatch(list)
    def add_datas(self, data: list)
⋮----
"""
        Add datas to the history
        Parameters
        ----------
        data: (list) list of floats or np.array(float)
        """
⋮----
datas = {f'data_{ind:02d}': data[ind] for ind in range(len(data))}
⋮----
@dispatch(dict)
    def add_datas(self, datas: dict)
⋮----
"""
        Add datas to the history on the form of a dict of key/data pairs (data is a numpy 0D array)
        Parameters
        ----------
        datas: (dict) dictionaary of floats or np.array(float)
        """
⋮----
data = np.array([data])
⋮----
@property
    def datas(self)
⋮----
@property
    def xaxis(self)
⋮----
def clear_data(self)
⋮----
class View_cust(pg.ViewBox)
⋮----
"""Custom ViewBox used to enable other properties compared to parent class: pg.ViewBox

    """
sig_double_clicked = QtCore.Signal(float, float)
⋮----
def mouseClickEvent(self, ev)
⋮----
pos = self.mapToView(ev.pos())
⋮----
@dataclass
class RoiInfo
⋮----
""" DataClass holding info about a given ROI

    Parameters
    ----------
    origin
    size
    angle
    centered
    color
    roi_class
    index
    """
⋮----
origin: Union[Point, IterableType[float]]
size: Union[Point, IterableType[float]]
angle: float = None
centered: bool = False
color: Tuple[int, int, int] = (255, 0, 0)
roi_class: type = None
index: int = 0
⋮----
@classmethod
    def info_from_linear_roi(cls, roi: LinearROI)
⋮----
pos = roi.pos()
⋮----
@classmethod
    def info_from_rect_roi(cls, roi: RectROI)
⋮----
def center_origin(self)
⋮----
def to_slices(self) -> IterableType[slice]
⋮----
"""Get slices to be used directly to slice DataWithAxes"""
</file>

<file path="src/pymodaq_gui/plotting/gant_chart.py">
pos = []
colors = []
⋮----
cmap = pg.ColorMap(pos, colors, Gradients['thermal']['mode'])
⋮----
def setTicksLabels(values)
⋮----
strings = []
⋮----
d = QDateTime()
d = d.fromSecsSinceEpoch(v * 30 * 60)
vstr = d.toString('HH:mm dd/MM/yy')
⋮----
class AxisItemDate(pg.AxisItem)
⋮----
def __init__(self, *args, **kwargs)
⋮----
def tickStrings(self, values, scale, spacing)
⋮----
places = max(0, np.ceil(-np.log10(spacing * scale)))
strings = setTicksLabels(values)
⋮----
class GanttROI(ROIBrushable)
⋮----
index_signal = Signal(int)
⋮----
def __init__(self, task='No task', index=0, start=0, stop=1, brush=None, *args, **kwargs)
⋮----
translateSnap=True, *args, **kwargs)  # )
⋮----
def update_tooltip(self)
⋮----
def center(self)
⋮----
def emit_index_signal(self)
⋮----
class GanttTask(QObject)
⋮----
alpha = 255
⋮----
def __init__(self, task_dict)
⋮----
self.task_dict = task_dict  # taskdict=dict(name=  ,idnumber=  ,task_type=int(0 to 12), time_start=, time_end=)
qc = cmap.mapToQColor(task_dict['task_type'] / 12)
⋮----
def show_hide_move_text(self)
⋮----
class GanttChart(QObject)
⋮----
def __init__(self)
⋮----
def setupUI(self)
⋮----
axis = AxisItemDate(orientation='bottom')
axis_top = AxisItemDate(orientation='top')
⋮----
def add_task(self, task_dict)
⋮----
# # create GUI
⋮----
app = QtWidgets.QApplication(sys.argv)
gchart = GanttChart()
</file>

<file path="src/pymodaq_gui/plotting/image_viewer.py">
class Image_Viewer(QtWidgets.QGraphicsView)
⋮----
def __init__(self, parent)
⋮----
def fitInView(self)
⋮----
rect = QtCore.QRectF(self._image.pixmap().rect())
⋮----
unity = self.transform().mapRect(QtCore.QRectF(0, 0, 1, 1))
⋮----
viewrect = self.viewport().rect()
scenerect = self.transform().mapRect(rect)
factor = min(viewrect.width() / scenerect.width(),
⋮----
def setPhoto(self, pixmap=None)
⋮----
# self.fitInView()
⋮----
def zoomFactor(self)
⋮----
def wheelEvent(self, event)
⋮----
# delta=QtCore.QPoint()
# delta.y
⋮----
factor = 1.25
⋮----
factor = 0.8
⋮----
class Window(QtWidgets.QWidget)
⋮----
def __init__(self)
⋮----
layout = QtWidgets.QGridLayout(self)
⋮----
def handleOpen(self)
⋮----
path = QtWidgets.QFileDialog.getOpenFileName(
path = path[0]
⋮----
app = QtWidgets.QApplication(sys.argv)
window = Window()
</file>

<file path="src/pymodaq_gui/plotting/navigator.py">
local_path = get_set_local_dir(user=True)
# navigator_path = local_path.joinpath('navigator_temp_files')
# if not navigator_path.is_dir():
#     navigator_path.mkdir()
⋮----
logger = set_logger(get_module_name(__file__))
⋮----
Ntick = 128
colors_red = np.array([(int(r), 0, 0) for r in np.linspace(0, 255, Ntick)])
colors_green = np.array([(0, int(g), 0) for g in np.linspace(0, 255, Ntick)])
colors_blue = np.array([(0, 0, int(b)) for b in np.linspace(0, 255, Ntick)])
config = Config()
⋮----
class Navigator(ParameterManager, ActionManager, QObject)
⋮----
settings_name = 'navigator_settings'
log_signal = Signal(str)
sig_double_clicked = Signal(float, float)
params = [
⋮----
def __init__(self, parent=None, h5file_path=None)
⋮----
parent = QtWidgets.QWidget()
⋮----
self.overlays = []  # %list of imageItem items displaying 2D scans info
⋮----
# self.h5module = H5BrowserUtil()
⋮----
# self.show_overlay()
⋮----
@property
    def h5saver(self)
⋮----
@h5saver.setter
    def h5saver(self, h5saver: H5Saver)
⋮----
def setup_actions(self)
⋮----
def connect_things(self)
⋮----
@Slot(float, float)
    def move_at(self, posx, posy)
⋮----
def show_histo(self)
⋮----
def show_all(self)
⋮----
def show_none(self)
⋮----
def show_scans(self, show=True)
⋮----
val = child.value()
⋮----
def get_data_from_scan_name(self, scan_name: str) -> DataToExport
⋮----
_data = DataToExport('All')
⋮----
data_2D = _data.get_data_from_Naxes(2)
for dat in data_2D:  # convert DataWithAxes DataND to Data2D
⋮----
def set_axes(self, dwa: DataWithAxes)
⋮----
x_axis = dwa.get_axis_from_index(0)[0]
y_axis = dwa.get_axis_from_index(1)[0]
⋮----
def list_2D_scans(self)
⋮----
scans = self.h5saver.get_scan_groups()
⋮----
params = []
⋮----
ind_overlay = 0
axes_init = False
⋮----
data_2D = self.get_data_from_scan_name(scan.name)
⋮----
axes_init = True
⋮----
def load_image(self)
⋮----
def load_data(self)
⋮----
def set_aspect_ratio(self)
⋮----
def add_image_data(self, dwa: DataWithAxes)
⋮----
ims = []
histograms = self.viewer.histograms
⋮----
im = SpreadImageItem()
⋮----
im = UniformImageItem()
⋮----
x_axis = dwa.get_axis_from_index(1)[0].get_data()
y_axis = dwa.get_axis_from_index(0)[0].get_data()
⋮----
rect = QtCore.QRectF(np.min(y_axis), np.min(x_axis),
⋮----
def remove_image_data(self, param)
⋮----
ind = self.overlays.index(overlay)
⋮----
def value_changed(self, param)
⋮----
data: PixmapCheckData = param.value()
⋮----
dwa = self.dataloader.load_data(data.path, load_all=True)
ims = self.add_image_data(dwa)
⋮----
dataloader = DataLoader(self.h5saver_image)
dwa = dataloader.load_data(data.path)
⋮----
def param_deleted(self, param)
⋮----
def setup_ui(self)
⋮----
layout = QtWidgets.QVBoxLayout()
⋮----
sett_widget = QtWidgets.QWidget()
⋮----
splitter = QtWidgets.QSplitter(Qt.Horizontal)
⋮----
# set viewer area
widg = QtWidgets.QWidget()
⋮----
def update_h5file(self, h5file)
⋮----
def update_status(self, txt, status_time=0, log_type=None)
⋮----
"""
            Show the txt message in the status bar with a delay of status_time ms.

            =============== =========== =======================
            **Parameters**    **Type**    **Description**
            *txt*             string      The message to show
            *status_time*       int         the delay of showing
            *log_type*        string      the type of the log
            =============== =========== =======================
        """
</file>

<file path="src/pymodaq_gui/plotting/widgets.py">
# -*- coding: utf-8 -*-
"""
Created the 04/11/2022

@author: Sebastien Weber
"""
⋮----
class ImageWidget(pg.GraphicsLayoutWidget)
⋮----
"""this gives a layout to add imageitems.
    """
⋮----
def __init__(self, parent=None, *args_plotitem, **kwargs_plotitem)
⋮----
def setAspectLocked(self, lock=True, ratio=1)
⋮----
"""
        Defines the aspect ratio of the view
        Parameters
        ----------
        lock: (bool) if True aspect ratio is set to ratio, else the aspect ratio is varying when scaling the view
        ratio: (int) aspect ratio between horizontal and vertical axis
        """
⋮----
def getAxis(self, position)
⋮----
def setupUI(self, *args_plotitem, **kwargs_plotitem)
⋮----
layout = QtWidgets.QGridLayout()
# set viewer area
⋮----
self.plotItem = self.plotitem  # for backcompatibility
⋮----
def add_scaled_axis(self, position)
⋮----
"""
        Add a AxisItem_Scaled to the given position with respect with the plotitem
        Parameters
        ----------
        position: (str) either 'top', 'bottom', 'right' or 'left'

        Returns
        -------

        """
⋮----
axis = AxisItem_Scaled(position)
⋮----
class PlotWidget(pg.PlotWidget)
⋮----
def __init__(self, *args, **kwargs)
⋮----
plot_item = pg.PlotItem(viewBox=View_cust())
⋮----
@property
    def view(self)
⋮----
@property
    def legend(self)
</file>

<file path="src/pymodaq_gui/QtDesigner_Ressources/credit.rst">
Icon Credits
############


* target.png: "Target Flat Icon.svg de Wikimedia Commons par Videoplasty.com, CC-BY-SA 4.0"
  https://fr.wikipedia.org/wiki/Fichier:Target_Flat_Icon.svg
* algo.png: <a href="https://www.flaticon.com/fr/icones-gratuites/algorithme" title="algorithme icônes">Algorithme icônes créées par phatplus - Flaticon</a>
</file>

<file path="src/pymodaq_gui/QtDesigner_Ressources/icons.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   sodipodi:docname="icons.svg"
   inkscape:version="1.0 (4035a4fb49, 2020-05-01)"
   id="svg8"
   version="1.1"
   viewBox="0 0 210 297"
   height="297mm"
   width="210mm">
  <defs
     id="defs2" />
  <sodipodi:namedview
     inkscape:window-maximized="1"
     inkscape:window-y="-8"
     inkscape:window-x="1912"
     inkscape:window-height="1017"
     inkscape:window-width="1920"
     showgrid="false"
     inkscape:document-rotation="0"
     inkscape:current-layer="layer1"
     inkscape:document-units="mm"
     inkscape:cy="251.2671"
     inkscape:cx="161.985"
     inkscape:zoom="2.8"
     inkscape:pageshadow="2"
     inkscape:pageopacity="0.0"
     borderopacity="1.0"
     bordercolor="#666666"
     pagecolor="#ffffff"
     id="base" />
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     id="layer1"
     inkscape:groupmode="layer"
     inkscape:label="Calque 1">
    <rect
       inkscape:export-ydpi="300"
       inkscape:export-xdpi="300"
       y="18.174328"
       x="18.174328"
       height="10.958051"
       width="10.958051"
       id="rect833"
       style="fill:#ff1c00;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;paint-order:fill markers stroke;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none" />
    <rect
       inkscape:export-ydpi="300"
       inkscape:export-xdpi="300"
       style="fill:#ff1c00;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke"
       id="rect833-2"
       width="10.958051"
       height="10.958051"
       x="22.851545"
       y="20.446119" />
    <rect
       inkscape:export-ydpi="300"
       inkscape:export-xdpi="300"
       style="fill:#ff1c00;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke"
       id="rect833-1"
       width="10.958051"
       height="10.958051"
       x="28.464205"
       y="22.317005" />
    <path
       inkscape:export-ydpi="300"
       inkscape:export-xdpi="300"
       inkscape:export-filename="C:\Users\weber\Labo\Programmes Python\PyMoDAQ_Git\pymodaq\src\pymodaq\resources\QtDesigner_Ressources\Icon_Library\run_all.png"
       transform="matrix(1.3430998,0,0,1,-6.6389431,1.2737737e-6)"
       inkscape:transform-center-x="-2.441257"
       d="m 19.34992,58.681279 0,-12.592905 10.905775,6.296453 z"
       inkscape:randomized="0"
       inkscape:rounded="0"
       inkscape:flatsided="true"
       sodipodi:arg2="3.1415927"
       sodipodi:arg1="2.0943951"
       sodipodi:r2="3.6352587"
       sodipodi:r1="7.2705169"
       sodipodi:cy="52.384827"
       sodipodi:cx="22.985178"
       sodipodi:sides="3"
       id="path856"
       style="fill:#16ff00;fill-opacity:1;stroke:#000000;stroke-width:0.862871;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke"
       sodipodi:type="star" />
    <path
       inkscape:export-ydpi="300"
       inkscape:export-xdpi="300"
       inkscape:export-filename="C:\Users\weber\Labo\Programmes Python\PyMoDAQ_Git\pymodaq\src\pymodaq\resources\QtDesigner_Ressources\Icon_Library\run_all.png"
       sodipodi:type="star"
       style="fill:#16ff00;fill-opacity:1;stroke:#000000;stroke-width:0.862871;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke"
       id="path856-6"
       sodipodi:sides="3"
       sodipodi:cx="22.985178"
       sodipodi:cy="52.384827"
       sodipodi:r1="7.2705169"
       sodipodi:r2="3.6352587"
       sodipodi:arg1="2.0943951"
       sodipodi:arg2="3.1415927"
       inkscape:flatsided="true"
       inkscape:rounded="0"
       inkscape:randomized="0"
       d="m 19.34992,58.681279 0,-12.592905 10.905775,6.296453 z"
       inkscape:transform-center-x="-2.441257"
       transform="matrix(1.3430998,0,0,1,-3.817297,2.8172591)" />
    <path
       inkscape:export-ydpi="300"
       inkscape:export-xdpi="300"
       inkscape:export-filename="C:\Users\weber\Labo\Programmes Python\PyMoDAQ_Git\pymodaq\src\pymodaq\resources\QtDesigner_Ressources\Icon_Library\run_all.png"
       sodipodi:type="star"
       style="fill:#16ff00;fill-opacity:1;stroke:#000000;stroke-width:0.862871;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke"
       id="path856-4"
       sodipodi:sides="3"
       sodipodi:cx="22.985178"
       sodipodi:cy="52.384827"
       sodipodi:r1="7.2705169"
       sodipodi:r2="3.6352587"
       sodipodi:arg1="2.0943951"
       sodipodi:arg2="3.1415927"
       inkscape:flatsided="true"
       inkscape:rounded="0"
       inkscape:randomized="0"
       d="m 19.34992,58.681279 0,-12.592905 10.905775,6.296453 z"
       inkscape:transform-center-x="-2.441257"
       transform="matrix(1.3430998,0,0,1,-0.99565079,5.6345168)" />
  </g>
</svg>
</file>

<file path="src/pymodaq_gui/utils/widgets/__init__.py">

</file>

<file path="src/pymodaq_gui/utils/widgets/label.py">
# -*- coding: utf-8 -*-
"""
Created the 29/07/2022

@author: Sebastien Weber
"""
⋮----
class LabelWithFont(QtWidgets.QLabel)
⋮----
def __init__(self, text: str = '', *args, font_name=None, font_size=None, isbold=False, isitalic=False, **kwargs)
⋮----
font = QtGui.QFont()
</file>

<file path="src/pymodaq_gui/utils/widgets/lcd.py">
class LCD(QObject)
⋮----
def __init__(self, parent: QtWidgets.QWidget, **kwargs)
⋮----
def setvalues(self, values: List[np.ndarray])
⋮----
"""
        display values on lcds
        Parameters
        ----------
        values: list of 0D ndarray

        Returns
        -------

        """
⋮----
values = values[:self.Nvals]
vals = []
⋮----
def setupui(self, **kwargs)
⋮----
vlayout = QtWidgets.QVBoxLayout()
hsplitter = QtWidgets.QSplitter()
⋮----
form = QtWidgets.QWidget()
⋮----
lcd_layouts = []
labels = []
⋮----
hFrame = QtWidgets.QFrame()
⋮----
lcd_widget = QtWidgets.QWidget()
⋮----
x = np.linspace(0, 200, 201)
y1 = gauss1D(x, 75, 25)
y2 = gauss1D(x, 120, 50, 2)
app = QtWidgets.QApplication(sys.argv)
Form = QtWidgets.QWidget()
⋮----
prog = LCD(Form, Nvals=2)
</file>

<file path="src/pymodaq_gui/utils/widgets/push.py">
EDIT_PUSH_TYPES = ['abs', 'rel']
⋮----
class PushButtonIcon(QtWidgets.QPushButton)
⋮----
def __init__(self, icon_name: str, text: str, checkable=False, tip="", menu=None)
⋮----
icon = QtGui.QIcon()
⋮----
def contextMenuEvent(self, event)
⋮----
class EditPushInfo
⋮----
def __init__(self, type:str, value: float)
⋮----
class EditPush(QtWidgets.QWidget)
⋮----
clicked = QtCore.Signal(EditPushInfo)
⋮----
def __init__(self, icon_name: str, ini_value=0.1, text='')
⋮----
def set_pushs(self, icon_name, text)
⋮----
def emit_clicked(self, coeff=1)
⋮----
"""will emit a signal containing a float value calculated from the product of the coeff and the internal
        spinbox value.

        See Also
        --------
        EditPushRel
        """
⋮----
class EditPushRel(EditPush)
⋮----
def __init__(self, icon_name: str, text='', ini_value=0.15)
⋮----
vlayout = QtWidgets.QVBoxLayout()
⋮----
class ActionMenu(QtWidgets.QAction)
⋮----
def __init__(self, *args, menu=None, **kwargs)
⋮----
def main(init_qt=True)
⋮----
if init_qt:  # used for the test suite
app = QtWidgets.QApplication(sys.argv)
⋮----
widget = QtWidgets.QWidget()
⋮----
toolbar = QtWidgets.QToolBar()
⋮----
action = QtWidgets.QAction('blabla')
⋮----
menu1 = QtWidgets.QMenu()
⋮----
menu2 = QtWidgets.QMenu()
⋮----
action2 = ActionMenu(icon, 'grab', menu=menu1)
⋮----
grab_pb = PushButtonIcon('run2', text='', checkable=True, menu=menu2)
⋮----
otherpb = PushButtonIcon('run2', 'grab me')
</file>

<file path="src/pymodaq_gui/utils/widgets/qled.py">
class QLED(QLabel)
⋮----
value_changed = Signal(bool)
⋮----
def __init__(self, parent=None, scale=1, readonly=True)
⋮----
# self.setText("")
⋮----
# set the possibility to click and control the state of the LED otherwise it behaves as an indicator
⋮----
# clickable is a function importing a filter class to deal with mouse down event as a signal see GUI_utils
⋮----
def scale(self, scale)
⋮----
def get_state(self)
⋮----
def set_as(self, state=True)
⋮----
def set_as_true(self)
⋮----
def set_as_false(self)
⋮----
def LED_Clicked(self)
</file>

<file path="src/pymodaq_gui/utils/widgets/spinbox.py">
class SpinBox(SpinBox)
⋮----
"""
    In case I want to add pyqtgraph spinbox functionalities
    """
def __init__(self, *args, font_size=None, min_height=20, **kwargs)
⋮----
def set_font_size(self, font_size)
⋮----
font = QtGui.QFont()
⋮----
class QSpinBoxWithShortcut(SpinBox)
⋮----
"""
    QSpinBox but which accepts key sequences and store them as attribute
    For now, it does not apply to regular input such as text or numerics.

    Beware I could not make it run for the KeySequence Ctrl+Enter or any combination involving enter...

    """
def __init__(self, *args, key_sequences=("Ctrl+E",), **kwargs)
⋮----
self.shortcut = dict() #Store shortcuts in a dictionnary
⋮----
shortcut = QtWidgets.QShortcut(QtGui.QKeySequence(key_sequence), self)
⋮----
class QSpinBox_ro(SpinBox)
⋮----
def __init__(self, *args, readonly=True, **kwargs)
⋮----
#self.setMaximum(100000)
⋮----
app = mkQApp('Test Spinbox')
⋮----
spinbox = QSpinBoxWithShortcut(key_sequences=('Ctrl+E', 'Ctrl+Shift+E', 'Ctrl+Enter', 'Ctrl+Shift+Enter'))
def print_spinbox(value)
</file>

<file path="src/pymodaq_gui/utils/widgets/table.py">
class TableView(QtWidgets.QTableView)
⋮----
def __init__(self, *args, **kwargs)
⋮----
def setupview(self)
⋮----
class TableModel(QtCore.QAbstractTableModel)
⋮----
def __init__(self, data, header, editable=True, parent=None, show_checkbox=False)
⋮----
data_tot = []
⋮----
data = data_tot
self._data = data  # stored data as a list of list
⋮----
def __eq__(self, other)
⋮----
def is_checked(self, row: int)
⋮----
@property
    def raw_data(self)
⋮----
def rowCount(self, parent)
⋮----
def columnCount(self, parent)
⋮----
def get_data(self, row, col)
⋮----
def get_data_all(self)
⋮----
def clear(self)
⋮----
def set_data_all(self, data)
⋮----
def data(self, index, role)
⋮----
dat = self._data[index.row()][index.column()]
⋮----
# def setHeaderData(self, section, orientation, value):
#     if section == 2 and orientation == Qt.Horizontal:
#         names = self._data.columns
#         self._data = self._data.rename(columns={names[section]: value})
#         self.headerDataChanged.emit(orientation, 0, section)
⋮----
def headerData(self, section, orientation, role)
⋮----
def flags(self, index)
⋮----
f = Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled
⋮----
def supportedDropActions(self)
⋮----
def validate_data(self, row, col, value)
⋮----
"""
        to be subclassed in order to validate ranges of values for the cell defined by index
        Parameters
        ----------
        index: (QModelIndex)
        value: (str or float or int or ...)


        Returns
        -------
        bool: True if value is valid for the given row and col
        """
⋮----
def setData(self, index, value, role)
⋮----
def dropMimeData(self, data, action, row, column, parent)
⋮----
row = self.rowCount(parent)
⋮----
def insert_data(self, row, data)
⋮----
def insertRows(self, row, count, parent)
⋮----
def remove_row(self, row)
⋮----
def removeRows(self, row, count, parent)
⋮----
class BooleanDelegate(QtWidgets.QItemEditorFactory)
⋮----
"""
    TO implement custom widget editor for cells in a tableview
    """
def createEditor(self, userType, parent)
⋮----
boolean = QtWidgets.QCheckBox(parent)
⋮----
class SpinBoxDelegate(QtWidgets.QItemEditorFactory)
⋮----
def __init__(self, decimals=4, min=-1e6, max=1e6)
⋮----
doubleSpinBox = QtWidgets.QDoubleSpinBox(parent)
⋮----
class MyStyle(QtWidgets.QProxyStyle)
⋮----
def drawPrimitive(self, element, option, painter, widget=None)
⋮----
"""
        Draw a line across the entire row rather than just the column
        we're hovering over.  This may not always work depending on global
        style - for instance I think it won't work on OSX.
        """
⋮----
option_new = QtWidgets.QStyleOption(option)
⋮----
option = option_new
⋮----
app = QtWidgets.QApplication([])
w = QtWidgets.QMainWindow()
table = TableView(w)
styledItemDelegate = QtWidgets.QStyledItemDelegate()
# styledItemDelegate.setItemEditorFactory(SpinBoxDelegate())
⋮----
#table.setItemDelegate(styledItemDelegate)
⋮----
#
⋮----
# c = TreeFromToml()
# c.show_dialog()
</file>

<file path="src/pymodaq_gui/utils/widgets/tree_layout.py">
class TreeLayout(QObject)
⋮----
"""
    qtpy class object based on QtreeWidget
    The function populate_tree has to be used in order to populate the tree with structure as nested lists of dicts

    """
status_sig = Signal(str)
item_clicked_sig = Signal(object)
item_double_clicked_sig = Signal(object)
⋮----
def __init__(self, parent=None, col_counts=1, labels=None)
⋮----
parent = QtWidgets.QWidget()
⋮----
def _current_text(self, col_index: int = 2)
⋮----
def current_node_path(self)
⋮----
def expand_all(self)
⋮----
def collapse_all(self)
⋮----
@property
    def treewidget(self)
⋮----
def setupUi(self)
⋮----
vlayout = QtWidgets.QVBoxLayout()
hlayout = QtWidgets.QHBoxLayout()
⋮----
iconopen = QtGui.QIcon()
⋮----
iconopensel = QtGui.QIcon()
⋮----
iconclose = QtGui.QIcon()
⋮----
def open_tree_selection(self)
⋮----
def tree_open_children(self, item_index)
⋮----
def tree_open_parents(self, item_index)
⋮----
flag = True
empty = QtCore.QModelIndex()
parent = item_index
⋮----
parent = parent.parent()
⋮----
flag = False
⋮----
def populate_tree(self, data_dict)
⋮----
parents = []
⋮----
str_list = [str(data['name'])]
⋮----
parent = QtWidgets.QTreeWidgetItem(str_list)
Items = self.populate_sub_tree(data['contents'])
⋮----
def populate_sub_tree(self, datas)
⋮----
class CustomTree(QtWidgets.QTreeWidget)
⋮----
def __init__(self, parent=None)
⋮----
app = QtWidgets.QApplication(sys.argv)
Form = QtWidgets.QWidget()
prog = TreeLayout(Form, col_counts=2, labels=["Material", "File"])
⋮----
# example of actions to add to the tree widget in order to show a context menu
detector_action = QtWidgets.QAction("Grab from camera", None)
⋮----
########################
⋮----
data = [dict(name='papa', contents=[
⋮----
# filename='C:\\Data\\2019\\20190220\\Dataset_20190220_004\\Dataset_20190220_004.h5'
# import tables
# h5_file = tables.open_file(filename, mode = "a")
# for node in h5_file.walk_nodes():
#     print(node)
# base_node = h5_file.root
# base_tree_item, pixmap_items = h5tree_to_QTree(h5_file, base_node)
# prog.ui.Tree.addTopLevelItem(base_tree_item)
</file>

<file path="src/pymodaq_gui/utils/widgets/tree_toml.py">
# -*- coding: utf-8 -*-
"""
Created the 19/10/2023

@author: Sebastien Weber
"""
⋮----
class TreeFromToml(QObject)
⋮----
""" Create a ParameterTree from a configuration file"""
⋮----
def __init__(self, config: Config = None, capitalize=True)
⋮----
config = Config()
⋮----
params = [{'title': 'Config path', 'name': 'config_path', 'type': 'str',
⋮----
def show_dialog(self) -> bool
⋮----
buttonBox = QtWidgets.QDialogButtonBox(parent=self.dialog)
⋮----
res = self.dialog.exec()
⋮----
config_dict = self.param_to_dict(self.settings)
⋮----
@classmethod
    def param_to_dict(cls, param: Parameter) -> dict
⋮----
config = dict()
⋮----
child.value().toSecsSinceEpoch())  # convert QDateTime to python datetime
⋮----
qdt = QtCore.QDateTime()
⋮----
pdt = datetime.fromtimestamp(qdt.toSecsSinceEpoch())
⋮----
@classmethod
    def dict_to_param(cls, config: dict, capitalize=True) -> Parameter
⋮----
params = []
⋮----
param = {'title': f'{key.capitalize() if capitalize else key}:',
⋮----
elif isinstance(config[key], bool):  # placed before int because a bool is an instance of int
</file>

<file path="src/pymodaq_gui/utils/widgets/widget_bkg.py">
class WidgetWithBkg(QtWidgets.QWidget)
⋮----
""" Widget with a png file as a background texture

    Parameters
    ----------
    bkg_path: Path
        Path to a valid png file to be used as background
    """
⋮----
def __init__(self, bkg_path: Union[str, Path], *args, **kwargs)
⋮----
bkg_path = Path(bkg_path)
⋮----
def setup_palette(self)
⋮----
pixmap = QtGui.QPixmap(str(self._bkg_path))
⋮----
palette = QtGui.QPalette()
</file>

<file path="src/pymodaq_gui/utils/__init__.py">

</file>

<file path="src/pymodaq_gui/utils/custom_app.py">
class CustomApp(QObject, ActionManager, ParameterManager)
⋮----
"""Base Class to ease the implementation of User Interfaces

    Inherits the MixIns ActionManager and ParameterManager classes. You have to subclass some methods and make
    concrete implementation of a given number of methods:

    * setup_actions: mandatory, see :class:`pymodaq.utils.managers.action_manager.ActionManager`
    * value_changed: non mandatory, see :class:`pymodaq.utils.managers.parameter_manager.ParameterManager`
    * child_added: non mandatory, see :class:`pymodaq.utils.managers.parameter_manager.ParameterManager`
    * param_deleted: non mandatory, see :class:`pymodaq.utils.managers.parameter_manager.ParameterManager`
    * setup_docks: mandatory
    * setup_menu: non mandatory
    * connect_things: mandatory

    Parameters
    ----------
    parent: DockArea or QtWidget

    See Also
    --------
    :class:`pymodaq.utils.managers.action_manager.ActionManager`,
    :class:`pymodaq.utils.managers.parameter_manager.ParameterManager`,
    :class:`pymodaq.utils.managers.modules_manager.ModulesManager`,
    """
⋮----
log_signal = QtCore.Signal(str)
params = []
⋮----
def __init__(self, parent: Union[DockArea, QtWidgets.QWidget])
⋮----
def setup_ui(self)
⋮----
self.setup_actions()  # see ActionManager MixIn class
⋮----
self.setup_menu()  # for backcompatibility
⋮----
def setup_docks(self)
⋮----
"""Mandatory method to be subclassed to setup the docks layout

        Examples
        --------
        >>>self.docks['ADock'] = gutils.Dock('ADock name')
        >>>self.dockarea.addDock(self.docks['ADock'])
        >>>self.docks['AnotherDock'] = gutils.Dock('AnotherDock name')
        >>>self.dockarea.addDock(self.docks['AnotherDock'''], 'bottom', self.docks['ADock'])

        See Also
        --------
        pyqtgraph.dockarea.Dock
        """
⋮----
def setup_menu(self, menubar: QtWidgets.QMenuBar = None)
⋮----
"""Non mandatory method to be subclassed in order to create a menubar

        create menu for actions contained into the self._actions, for instance:

        Examples
        --------
        >>>file_menu = self._menubar.addMenu('File')
        >>>self.affect_to('load', file_menu)
        >>>self.affect_to('save', file_menu)

        >>>file_menu.addSeparator()
        >>>self.affect_to('quit', file_menu)

        See Also
        --------
        pymodaq.utils.managers.action_manager.ActionManager
        """
⋮----
def connect_things(self)
⋮----
"""Connect actions and/or other widgets signal to methods"""
</file>

<file path="src/pymodaq_gui/utils/dock.py">
class Dock(Dock)
⋮----
dock_focused = Signal(str)
def __init__(self, name, *args, fontSize='20px', **kwargs)
⋮----
def removeWidgets(self)
⋮----
def setOrientation(self, o='auto', force=False)
⋮----
"""
        Sets the orientation of the title bar for this Dock.
        Must be one of 'auto', 'horizontal', or 'vertical'.
        By default ('auto'), the orientation is determined
        based on the aspect ratio of the Dock.
        """
if self.container() is not None:  # patch here for when Dock is closed and when the QApplication
# event loop is processed
⋮----
o = 'horizontal'
⋮----
o = 'vertical'
⋮----
class DockArea(DockArea, QObject)
⋮----
"""
    Custom Dockarea class subclassing from the standard DockArea class and QObject so it can emit a signal when docks
    are moved around (one subclassed method: moveDock)
    See Also
    --------
    pyqtgraph.dockarea
    """
dock_signal = Signal()
⋮----
def __init__(self, parent=None, temporary=False, home=None)
⋮----
def moveDock(self, dock, position, neighbor)
⋮----
"""
        Move an existing Dock to a new location.
        """
# Moving to the edge of a tabbed dock causes a drop outside the tab box
⋮----
neighbor = neighbor.container()
⋮----
def addTempArea(self)
⋮----
area = DockArea(temporary=True, home=self)
⋮----
win = TempAreaWindow(area)
⋮----
area = self.home.addTempArea()
# print "added temp area", area, area.window()
</file>

<file path="src/pymodaq_gui/utils/file_io.py">
config = Config()
⋮----
"""Opens a selection file popup for loading or saving a file

    Parameters
    ----------
    start_path: str or Path
        The strating point in the file/folder system to open the popup from
    save: bool
        if True, ask you to enter a filename (with or without extension)
    ext: str
        the extension string, e.g. xml, h5, png ...
    filter: list of string
        list of possible extensions, mostly valid for loading
    force_save_extension: bool
        if True force the extension of the saved file to be set to ext

    Returns
    -------
    Path: the Path object of the file to save or load
    str: the selected filter
    """
⋮----
ext = '.h5'
⋮----
ext = [ext]
filter = "Data files ("
⋮----
start_path = str(start_path)
⋮----
if fname != '':  # execute if the user didn't cancel the file selection
fname = Path(fname)
⋮----
parent = fname.parent
filename = fname.stem
fname = parent.joinpath(filename + "." + ext)  # forcing the right extension on the filename
⋮----
"""Opens a selection file popup for loading or saving a file

    Parameters
    ----------
    start_path: str or Path
        The strating point in the file/folder system to open the popup from
    save: bool
        if True, ask you to enter a filename (with or without extension)
    ext: str
        the extension string, e.g. xml, h5, png ...
    filter: string
        list of possible extensions, if you need several you can separate them by ;;
        for example: "Images (*.png *.xpm *.jpg);;Text files (*.txt);;XML files (*.xml)"
    force_save_extension: bool
        if True force the extension of the saved file to be set to ext

    Returns
    -------
    Path: the Path object of the file to save or load
    """
⋮----
return fname  # fname is a Path object
⋮----
app = QtWidgets.QApplication(sys.argv)
file = select_file(save=True, filter="Images (*.png *.xpm *.jpg);;Text files (*.txt);;XML files (*.xml)")
</file>

<file path="src/pymodaq_gui/utils/layout.py">
def load_layout_state(dockarea, file=None)
⋮----
"""
        Load and restore a dockarea layout state from the select_file obtained pathname file.
    """
⋮----
file = select_file(start_path=config_mod.get_set_layout_path(), save=False, ext='dock')
⋮----
dockstate = pickle.load(f)
⋮----
file = file.name
⋮----
def save_layout_state(dockarea, file=None)
⋮----
"""
        Save the current layout state in the select_file obtained pathname file.
        Once done dump the pickle.
    """
⋮----
dockstate = dockarea.saveState()
⋮----
file = select_file(start_path=config_mod.get_set_layout_path(), save=True, ext='dock')
</file>

<file path="src/pymodaq_gui/utils/list_picker.py">
class ListPicker(QObject)
⋮----
def __init__(self, list_str)
⋮----
def pick_dialog(self)
⋮----
vlayout = QtWidgets.QVBoxLayout()
⋮----
buttonBox = QtWidgets.QDialogButtonBox()
⋮----
res = self.dialog.show()
⋮----
# save managers parameters in a xml file
</file>

<file path="src/pymodaq_gui/utils/splash.py">
class MySplash(QtWidgets.QSplashScreen)
⋮----
def __init__(self, *args, **kwargs)
⋮----
here = Path(__file__)
pixmap = QtGui.QPixmap(str(here.parent.parent.joinpath('splash.png')))
⋮----
font = self.font()
⋮----
def showMessage(self, message, *args, **kwargs)
⋮----
""" force any message to be printed in white in the right/top corner """
⋮----
def get_splash_sc() -> MySplash
</file>

<file path="src/pymodaq_gui/utils/utils.py">
config = Config()
logger = set_logger(get_module_name(__file__))
⋮----
here = Path(__file__).parent
custom_folder = here.parent.joinpath('QtDesigner_Ressources/custom/')
⋮----
def set_dark_palette(app)
⋮----
palette = QPalette()
⋮----
# Checkbox are not visible in dark style but it is not possible to
# modify QCheckBox style without messing up the check mark (it disappears)
# so images are needed to avoid the problem.
⋮----
def clickable(widget)
⋮----
class Filter(QObject)
⋮----
clicked = Signal()
⋮----
def eventFilter(self, obj, event)
⋮----
# The developer can opt for .emit(obj) to get the object within the slot.
⋮----
filter = Filter(widget)
⋮----
def h5tree_to_QTree(base_node, base_tree_elt=None, pixmap_items=[])
⋮----
"""
        | Convert a loaded h5 file to a QTreeWidgetItem element structure containing two columns.
        | The first is the name of the h5 current node, the second is the path of the node in the h5 structure.
        |
        | Recursive function discreasing on base_node.

        ==================   ======================================== ===============================
        **Parameters**        **Type**                                 **Description**

          *h5file*            instance class File from tables module   loaded h5 file

          *base_node*         pytables h5 node                         parent node

          *base_tree_elt*     QTreeWidgetItem                          parent QTreeWidgetItem element
        ==================   ======================================== ===============================

        Returns
        -------
        QTreeWidgetItem
            h5 structure copy converted into QtreeWidgetItem structure.

        See Also
        --------
        h5tree_to_QTree

    """
⋮----
base_tree_elt = QtWidgets.QTreeWidgetItem([base_node.name, "", base_node.path])
⋮----
child = QtWidgets.QTreeWidgetItem([node_name, "", node.path])
klass = node.attrs['CLASS']
tooltip = []
⋮----
def set_enable_recursive(children, enable=False)
⋮----
"""Apply the enable state on all children widgets, do it recursively

    Parameters
    ----------
    children: (list) elements children ofa pyqt5 element
    enable: (bool) set enabled state (True) of all children widgets
    """
⋮----
def widget_to_png_to_bytes(widget, keep_aspect=True, width=200, height=100)
⋮----
"""
    Renders the widget content in a png format as a bytes string
    Parameters
    ----------
    widget: (QWidget) the widget to render
    keep_aspect: (bool) if True use width and the widget aspect ratio to calculate the height
                        if False use set values of width and height to produce the png
    width: (int) the rendered width of the png
    height: (int) the rendered width of the png

    Returns
    -------
    binary string

    """
png = widget.grab().toImage()
wwidth = widget.width()
wheight = widget.height()
⋮----
height = width * wheight / wwidth
⋮----
png = png.scaled(int(width), int(height), QtCore.Qt.KeepAspectRatio)
buffer = QtCore.QBuffer()
⋮----
def pngbinary2Qlabel(databinary, scale_height: int = None)
⋮----
buff = QBuffer()
⋮----
dat = buff.data()
pixmap = QtGui.QPixmap()
⋮----
pixmap = pixmap.scaledToHeight(scale_height)
label = QtWidgets.QLabel()
⋮----
def start_qapplication() -> QtWidgets.QApplication
⋮----
app = QtWidgets.QApplication(sys.argv)
⋮----
def mkQApp(name: str)
⋮----
app = mkQApppg(name)
⋮----
def exec()
⋮----
app = mkQApp('a name')
</file>

<file path="src/pymodaq_gui/__init__.py">
def set_and_check_qt_backend_or_die(config)
⋮----
wanted_backend = config('qtbackend', 'backend')
backend = wanted_backend
#filter to get only qt backend modules
available_backends = [mod.name.lower() for mod in pkgutil.iter_modules() \
⋮----
backend_found = wanted_backend.lower() in available_backends
⋮----
#trying in the remaining backends and taking the first one
⋮----
other_backends = [backend for backend in available_backends if backend != wanted_backend]
⋮----
backend_found = True
backend =  other_backends[0]
⋮----
# environment variable is set
⋮----
msg = "No Qt backend could be found in your system, please install either pyqt6 or pyside6." \
⋮----
__version__ = get_version(__package__)
⋮----
__version__ = '0.0.0dev'
⋮----
config = Config()  # to check for config file existence, otherwise create one
⋮----
logger = set_logger('pymodaq_gui', base_logger=False)
⋮----
# in a try statement for compilation on readthedocs server but if this fail, you cannot use the code
from pymodaq_gui.plotting import data_viewers  # imported here as to avoid circular imports later on
</file>

<file path="src/pymodaq_gui/config_saver_loader.py">
def get_set_roi_path()
⋮----
""" creates and return the config folder path for managers files
    """
⋮----
class ConfigSaverLoader
⋮----
""" Allows to set Parameters values from previously saved one in a configuration file

    This plays the role of a cache for these Parameters

    Parameters
    ----------
    base_param: Parameter
        The parent Parameter whose children should be cached in the config file
    config: BaseConfig
        The Config object that will cache the Parameter values
    base_path: Iterable[str]
        an iterable of string defining a "category"
    """
⋮----
base_path = []
⋮----
@property
    def base_path(self)
⋮----
""" Get/Set the iterable of string defining a particular configuration to be loaded/saved"""
⋮----
@base_path.setter
    def base_path(self, path: IterableType[str])
⋮----
@property
    def base_param(self)
⋮----
""" Get/Set the parent Parameter whose children should be saved in the config file"""
⋮----
@base_param.setter
    def base_param(self, param: 'Parameter')
⋮----
def load_config(self, param: 'Parameter' = None)
⋮----
param = self.base_param
base_path = self.base_path[:]
⋮----
if len(child.children()) == 0:  # means it is not a group parameter
⋮----
path = base_path + putils.get_param_path(child)[1:]
⋮----
*path))  # first try to load the config including the actuators name
⋮----
def save_config(self)
⋮----
path_param = self.base_path[:]
</file>

<file path="src/pymodaq_gui/messenger.py">
MESSAGE_SEVERITIES = ['critical', 'information', 'question', 'warning']
⋮----
def messagebox(severity='warning', title='this is a title', text='blabla')
⋮----
"""
    Display a popup messagebox with a given severity
    Parameters
    ----------
    severity: (str) one in ['critical', 'information', 'question', 'warning']
    title: (str) the displayed popup title
    text: (str) the displayed text in the message

    Returns
    -------
    bool: True if the user clicks on Ok
    """
⋮----
messbox = getattr(QtWidgets.QMessageBox, severity)
ret = messbox(None, title, text)
⋮----
def dialog(title='', message='', widget=None)
⋮----
dlg = QtWidgets.QDialog()
⋮----
label = QtWidgets.QLabel(message)
⋮----
button_box = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok | QtWidgets.QDialogButtonBox.StandardButton.Cancel)
⋮----
ret = dlg.exec()
⋮----
def show_message(message="blabla", title="Error")
</file>

<file path="src/pymodaq_gui/qt_utils.py">
logger = logger_module.set_logger(logger_module.get_module_name(__file__))
⋮----
config = Config()
⋮----
def decode_data(encoded_data)
⋮----
"""
    Decode QbyteArrayData generated when drop items in table/tree/list view
    Parameters
    ----------
    encoded_data: QByteArray
                    Encoded data of the mime data to be dropped
    Returns
    -------
    data: list
            list of dict whose key is the QtRole in the Model, and the value a QVariant

    """
data = []
⋮----
ds = QtCore.QDataStream(encoded_data, QtCore.QIODevice.ReadOnly)
⋮----
row = ds.readInt32()
col = ds.readInt32()
⋮----
map_items = ds.readInt32()
item = {}
⋮----
key = ds.readInt32()
#TODO check this is fine
value = QVariant()
#value = None
⋮----
def setLocale()
⋮----
"""
    defines the Locale to use to convert numbers to strings representation using language/country conventions
    Default is English and US
    """
language = getattr(QLocale, config('style', 'language'))
country = getattr(QLocale, config('style', 'country'))
</file>

<file path="src/pymodaq_gui/qvariant.py">
def QVariant(*args)
</file>

<file path="tests/data/preset_default.xml">
<Preset type="group" title="Preset" visible="1" removable="0" readonly="0"><filename type="str" title="Filename:" visible="1" removable="0" readonly="0">preset_default</filename><use_pid type="bool" title="Use PID as actuator:" visible="1" removable="0" readonly="0">0</use_pid><pid_models type="list" title="PID models:" visible="0" removable="0" readonly="0" limits="['PIDModelBeamSteering']">str('PIDModelBeamSteering')</pid_models><model_settings type="group" title="Model Settings:" visible="0" removable="0" readonly="0"><threshold type="float" title="Threshold" visible="1" removable="0" readonly="0">10.0</threshold></model_settings><Moves type="groupmove" title="Moves:" visible="1" removable="0" readonly="0" addList="['Mock', 'TCPServer', 'MockCamera', 'MockNamedAxes', 'MockTauMulti', 'PI', 'PI_E870', 'Mock', 'TCPServer', 'MockCamera', 'MockNamedAxes', 'MockTauMulti', 'PI', 'PI_E870']" addText="Add"><move00 type="group" title="Actuator 00" visible="1" removable="1" readonly="0"><name type="str" title="Name:" visible="1" removable="0" readonly="0">Xaxis</name><init type="bool" title="Init?:" visible="1" removable="0" readonly="0">1</init><params type="group" title="Settings:" visible="1" removable="0" readonly="0"><main_settings type="group" title="Main Settings:" visible="1" removable="0" readonly="0"><move_type type="str" title="Actuator type:" visible="1" removable="0" readonly="1">Mock</move_type><module_name type="str" title="Actuator name:" visible="1" removable="0" readonly="1">Xaxis</module_name><plugin_config type="bool_push" title="Plugin Config:" visible="1" removable="0" readonly="0">0</plugin_config><controller_ID type="int" title="Controller ID:" visible="1" removable="0" readonly="0">9029</controller_ID><refresh_timeout type="int" title="Refresh value (ms):" visible="1" removable="0" readonly="0">500</refresh_timeout><tcpip type="group" title="TCP/IP options:" visible="1" removable="0" readonly="0"><connect_server type="bool_push" title="Connect to server:" visible="1" removable="0" readonly="0">0</connect_server><tcp_connected type="led" title="Connected?:" visible="1" removable="0" readonly="0">0</tcp_connected><ip_address type="str" title="IP address:" visible="1" removable="0" readonly="0">localhost</ip_address><port type="int" title="Port:" visible="1" removable="0" readonly="0">6341</port></tcpip></main_settings><move_settings type="group" title="Actuator Settings:" visible="1" removable="0" readonly="0"><tau type="int" title="Tau (ms):" visible="1" removable="0" readonly="0">500</tau><multiaxes type="group" title="MultiAxes:" visible="1" removable="0" readonly="0"><ismultiaxes type="bool" title="is Multiaxes:" visible="1" removable="0" readonly="0">1</ismultiaxes><multi_status type="list" title="Status:" visible="1" removable="0" readonly="0" limits="['Master', 'Slave']" show_pb="1">str('Master')</multi_status><axis type="list" title="Axis:" visible="1" removable="0" readonly="0" limits="['X', 'Y', 'Theta']" show_pb="1">str('X')</axis></multiaxes><units type="str" title="Units:" visible="1" removable="0" readonly="1" /><epsilon type="float" title="Epsilon:" visible="1" removable="0" readonly="0">0.01</epsilon><timeout type="int" title="Timeout (s):" visible="1" removable="0" readonly="0">20</timeout><bounds type="group" title="Bounds:" visible="1" removable="0" readonly="0"><is_bounds type="bool" title="Set Bounds:" visible="1" removable="0" readonly="0">0</is_bounds><min_bound type="float" title="Min:" visible="1" removable="0" readonly="0">0.0</min_bound><max_bound type="float" title="Max:" visible="1" removable="0" readonly="0">1.0</max_bound></bounds><scaling type="group" title="Scaling:" visible="1" removable="0" readonly="0"><use_scaling type="bool" title="Use scaling:" visible="1" removable="0" readonly="0">0</use_scaling><scaling type="float" title="Scaling factor:" visible="1" removable="0" readonly="0">1.0</scaling><offset type="float" title="Offset factor:" visible="1" removable="0" readonly="0">0.0</offset></scaling></move_settings></params></move00><move01 type="group" title="Actuator 01" visible="1" removable="1" readonly="0"><name type="str" title="Name:" visible="1" removable="0" readonly="0">Yaxis</name><init type="bool" title="Init?:" visible="1" removable="0" readonly="0">1</init><params type="group" title="Settings:" visible="1" removable="0" readonly="0"><main_settings type="group" title="Main Settings:" visible="1" removable="0" readonly="0"><move_type type="str" title="Actuator type:" visible="1" removable="0" readonly="1">Mock</move_type><module_name type="str" title="Actuator name:" visible="1" removable="0" readonly="1">Yaxis</module_name><plugin_config type="bool_push" title="Plugin Config:" visible="1" removable="0" readonly="0">0</plugin_config><controller_ID type="int" title="Controller ID:" visible="1" removable="0" readonly="0">9029</controller_ID><refresh_timeout type="int" title="Refresh value (ms):" visible="1" removable="0" readonly="0">500</refresh_timeout><tcpip type="group" title="TCP/IP options:" visible="1" removable="0" readonly="0"><connect_server type="bool_push" title="Connect to server:" visible="1" removable="0" readonly="0">0</connect_server><tcp_connected type="led" title="Connected?:" visible="1" removable="0" readonly="0">0</tcp_connected><ip_address type="str" title="IP address:" visible="1" removable="0" readonly="0">localhost</ip_address><port type="int" title="Port:" visible="1" removable="0" readonly="0">6341</port></tcpip></main_settings><move_settings type="group" title="Actuator Settings:" visible="1" removable="0" readonly="0"><tau type="int" title="Tau (ms):" visible="1" removable="0" readonly="0">500</tau><multiaxes type="group" title="MultiAxes:" visible="1" removable="0" readonly="0"><ismultiaxes type="bool" title="is Multiaxes:" visible="1" removable="0" readonly="0">1</ismultiaxes><multi_status type="list" title="Status:" visible="1" removable="0" readonly="0" limits="['Master', 'Slave']" show_pb="1">str('Slave')</multi_status><axis type="list" title="Axis:" visible="1" removable="0" readonly="0" limits="['X', 'Y', 'Theta']" show_pb="1">str('Y')</axis></multiaxes><units type="str" title="Units:" visible="1" removable="0" readonly="1" /><epsilon type="float" title="Epsilon:" visible="1" removable="0" readonly="0">0.01</epsilon><timeout type="int" title="Timeout (s):" visible="1" removable="0" readonly="0">20</timeout><bounds type="group" title="Bounds:" visible="1" removable="0" readonly="0"><is_bounds type="bool" title="Set Bounds:" visible="1" removable="0" readonly="0">0</is_bounds><min_bound type="float" title="Min:" visible="1" removable="0" readonly="0">0.0</min_bound><max_bound type="float" title="Max:" visible="1" removable="0" readonly="0">1.0</max_bound></bounds><scaling type="group" title="Scaling:" visible="1" removable="0" readonly="0"><use_scaling type="bool" title="Use scaling:" visible="1" removable="0" readonly="0">0</use_scaling><scaling type="float" title="Scaling factor:" visible="1" removable="0" readonly="0">1.0</scaling><offset type="float" title="Offset factor:" visible="1" removable="0" readonly="0">0.0</offset></scaling></move_settings></params></move01><move02 type="group" title="Actuator 02" visible="1" removable="1" readonly="0"><name type="str" title="Name:" visible="1" removable="0" readonly="0">Theta axis</name><init type="bool" title="Init?:" visible="1" removable="0" readonly="0">1</init><params type="group" title="Settings:" visible="1" removable="0" readonly="0"><main_settings type="group" title="Main Settings:" visible="1" removable="0" readonly="0"><move_type type="str" title="Actuator type:" visible="1" removable="0" readonly="1">Mock</move_type><module_name type="str" title="Actuator name:" visible="1" removable="0" readonly="1">Theta axis</module_name><plugin_config type="bool_push" title="Plugin Config:" visible="1" removable="0" readonly="0">0</plugin_config><controller_ID type="int" title="Controller ID:" visible="1" removable="0" readonly="0">9029</controller_ID><refresh_timeout type="int" title="Refresh value (ms):" visible="1" removable="0" readonly="0">500</refresh_timeout><tcpip type="group" title="TCP/IP options:" visible="1" removable="0" readonly="0"><connect_server type="bool_push" title="Connect to server:" visible="1" removable="0" readonly="0">0</connect_server><tcp_connected type="led" title="Connected?:" visible="1" removable="0" readonly="0">0</tcp_connected><ip_address type="str" title="IP address:" visible="1" removable="0" readonly="0">localhost</ip_address><port type="int" title="Port:" visible="1" removable="0" readonly="0">6341</port></tcpip></main_settings><move_settings type="group" title="Actuator Settings:" visible="1" removable="0" readonly="0"><tau type="int" title="Tau (ms):" visible="1" removable="0" readonly="0">500</tau><multiaxes type="group" title="MultiAxes:" visible="1" removable="0" readonly="0"><ismultiaxes type="bool" title="is Multiaxes:" visible="1" removable="0" readonly="0">1</ismultiaxes><multi_status type="list" title="Status:" visible="1" removable="0" readonly="0" limits="['Master', 'Slave']" show_pb="1">str('Slave')</multi_status><axis type="list" title="Axis:" visible="1" removable="0" readonly="0" limits="['X', 'Y', 'Theta']" show_pb="1">str('Theta')</axis></multiaxes><units type="str" title="Units:" visible="1" removable="0" readonly="1" /><epsilon type="float" title="Epsilon:" visible="1" removable="0" readonly="0">0.01</epsilon><timeout type="int" title="Timeout (s):" visible="1" removable="0" readonly="0">20</timeout><bounds type="group" title="Bounds:" visible="1" removable="0" readonly="0"><is_bounds type="bool" title="Set Bounds:" visible="1" removable="0" readonly="0">0</is_bounds><min_bound type="float" title="Min:" visible="1" removable="0" readonly="0">0.0</min_bound><max_bound type="float" title="Max:" visible="1" removable="0" readonly="0">1.0</max_bound></bounds><scaling type="group" title="Scaling:" visible="1" removable="0" readonly="0"><use_scaling type="bool" title="Use scaling:" visible="1" removable="0" readonly="0">0</use_scaling><scaling type="float" title="Scaling factor:" visible="1" removable="0" readonly="0">1.0</scaling><offset type="float" title="Offset factor:" visible="1" removable="0" readonly="0">0.0</offset></scaling></move_settings></params></move02></Moves><Detectors type="groupdet" title="Detectors:" visible="1" removable="0" readonly="0" addList="['DAQ0D/Mock', 'DAQ0D/TCPServer', 'DAQ0D/Mock', 'DAQ0D/TCPServer', 'DAQ1D/Mock', 'DAQ1D/TCPServer', 'DAQ1D/Mock_spectro', 'DAQ1D/Mock', 'DAQ1D/TCPServer', 'DAQ1D/Mock_spectro', 'DAQ2D/Mock', 'DAQ2D/TCPServer', 'DAQ2D/MockCamera', 'DAQ2D/Mock', 'DAQ2D/TCPServer', 'DAQ2D/MockCamera', 'DAQND/Mock', 'DAQND/MockEvents', 'DAQND/Mock', 'DAQND/MockEvents']" addText="Add"><det00 type="group" title="Det 00" visible="1" removable="1" readonly="0"><name type="str" title="Name:" visible="1" removable="0" readonly="0">Det 0D</name><init type="bool" title="Init?:" visible="1" removable="0" readonly="0">1</init><params type="group" title="Settings:" visible="1" removable="0" readonly="0"><main_settings type="group" title="Main Settings:" visible="1" removable="0" readonly="0"><DAQ_type type="list" title="DAQ type:" visible="1" removable="0" readonly="1" limits="['DAQ0D', 'DAQ1D', 'DAQ2D', 'DAQND']" show_pb="1">str('DAQ0D')</DAQ_type><detector_type type="str" title="Detector type:" visible="1" removable="0" readonly="1">Mock</detector_type><module_name type="str" title="Detector Name:" visible="1" removable="0" readonly="1">Det 0D</module_name><plugin_config type="bool_push" title="Plugin Config:" visible="1" removable="0" readonly="0">0</plugin_config><controller_ID type="int" title="Controller ID:" visible="1" removable="0" readonly="0">1505</controller_ID><show_data type="bool" title="Show data and process:" visible="1" removable="0" readonly="0">1</show_data><refresh_time type="float" title="Refresh time (ms):" visible="1" removable="0" readonly="0">50.0</refresh_time><Naverage type="int" title="Naverage" visible="1" removable="0" readonly="0">1</Naverage><show_averaging type="bool" title="Show averaging:" visible="1" removable="0" readonly="0">0</show_averaging><live_averaging type="bool" title="Live averaging:" visible="1" removable="0" readonly="0">0</live_averaging><N_live_averaging type="int" title="N Live aver.:" visible="0" removable="0" readonly="0">0</N_live_averaging><wait_time type="int" title="Wait time (ms):" visible="1" removable="0" readonly="0">0</wait_time><continuous_saving_opt type="bool" title="Continuous saving:" visible="1" removable="0" readonly="0">0</continuous_saving_opt><tcpip type="group" title="TCP/IP options:" visible="1" removable="0" readonly="0"><connect_server type="bool_push" title="Connect to server:" visible="1" removable="0" readonly="0">0</connect_server><tcp_connected type="led" title="Connected?:" visible="1" removable="0" readonly="0">0</tcp_connected><ip_address type="str" title="IP address:" visible="1" removable="0" readonly="0">localhost</ip_address><port type="int" title="Port:" visible="1" removable="0" readonly="0">6341</port></tcpip><overshoot type="group" title="Overshoot options:" visible="1" removable="0" readonly="0"><stop_overshoot type="bool" title="Overshoot:" visible="1" removable="0" readonly="0">0</stop_overshoot><overshoot_value type="float" title="Overshoot value:" visible="1" removable="0" readonly="0">0.0</overshoot_value></overshoot><axes type="group" title="Axis options:" visible="1" removable="0" readonly="0"><use_calib type="list" title="Use calibration?:" visible="1" removable="0" readonly="0" limits="['None']" show_pb="1">str('None')</use_calib><xaxis type="group" title="X axis:" visible="1" removable="0" readonly="0"><xlabel type="str" title="Label:" visible="1" removable="0" readonly="0">x axis</xlabel><xunits type="str" title="Units:" visible="1" removable="0" readonly="0">pxls</xunits><xoffset type="float" title="Offset:" visible="1" removable="0" readonly="0">0.0</xoffset><xscaling type="float" title="Scaling" visible="1" removable="0" readonly="0">1.0</xscaling></xaxis><yaxis type="group" title="Y axis:" visible="1" removable="0" readonly="0"><ylabel type="str" title="Label:" visible="1" removable="0" readonly="0">y axis</ylabel><yunits type="str" title="Units:" visible="1" removable="0" readonly="0">pxls</yunits><yoffset type="float" title="Offset:" visible="1" removable="0" readonly="0">0.0</yoffset><yscaling type="float" title="Scaling" visible="1" removable="0" readonly="0">1.0</yscaling></yaxis></axes></main_settings><detector_settings type="group" title="Detector Settings" visible="1" removable="0" readonly="0"><controller_status type="list" title="Controller Status:" visible="1" removable="0" readonly="0" limits="['Master', 'Slave']" show_pb="1">str('Master')</controller_status><wait_time type="int" title="Wait time (ms)" visible="1" removable="0" readonly="0">100</wait_time><sep_viewers type="bool" title="Separated viewers" visible="1" removable="0" readonly="0">0</sep_viewers><lcd type="bool" title="Show in LCD" visible="1" removable="0" readonly="0">0</lcd><Mock1 type="group" title="Mock1" visible="1" removable="0" readonly="0"><Npts type="int" title="Npts" visible="1" removable="0" readonly="0">200</Npts><Amp type="int" title="Amp" visible="1" removable="0" readonly="0">20</Amp><x0 type="float" title="x0" visible="1" removable="0" readonly="0">50.0</x0><dx type="float" title="dx" visible="1" removable="0" readonly="0">20.0</dx><n type="int" title="n" visible="1" removable="0" readonly="0">1</n><amp_noise type="float" title="amp_noise" visible="1" removable="0" readonly="0">0.1</amp_noise></Mock1><Mock2 type="group" title="Mock2" visible="1" removable="0" readonly="0"><Npts type="int" title="Npts" visible="1" removable="0" readonly="0">200</Npts><Amp type="int" title="Amp" visible="1" removable="0" readonly="0">10</Amp><x0 type="float" title="x0" visible="1" removable="0" readonly="0">100.0</x0><dx type="float" title="dx" visible="1" removable="0" readonly="0">30.0</dx><n type="int" title="n" visible="1" removable="0" readonly="0">2</n><amp_noise type="float" title="amp_noise" visible="1" removable="0" readonly="0">0.1</amp_noise></Mock2></detector_settings></params></det00><det01 type="group" title="Det 01" visible="1" removable="1" readonly="0"><name type="str" title="Name:" visible="1" removable="0" readonly="0">Det 1D</name><init type="bool" title="Init?:" visible="1" removable="0" readonly="0">1</init><params type="group" title="Settings:" visible="1" removable="0" readonly="0"><main_settings type="group" title="Main Settings:" visible="1" removable="0" readonly="0"><DAQ_type type="list" title="DAQ type:" visible="1" removable="0" readonly="1" limits="['DAQ0D', 'DAQ1D', 'DAQ2D', 'DAQND']" show_pb="1">str('DAQ1D')</DAQ_type><detector_type type="str" title="Detector type:" visible="1" removable="0" readonly="1">Mock</detector_type><module_name type="str" title="Detector Name:" visible="1" removable="0" readonly="1">Det 1D</module_name><plugin_config type="bool_push" title="Plugin Config:" visible="1" removable="0" readonly="0">0</plugin_config><controller_ID type="int" title="Controller ID:" visible="1" removable="0" readonly="0">8744</controller_ID><show_data type="bool" title="Show data and process:" visible="1" removable="0" readonly="0">1</show_data><refresh_time type="float" title="Refresh time (ms):" visible="1" removable="0" readonly="0">50.0</refresh_time><Naverage type="int" title="Naverage" visible="1" removable="0" readonly="0">1</Naverage><show_averaging type="bool" title="Show averaging:" visible="1" removable="0" readonly="0">0</show_averaging><live_averaging type="bool" title="Live averaging:" visible="1" removable="0" readonly="0">0</live_averaging><N_live_averaging type="int" title="N Live aver.:" visible="0" removable="0" readonly="0">0</N_live_averaging><wait_time type="int" title="Wait time (ms):" visible="1" removable="0" readonly="0">0</wait_time><continuous_saving_opt type="bool" title="Continuous saving:" visible="1" removable="0" readonly="0">0</continuous_saving_opt><tcpip type="group" title="TCP/IP options:" visible="1" removable="0" readonly="0"><connect_server type="bool_push" title="Connect to server:" visible="1" removable="0" readonly="0">0</connect_server><tcp_connected type="led" title="Connected?:" visible="1" removable="0" readonly="0">0</tcp_connected><ip_address type="str" title="IP address:" visible="1" removable="0" readonly="0">localhost</ip_address><port type="int" title="Port:" visible="1" removable="0" readonly="0">6341</port></tcpip><overshoot type="group" title="Overshoot options:" visible="1" removable="0" readonly="0"><stop_overshoot type="bool" title="Overshoot:" visible="1" removable="0" readonly="0">0</stop_overshoot><overshoot_value type="float" title="Overshoot value:" visible="1" removable="0" readonly="0">0.0</overshoot_value></overshoot><axes type="group" title="Axis options:" visible="1" removable="0" readonly="0"><use_calib type="list" title="Use calibration?:" visible="1" removable="0" readonly="0" limits="['None']" show_pb="1">str('None')</use_calib><xaxis type="group" title="X axis:" visible="1" removable="0" readonly="0"><xlabel type="str" title="Label:" visible="1" removable="0" readonly="0">x axis</xlabel><xunits type="str" title="Units:" visible="1" removable="0" readonly="0">pxls</xunits><xoffset type="float" title="Offset:" visible="1" removable="0" readonly="0">0.0</xoffset><xscaling type="float" title="Scaling" visible="1" removable="0" readonly="0">1.0</xscaling></xaxis><yaxis type="group" title="Y axis:" visible="1" removable="0" readonly="0"><ylabel type="str" title="Label:" visible="1" removable="0" readonly="0">y axis</ylabel><yunits type="str" title="Units:" visible="1" removable="0" readonly="0">pxls</yunits><yoffset type="float" title="Offset:" visible="1" removable="0" readonly="0">0.0</yoffset><yscaling type="float" title="Scaling" visible="1" removable="0" readonly="0">1.0</yscaling></yaxis></axes></main_settings><detector_settings type="group" title="Detector Settings" visible="1" removable="0" readonly="0"><controller_status type="list" title="Controller Status:" visible="1" removable="0" readonly="0" limits="['Master', 'Slave']" show_pb="1">str('Master')</controller_status><rolling type="int" title="Rolling?:" visible="1" removable="0" readonly="0">0</rolling><multi type="bool" title="Multi Channels?:" visible="1" removable="0" readonly="0">0</multi><Mock1 type="group" title="Mock1:" visible="1" removable="0" readonly="0"><Amp type="int" title="Amp:" visible="1" removable="0" readonly="0">20</Amp><x0 type="float" title="x0:" visible="1" removable="0" readonly="0">500.0</x0><dx type="float" title="dx:" visible="1" removable="0" readonly="0">0.3</dx><n type="int" title="n:" visible="1" removable="0" readonly="0">1</n><amp_noise type="float" title="noise:" visible="1" removable="0" readonly="0">0.1</amp_noise></Mock1><Mock2 type="group" title="Mock2:" visible="1" removable="0" readonly="0"><Amp type="int" title="Amp?:" visible="1" removable="0" readonly="0">10</Amp><x0 type="float" title="x0:" visible="1" removable="0" readonly="0">520.0</x0><dx type="float" title="dx:" visible="1" removable="0" readonly="0">0.7</dx><n type="int" title="n:" visible="1" removable="0" readonly="0">2</n><amp_noise type="float" title="noise:" visible="1" removable="0" readonly="0">0.1</amp_noise></Mock2><x_axis type="group" title="xaxis:" visible="1" removable="0" readonly="0"><Npts type="int" title="Npts:" visible="1" removable="0" readonly="0">513</Npts><x0 type="float" title="x0:" visible="1" removable="0" readonly="0">515.0</x0><dx type="float" title="dx:" visible="1" removable="0" readonly="0">0.1</dx></x_axis></detector_settings></params></det01><det02 type="group" title="Det 02" visible="1" removable="1" readonly="0"><name type="str" title="Name:" visible="1" removable="0" readonly="0">Det 2D</name><init type="bool" title="Init?:" visible="1" removable="0" readonly="0">1</init><params type="group" title="Settings:" visible="1" removable="0" readonly="0"><main_settings type="group" title="Main Settings:" visible="1" removable="0" readonly="0"><DAQ_type type="list" title="DAQ type:" visible="1" removable="0" readonly="1" limits="['DAQ0D', 'DAQ1D', 'DAQ2D', 'DAQND']" show_pb="1">str('DAQ2D')</DAQ_type><detector_type type="str" title="Detector type:" visible="1" removable="0" readonly="1">Mock</detector_type><module_name type="str" title="Detector Name:" visible="1" removable="0" readonly="1">Det 2D</module_name><plugin_config type="bool_push" title="Plugin Config:" visible="1" removable="0" readonly="0">0</plugin_config><controller_ID type="int" title="Controller ID:" visible="1" removable="0" readonly="0">9476</controller_ID><show_data type="bool" title="Show data and process:" visible="1" removable="0" readonly="0">1</show_data><refresh_time type="float" title="Refresh time (ms):" visible="1" removable="0" readonly="0">50.0</refresh_time><Naverage type="int" title="Naverage" visible="1" removable="0" readonly="0">1</Naverage><show_averaging type="bool" title="Show averaging:" visible="1" removable="0" readonly="0">0</show_averaging><live_averaging type="bool" title="Live averaging:" visible="1" removable="0" readonly="0">0</live_averaging><N_live_averaging type="int" title="N Live aver.:" visible="0" removable="0" readonly="0">0</N_live_averaging><wait_time type="int" title="Wait time (ms):" visible="1" removable="0" readonly="0">0</wait_time><continuous_saving_opt type="bool" title="Continuous saving:" visible="1" removable="0" readonly="0">0</continuous_saving_opt><tcpip type="group" title="TCP/IP options:" visible="1" removable="0" readonly="0"><connect_server type="bool_push" title="Connect to server:" visible="1" removable="0" readonly="0">0</connect_server><tcp_connected type="led" title="Connected?:" visible="1" removable="0" readonly="0">0</tcp_connected><ip_address type="str" title="IP address:" visible="1" removable="0" readonly="0">localhost</ip_address><port type="int" title="Port:" visible="1" removable="0" readonly="0">6341</port></tcpip><overshoot type="group" title="Overshoot options:" visible="1" removable="0" readonly="0"><stop_overshoot type="bool" title="Overshoot:" visible="1" removable="0" readonly="0">0</stop_overshoot><overshoot_value type="float" title="Overshoot value:" visible="1" removable="0" readonly="0">0.0</overshoot_value></overshoot><axes type="group" title="Axis options:" visible="1" removable="0" readonly="0"><use_calib type="list" title="Use calibration?:" visible="1" removable="0" readonly="0" limits="['None']" show_pb="1">str('None')</use_calib><xaxis type="group" title="X axis:" visible="1" removable="0" readonly="0"><xlabel type="str" title="Label:" visible="1" removable="0" readonly="0">x axis</xlabel><xunits type="str" title="Units:" visible="1" removable="0" readonly="0">pxls</xunits><xoffset type="float" title="Offset:" visible="1" removable="0" readonly="0">0.0</xoffset><xscaling type="float" title="Scaling" visible="1" removable="0" readonly="0">1.0</xscaling></xaxis><yaxis type="group" title="Y axis:" visible="1" removable="0" readonly="0"><ylabel type="str" title="Label:" visible="1" removable="0" readonly="0">y axis</ylabel><yunits type="str" title="Units:" visible="1" removable="0" readonly="0">pxls</yunits><yoffset type="float" title="Offset:" visible="1" removable="0" readonly="0">0.0</yoffset><yscaling type="float" title="Scaling" visible="1" removable="0" readonly="0">1.0</yscaling></yaxis></axes></main_settings><detector_settings type="group" title="Detector Settings" visible="1" removable="0" readonly="0"><controller_status type="list" title="Controller Status:" visible="1" removable="0" readonly="0" limits="['Master', 'Slave']" show_pb="1">str('Master')</controller_status><Nimagescolor type="int" title="Nimages colors:" visible="1" removable="0" readonly="0">1</Nimagescolor><Nimagespannel type="int" title="Nimages pannels:" visible="1" removable="0" readonly="0">2</Nimagespannel><use_roi_select type="bool" title="Use ROISelect" visible="1" removable="0" readonly="0">0</use_roi_select><threshold type="int" title="Threshold" visible="1" removable="0" readonly="0">1</threshold><rolling type="int" title="rolling" visible="1" removable="0" readonly="0">1</rolling><Nx type="int" title="Nx" visible="1" removable="0" readonly="0">100</Nx><Ny type="int" title="Ny" visible="1" removable="0" readonly="0">200</Ny><Amp type="int" title="Amp" visible="1" removable="0" readonly="0">20</Amp><x0 type="slide" title="x0" visible="1" removable="0" readonly="0">50</x0><y0 type="float" title="y0" visible="1" removable="0" readonly="0">100.0</y0><dx type="float" title="dx" visible="1" removable="0" readonly="0">20.0</dx><dy type="float" title="dy" visible="1" removable="0" readonly="0">40.0</dy><n type="int" title="n" visible="1" removable="0" readonly="0">1</n><amp_noise type="float" title="amp_noise" visible="1" removable="0" readonly="0">4.0</amp_noise><cam_settings type="group" title="Cam. Prop.:" visible="1" removable="0" readonly="0" /></detector_settings></params></det02></Detectors></Preset>
</file>

<file path="tests/h5module_test/saving_test.py">
# -*- coding: utf-8 -*-
"""
Created the 21/11/2022

@author: Sebastien Weber
"""
⋮----
tested_backend = ['tables', 'h5py']  # , 'h5pyd']
⋮----
@pytest.fixture()
def get_h5saver(qtbot)
⋮----
h5saver = saving.H5Saver()
⋮----
@pytest.fixture(params=tested_backend)
def get_h5saver_scan(request, qtbot)
⋮----
saver = saving.H5Saver(save_type='scan', backend=request.param)
⋮----
@pytest.fixture(scope="module")
def session_path(tmp_path_factory)
⋮----
def generate_random_data(shape, dtype=float)
⋮----
class TestH5Saver
⋮----
def test_init_file_addhoc(self, get_h5saver, tmp_path)
⋮----
h5saver = get_h5saver
addhoc_file_path = tmp_path.joinpath('h5file.h5')
⋮----
logger_array = h5saver.get_set_logger()
⋮----
def test_init_file(self, get_h5saver_scan, tmp_path)
⋮----
h5saver = get_h5saver_scan
datetime_now = datetime.now()
date = datetime_now.date()
today = f'{date.year}{date.month:02d}{date.day:02d}'
base_path = tmp_path
⋮----
update_h5 = True
⋮----
# assert h5saver.h5_file_path.joinpath(f'Dataset_{today}_001.h5').is_file()
⋮----
scan_group = h5saver.add_scan_group()
⋮----
scan_group1 = h5saver.add_scan_group()
⋮----
def test_load_file(self, get_h5saver_scan, tmp_path)
⋮----
file_path = h5saver.settings.child(('current_h5_file')).value()
⋮----
def test_groups(self, get_h5saver_scan, tmp_path)
⋮----
scan_group = h5saver.add_scan_group(settings_as_xml='this is a setting',
⋮----
ch1_group = h5saver.add_ch_group(scan_group)
⋮----
scan_group_1 = h5saver.add_scan_group()
⋮----
def test_hierarchy(self, get_h5saver_scan, tmp_path)
⋮----
move_group = h5saver.add_move_group(scan_group)
⋮----
det_group = h5saver.add_det_group(scan_group)
⋮----
data_group = h5saver.add_data_group(det_group, data_dim)
⋮----
CH_group0 = h5saver.add_ch_group(data_group)
⋮----
CH_group1 = h5saver.add_ch_group(data_group)
</file>

<file path="tests/managers/action_manager_test.py">
# -*- coding: utf-8 -*-
"""
Created the 08/11/2024

@author: Constant Schouder
"""
⋮----
version_qt = QtCore.qVersion()
⋮----
@pytest.fixture
def ini_qt_widget(init_qt)
⋮----
qtbot = init_qt
widget = QtWidgets.QWidget()
⋮----
action = action_manager.get_action(action_name)
⋮----
def test_icon(qtbot)
⋮----
action_manager = ActionManager(toolbar=QtWidgets.QToolBar(), menu=QtWidgets.QMenu())
⋮----
icon = QtGui.QIcon.fromTheme(QtGui.QIcon.ThemeIcon.WindowClose)
⋮----
def test_action_properties(qtbot)
</file>

<file path="tests/managers/parameter_manager_test.py">
1# -*- coding: utf-8 -*-
"""
Created the 07/11/2023

@author: Sebastien Weber
"""
⋮----
@pytest.fixture
def ini_qt_widget(init_qt)
⋮----
qtbot = init_qt
widget = QtWidgets.QWidget()
⋮----
class RealParameterManager(ParameterManager)
⋮----
params = {'title': 'Numbers:', 'name': 'numbers', 'type': 'group', 'children': [
⋮----
def test_parameter_manager(qtbot)
⋮----
param_manager = RealParameterManager()
⋮----
def test_save(qtbot, tmp_path)
⋮----
ptree = ParameterEx()
⋮----
file_path = tmp_path.joinpath('settings.xml')
⋮----
def test_load(qtbot, tmp_path)
⋮----
parameter_copy = Parameter.create(name='settings', type='group', children=ParameterEx.params)
⋮----
parameters = iter_children_params(ptree.settings, childlist=[])
parameters_copy = iter_children_params(parameter_copy, childlist=[])
⋮----
default_parameter = Parameter.create(name='settings', type=parameter.opts['type'])
⋮----
item = default_parameter.makeTreeItem(0)
</file>

<file path="tests/parameter_test/param_ioxml_test.py">
# -*- coding: utf-8 -*-
"""
Created the 29/08/2023

@author: Sebastien Weber
"""
⋮----
axes_names = {'Axis 1': 0, 'Axis 2': 1, 'Axis 3': 2}
⋮----
params = [{'title': 'Axes', 'name': 'axes', 'type': 'list', 'limits': axes_names}]
⋮----
settings = Parameter.create(name='settings', type='group', children=params)
# preset = PresentManager()
⋮----
string = ioxml.parameter_to_xml_string(settings.child('axes'))
⋮----
class TestListParameter
⋮----
list_limits = ['DAQ0D', 'DAQ1D', 'DAQ2D', 'DAQND']
dict_limits = {'DAQ0D': 0, 'DAQ1D': 1, 'DAQ2D': 2, 'DAQND': 3}
⋮----
params = [{'name': 'list_param', 'type': 'list', 'limits': list_limits},
⋮----
settings = Parameter.create(name='settings', children=params)
⋮----
def test_value(self, qtbot)
⋮----
tree = ParameterTree()
⋮----
list_widget: QtWidgets.QComboBox = list_item.widget.combo
dict_widget: QtWidgets.QComboBox = dict_item.widget.combo
⋮----
list_item.setValue('DAQ4D')  # not in limits so should be set to the first element of the underlying combobox
dict_item.setValue('DAQ1D')  # not in limits (because should be values of the dict, not keys) so should be
# set to the first element of the underlying combobox
⋮----
def test_save_xml_list(self)
⋮----
xml_string = ioxml.parameter_to_xml_string(self.settings.child('list_param'))
⋮----
param_back = ioxml.XML_string_to_pobject(xml_string).child('list_param')
⋮----
def test_save_xml_dict(self)
⋮----
xml_string = ioxml.parameter_to_xml_string(self.settings.child('dict_param'))
⋮----
param_back = ioxml.XML_string_to_pobject(xml_string).child('dict_param')
⋮----
class TestXMLbackForth()
⋮----
params = ParameterEx.params
⋮----
def test_save_load_xml(self)
⋮----
param_back = ioxml.XML_string_to_pobject(ioxml.parameter_to_xml_string(self.settings))
children_list_in = putils.iter_children_params(self.settings)
children_list_back = putils.iter_children_params(param_back)
⋮----
def test_load_save_overwrite_xml_file(self, tmp_path)
⋮----
"""
        Testing to load default preset saving it under a name,
        raising an exception when trying to overwrite then forcing overwrite
        :return:
        """
defaultparameter = Parameter.create(title='Preset', name='Preset', type='group',
saveto = tmp_path.joinpath('impossiblenamedonotuse')
⋮----
origin_modification_time = saveto.with_suffix(".xml").stat().st_mtime_ns
</file>

<file path="tests/parameter_test/param_ptypes_test.py">
# -*- coding: utf-8 -*-
"""
Created the 23/11/2023

@author: Sebastien Weber
"""
⋮----
@pytest.fixture
def init_ParameterTree(qtbot)
⋮----
form = QtWidgets.QWidget()
prog = ParameterTree(form)
⋮----
class TestItemSelect
⋮----
def test_isSelected_setValue(self, init_ParameterTree)
⋮----
params_itemSelect = {'title': 'Dragable items', 'name': 'itemsSelect_drag',
tree = init_ParameterTree
settings = Parameter.create(**params_itemSelect)
⋮----
# Keeping selection order + erase non existing items
⋮----
# Removing selection
⋮----
# Adding selection (non matching order between all/selected)
⋮----
def test_isSelected_clicked(self, init_ParameterTree)
⋮----
listwidget = tree.listAllItems()[0].widget.itemselect
⋮----
# Selecting items
⋮----
# Unselecting item
⋮----
# Reselecting item
</file>

<file path="tests/parameter_test/param_str_test.py">
def test_empty_string()
⋮----
param_list = [{'name': 'strname', 'type': 'str', 'value': ''}]
⋮----
settings = Parameter.create(name='settings', type='group', children=param_list)
xml_string = ioxml.parameter_to_xml_string(settings)
settings_back = ioxml.XML_string_to_pobject(xml_string)
#
</file>

<file path="tests/parameter_test/param_utils_test.py">
# -*- coding: utf-8 -*-
"""
Created the 28/10/2022

@author: Sebastien Weber
"""
⋮----
params = [
params1 = [
# No min for afloat ==) False, True, True
params2 = [
# No children in afloat ==) False, False, False
params3 = [
# Different value in afloat ==) False, False, True
params4 = [
P1 = Parameter(name='settings1', type='group', children=params1)
P2 = Parameter(name='settings2', type='group', children=params2)
P3 = Parameter(name='settings3', type='group', children=params3)
P4 = Parameter(name='settings4', type='group', children=params4)
⋮----
def test_iter_children_params()
⋮----
settings = Parameter.create(name='settings', type='group', children=params)
param_list = putils.iter_children_params(settings,childlist=[],filter_type=['group'])
⋮----
param_list = putils.iter_children_params(settings,childlist=[],filter_name=['axis'])
⋮----
param_list = putils.iter_children_params(settings,childlist=[],filter_name=['axis'],select_filter=True)
⋮----
param_list = putils.iter_children_params(settings,childlist=[],filter_type=['group'],select_filter=True)
⋮----
def test_iter_children_attributes()
⋮----
param_name = putils.iter_children_params(settings, childlist=[], output_type='name')
param_type = putils.iter_children_params(settings, childlist=[], output_type='type')
param_list = putils.iter_children_params(settings, childlist=[])
⋮----
def test_get_param_path()
⋮----
path = putils.get_param_path(settings.child('main_settings', 'DAQ_type'))
⋮----
def test_get_param_from_name()
⋮----
def test_is_name_in_dict()
⋮----
dict = {'name': 'test', 'parameter': 'gaussian', 'value': 5}
⋮----
def test_get_param_dict_from_name()
⋮----
parent_list = []
⋮----
parent_dict = {'name': ind, 'value': ind*5}
⋮----
children = []
⋮----
parent_dict = {'name': ind*5, 'value': ind*10}
⋮----
parent_dict = {'name': 'test', 'children': children}
⋮----
result = putils.get_param_dict_from_name(parent_list, 4)
⋮----
result = putils.get_param_dict_from_name(parent_list, 20, pop=True)
⋮----
def test_getOpts()
⋮----
opts = putils.getOpts(P1)
⋮----
def test_getStruct()
⋮----
struc = putils.getStruct(P1)
⋮----
def test_getValues()
⋮----
val = putils.getValues(P1)
⋮----
def test_compareParameters()
def test_compareStructureParameter()
⋮----
def test_compareValuesParameter()
⋮----
class TestScroll
⋮----
def test_scroll_log(self)
⋮----
min_val = 50
max_val = 51
⋮----
def test_scroll_linear(self)
⋮----
def test_set_param_from_param(qtbot)
⋮----
settings_old = Parameter.create(name='settings', type='group', children=params)
⋮----
tree = ParameterTree()
⋮----
dict_widget: QtWidgets.QComboBox = dict_item.widget.combo
⋮----
def test_ParameterWithPath_serialize()
⋮----
p1_with_path = putils.ParameterWithPath(P1.child('numbers', 'afloat', 'aint'))
⋮----
param_back: putils.ParameterWithPath = putils.ser_factory.get_apply_deserializer(
</file>

<file path="tests/plotting_test/data_viewers_test/ploting_data_all_test.py">
# -*- coding: utf-8 -*-
"""
Created on Thu Feb 29 16:12:05 2024

@author: weber
"""
⋮----
@pytest.fixture(scope="module")
def get_3D_array()
⋮----
# import tempfile
# from pathlib import Path
# import zipfile
# from urllib.request import urlretrieve
# import nibabel
#
# # Create a temporary directory
# with tempfile.TemporaryDirectory() as directory_name:
#     directory = Path(directory_name)
#     # Define URL
#     url = 'http://www.fil.ion.ucl.ac.uk/spm/download/data/attention/attention.zip'
⋮----
#     # Retrieve the data
#     fn, info = urlretrieve(url, directory.joinpath('attention.zip'))
⋮----
#     # Extract the contents into the temporary directory we created earlier
#     zipfile.ZipFile(fn).extractall(path=directory)
⋮----
#     # Read the image
#     struct = nibabel.load(directory.joinpath('attention/structural/nsM00587_0002.hdr'))
⋮----
#     # Get a plain NumPy array, without all the metadata
#     array_3D = struct.get_fdata()
p = Path(__file__).parent.parent.parent
array_3D = np.load(p.joinpath('data/my_brain.npy'))
⋮----
@pytest.fixture(scope='module')
def get_4D()
⋮----
x = mutils.linspace_step(-10, 10, 0.2)
y = mutils.linspace_step(-30, 30, 2)
t = mutils.linspace_step(-200, 200, 2)
z = mutils.linspace_step(-50, 50, 0.5)
data = np.zeros((len(y), len(x), len(t), len(z)))
amp = np.ones((len(y), len(x), len(t), len(z)))
⋮----
dwa = \
⋮----
@pytest.fixture()
def get_h5saver(tmp_path)
⋮----
h5saver = H5SaverLowLevel()
addhoc_file_path = tmp_path.joinpath('h5file.h5')
⋮----
class Test1DPlot
⋮----
def test_plot_0D_1D_uniform(self, qtbot)
⋮----
#%%
NX = 100
x_axis = datamod.Axis('xaxis', 'xunits', data=np.linspace(-20, 50, NX), index=0)
data_array_1D = mutils.gauss1D(x_axis.get_data(), 10, 5)
⋮----
dwa_1D = datamod.DataRaw('data1DUniform', data=[data_array_1D, -data_array_1D],
⋮----
viewer = dwa_1D.plot('qt')
⋮----
dwa_back = saver_loader.load_data('/RawData/Data00', load_all=True)
⋮----
def test_plot_1D_0D_uniform(self, qtbot)
⋮----
def test_plot_1D_0D_spread(self, qtbot)
⋮----
axis_spread_array = np.linspace(-20, 50, NX)
⋮----
data_array_1D_spread = mutils.gauss1D(axis_spread_array, 20, 5)
⋮----
axis_name = 'axis spread'
axis_units = 'spread units'
⋮----
axis_spread = datamod.Axis(axis_name, axis_units, data=axis_spread_array)
⋮----
data0D = datamod.DataRaw('data0D',
⋮----
data1D_spread = saver_loader.load_data('/RawData/EnlData00', load_all=True)
⋮----
viewer = data1D_spread.plot('qt')
⋮----
def test_plot_0D_1D_spread(self, qtbot, get_h5saver)
⋮----
h5saver = get_h5saver
data_saver = DataEnlargeableSaver(h5saver)
⋮----
axis_array = np.linspace(-20, 50, NX)
data_array_1D = mutils.gauss1D(axis_array, 20, 5)
axis_sig = datamod.Axis('axis spread', 'units', data=axis_array, index=0)
data_to_append = datamod.DataRaw('data1D', data=[data_array_1D],
⋮----
axis_value = 12.
⋮----
dwa_back = data_saver.load_data('/RawData/EnlData00', load_all=True)
⋮----
viewer = dwa_back.plot('qt')
⋮----
class Test2DPlot
⋮----
def test_plot_0D_2D_uniform(self, qtbot)
⋮----
NY = 50
⋮----
x_axis = datamod.Axis('xaxis', 'xunits', data=np.linspace(-20, 50, NX), index=1)
y_axis = datamod.Axis('yaxis', 'yunits', data=np.linspace(20, 40, NY), index=0)
data_array_2D = mutils.gauss2D(x_axis.get_data(), 0, 5, y_axis.get_data(), 30, 5)
⋮----
data2D = datamod.DataRaw('data2DUniform', data=[data_array_2D],
⋮----
viewer = data2D.plot('qt')
⋮----
@pytest.mark.parametrize('nav_index', (0, 1))
    def test_plot_1D_1D_uniform(self, qtbot, nav_index)
⋮----
def test_plot_2D_0D_uniform(self, qtbot)
⋮----
def test_plot_2D_0D_spread(self, qtbot)
⋮----
N = 100
x_axis_array = np.random.randint(-20, 50, size=N)
y_axis_array = np.random.randint(20, 40, size=N)
x_axis = datamod.Axis('xaxis', 'xunits', data=x_axis_array, index=0, spread_order=0)
y_axis = datamod.Axis('yaxis', 'yunits', data=y_axis_array, index=0, spread_order=1)
⋮----
data_list = []
⋮----
data_array = datamod.squeeze(np.array(data_list))
⋮----
data2D_spread = datamod.DataRaw('data2DSpread', data=[data_array],
⋮----
viewer = data2D_spread.plot('qt')
⋮----
def test_plot_1D_1D_spread(self, qtbot)
⋮----
N = 10
axis_array = np.linspace(0, 2*np.pi, N)
axis = datamod.Axis('axis', 'units', data=axis_array, index=0, spread_order=0)
⋮----
class Test3DPlot
⋮----
@pytest.mark.parametrize('nav_index', ((0,), (1,), (2,), (0, 1), (0, 2), (1, 2)))
    def test_plot_0D_3D_uniform(self, qtbot, get_3D_array, nav_index)
⋮----
data3D = datamod.DataRaw('data3DUniform', data=[get_3D_array],
⋮----
viewer = data3D.plot('qt')
⋮----
class Test4DPlot
⋮----
def test_plot_4D_uniform(self, qtbot, get_4D, nav_indexes)
⋮----
dwa = get_4D
⋮----
viewer = dwa.plot('qt')
⋮----
def test_plot_4D_spread(self, qtbot)
⋮----
x = np.sin(np.linspace(0, 4 * np.pi, N))
y = np.sin(np.linspace(0, 4 * np.pi, N) + np.pi / 6)
z = np.sin(np.linspace(0, 4 * np.pi, N) + np.pi / 3)
⋮----
Nsig = 200
axis = datamod.Axis('signal axis', 'signal units', data=np.linspace(-10, 10, Nsig), index=1)
data = np.zeros((N, Nsig))
⋮----
dwa = datamod.DataRaw('NDdata', data=data, distribution='spread', dim='DataND',
</file>

<file path="tests/plotting_test/data_viewers_test/viewer0D_test.py">
@pytest.fixture
def init_viewer0d(qtbot)
⋮----
form = QtWidgets.QWidget()
prog = Viewer0D(form)
⋮----
class Data0D
⋮----
num = 0
⋮----
def __init__(self, Npts=11)
⋮----
def __iter__(self)
⋮----
def __next__(self)
⋮----
class TestViewer0D
⋮----
def test_init(self, init_viewer0d)
⋮----
prog = Viewer0D(None)
⋮----
def test_actions(self, init_viewer0d)
⋮----
def test_clear_action(self, init_viewer0d)
⋮----
def test_show_datalist(self, init_viewer0d)
⋮----
def test_clear_data(self, init_viewer0d)
</file>

<file path="tests/plotting_test/data_viewers_test/viewer1D_test.py">
@pytest.fixture
def init_viewer1d(qtbot)
⋮----
widget = QtWidgets.QWidget()
prog = Viewer1D(widget)
⋮----
x = np.linspace(0, 200, 201)
y1 = mutils.gauss1D(x, 75, 25)
y2 = mutils.gauss1D(x, 120, 50, 2)
data = data_mod.DataRaw('mydata', data=[y1, y2],
⋮----
class TestLineoutPlotter
⋮----
# Most test should be made in the base class
⋮----
class TestDataDisplayer
⋮----
#TODO
⋮----
class TestView1D
⋮----
class TestViewer1D
⋮----
def test_init(self, init_viewer1d)
⋮----
def test_do_math(self, init_viewer1d)
⋮----
def test_scatter(self, init_viewer1d)
⋮----
def test_xyplot_action(self, init_viewer1d)
⋮----
def test_crosshairClicked(self, init_viewer1d)
⋮----
def test_extra_scatter(self, init_viewer1d)
⋮----
xlow = np.linspace(0, 200, 21)
ylow = gauss1D(xlow, 75, 25)
⋮----
scatter_dwa = data_mod.DataRaw(
⋮----
def test_unsorted(self, init_viewer1d)
⋮----
xaxis = np.concatenate((x, x[::-1]))
y = gauss1D(x, 75, 25)
yaxis = np.concatenate((y, -y))
data = data_mod.DataRaw('mydata', data=[yaxis],
⋮----
def test_random(self, init_viewer1d)
⋮----
x = np.random.randint(201, size=201)
y1 = gauss1D(x, 75, 25)
y2 = gauss1D(x, 120, 50, 2)
⋮----
data = data_mod.DataRaw(
⋮----
def test_errors(self, init_viewer1d)
⋮----
def test_nans(self, init_viewer1d)
⋮----
data = data_mod.DataRaw('mydata', data=[y],
</file>

<file path="tests/plotting_test/data_viewers_test/viewer1Dbasic_test.py">
@pytest.fixture
def init_viewer1Dbasic(qtbot)
⋮----
form = QtWidgets.QWidget()
prog = Viewer1DBasic(form)
⋮----
class TestViewer1DBasic
⋮----
def test_init(self, init_viewer1Dbasic)
⋮----
prog = init_viewer1Dbasic
⋮----
def test_show(self, init_viewer1Dbasic)
⋮----
def test_update_region(self, init_viewer1Dbasic)
⋮----
ROI = LinearRegionItem()
⋮----
def test_update_line(self, init_viewer1Dbasic)
⋮----
IL = InfiniteLine()
⋮----
def test_update_labels(self, init_viewer1Dbasic)
⋮----
datas = np.linspace(np.linspace(1, 10, 10), np.linspace(11, 20, 10), 2)
⋮----
item = PlotItem()
⋮----
labels = ['CH_00', 'CH_01']
⋮----
def test_show_data(self, init_viewer1Dbasic)
⋮----
def test_x_axis(self, init_viewer1Dbasic)
⋮----
data = np.linspace(1, 10, 10)
label = ['CH_00', 'CH_01']
units = 'nm'
⋮----
x_axis = {'data': data, 'label': label, 'units': units}
</file>

<file path="tests/plotting_test/data_viewers_test/viewer2D_basic_test.py">
@pytest.fixture
def init_viewer2d_basic(qtbot)
⋮----
form = QtWidgets.QWidget()
prog = Viewer2DBasic(form)
⋮----
@pytest.fixture
def init_image(qtbot)
⋮----
img = ImageWidget(form)
⋮----
@pytest.fixture
def init_view(qtbot)
⋮----
view = View_cust()
⋮----
class TestViewer2DBasic
⋮----
def test_init(self, init_viewer2d_basic)
⋮----
prog = init_viewer2d_basic
⋮----
prog = Viewer2DBasic()
⋮----
def test_scale_axis(self, init_viewer2d_basic)
⋮----
xaxis = np.linspace(1, 10, 10)
yaxis = np.linspace(11, 20, 10)
⋮----
result = prog.scale_axis(xaxis=xaxis, yaxis=yaxis)
⋮----
class TestImageWidget
⋮----
def test_init(self, init_image)
⋮----
img = init_image
⋮----
class TestView_cust
⋮----
def test_init(self, init_view)
⋮----
view = init_view
</file>

<file path="tests/plotting_test/data_viewers_test/viewer2D_test.py">
@fixture
def init_qt(qtbot)
⋮----
def init_data(Ndata=1, uniform=True)
⋮----
Nx = 100
Ny = 200
data_random = np.random.normal(size=(Ny, Nx))
x = np.linspace(0, Nx - 1, Nx)
y = np.linspace(0, Ny - 1, Ny)
⋮----
data_red = 3 * gauss2D(x, 0.2 * Nx, Nx / 5, y, 0.3 * Ny, Ny / 5, 1, 90) * np.sin(x / 5) ** 2
data_green = 24 * gauss2D(x, 0.2 * Nx, Nx / 5, y, 0.3 * Ny, Ny / 5, 1, 0)
data_blue = 10 * gauss2D(x, 0.7 * Nx, Nx / 5, y, 0.2 * Ny, Ny / 5, 1)
data_blue = pg.gaussianFilter(data_blue, (2, 2))
data_list = [data_red, data_green, data_blue]
data = data_mod.DataRaw('raw', data=[data_list[ind] for ind in range(min(3, Ndata))])
⋮----
here = Path(__file__).parent
data_spread = np.load(str(here.joinpath('triangulation_data.npy')))
axes = [data_mod.Axis(data=data_spread[:, 0], index=0, label='x_axis', units='xunits', spread_order=0),
data_list = [data_spread[:, 2] for _ in range(Ndata)]
data = data_mod.DataRaw('raw', distribution='spread', dim='DataND', data=data_list, nav_indexes=(0,),
⋮----
@fixture
def init_viewer2D(qtbot) -> Tuple[Viewer2D, None]
⋮----
form = QtWidgets.QWidget()
prog = Viewer2D()
⋮----
@fixture
def init_prog_show_data(init_viewer2D, distribution='uniform')
⋮----
data = init_data(3, uniform=(distribution == 'uniform'))
⋮----
def create_one_roi(prog, qtbot, roitype='RectROI')
⋮----
index_roi = blocker.args[0]
roi_type = blocker.args[1]
⋮----
roi = prog.view.roi_manager.get_roi_from_index(index_roi)
⋮----
class TestImageFactory
⋮----
@pytest.mark.parametrize('item_type', ['uniform', 'spread'])
    def test_create_image(self, init_qt, item_type)
⋮----
image_item = v2d.image_item_factory(item_type=item_type)
⋮----
@pytest.mark.parametrize('axisOrder', ('row-major', 'col-major'))
    def test_axisorder(self, init_qt, axisOrder)
⋮----
image_item = v2d.image_item_factory('uniform', axisOrder)
⋮----
def test_axisorder(self, init_qt)
⋮----
axisOrder = 'a random order'
⋮----
class TestHistoFactory
⋮----
@pytest.mark.parametrize('gradient', ['red', 'spread'])
    def test_create_histo(self, init_qt, gradient)
⋮----
histo = v2d.histogram_factory(gradient=gradient)
⋮----
def test_wrong_gradient(self, init_qt)
⋮----
histo = v2d.histogram_factory(gradient='yuipof135748f')
⋮----
def test_set_image(self, init_qt)
⋮----
image_item = pg.graphicsItems.ImageItem.ImageItem(np.random.rand(10,50))
histo = v2d.histogram_factory(image_item, gradient='red')
⋮----
class TestData0DWithHistory
⋮----
def test_add_datas_list(self, init_qt)
⋮----
Nsamplesinhisto = 2
data_histo = plot_utils.Data0DWithHistory(Nsamplesinhisto)
dat = [[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]
⋮----
def test_add_datas(self, init_qt)
⋮----
data_histo = plot_utils.Data0DWithHistory()
dat = [dict(CH0=1, CH1=2.), dict(CH0=np.array([1]), CH1=2.), dict(CH0=1, CH1=2.), dict(CH0=1, CH1=2.)]
⋮----
def test_add_datas_and_clear(self, init_qt)
⋮----
class TestViewer2D
⋮----
def test_init(self, init_viewer2D)
⋮----
def test_show_data_triggers_data_to_export_signal(self, init_viewer2D)
⋮----
data = init_data()
⋮----
@pytest.mark.xfail
    def test_show_data_temp(self, init_viewer2D)
⋮----
def test_show_data_setImageredblue(self, init_viewer2D)
⋮----
data = init_data(3)
⋮----
def test_show_data_uniform(self, init_viewer2D)
⋮----
data = init_data(2)
⋮----
def test_show_data_spread(self, init_viewer2D)
⋮----
data = init_data(2, uniform=False)
⋮----
def test_update_data_roi(self, init_prog_show_data)
⋮----
def test_update_data_crosshair(self, init_prog_show_data)
⋮----
class TestAxis
⋮----
@pytest.mark.parametrize('position', ('left', 'bottom', 'right', 'top'))
    def test_axis_label(self, init_viewer2D, position)
⋮----
UNITS= 'myunits'
LABEL = 'mylabel'
⋮----
def test_get_axis_error(self, init_viewer2D)
⋮----
def test_scale_axis(self, init_viewer2D)
⋮----
XSCALING = 0.1
XOFFSET = 24
YSCALING = -2.1
YOFFSET = 0.87
⋮----
xaxis = np.linspace(0., 10., 20)
yaxis = np.linspace(0, 20., 10)
⋮----
class TestActions
⋮----
def test_actionhas(self, init_viewer2D, action)
⋮----
@pytest.mark.parametrize('color', ['red', 'green', 'blue'])
    def test_color_action(self, init_viewer2D, color)
⋮----
def test_histo_action(self, init_viewer2D)
⋮----
def test_histo_autolevel_action(self, init_viewer2D)
⋮----
# the 4.2.x_dev added the autotriggering of this autolevels on first display of data
# prog.view.get_action('histo').trigger()
#
# assert prog.view.histogrammer.get_histogram('red').getLevels() == approx((0, 1.))
# assert prog.view.histogrammer.get_histogram('green').getLevels() == approx((0, 1.))
# assert prog.view.histogrammer.get_histogram('blue').getLevels() == approx((0, 1.))
⋮----
# prog.view.get_action('autolevels').trigger()
⋮----
def test_autolevel_action(self, init_viewer2D)
⋮----
class TestHistogrammer
⋮----
@pytest.mark.parametrize('color', ['red', 'green', 'blue'])
    def test_get_histogram(self, init_viewer2D, color)
⋮----
def test_get_histogram_name_error(self, init_viewer2D)
⋮----
@pytest.mark.parametrize('histo', ['red', 'blue', 'green', 'all'])
@pytest.mark.parametrize('gradient', ['blue', 'green', 'spread'])
    def test_setgradient(self, init_prog_show_data, histo, gradient)
⋮----
class TestROI
⋮----
def test_roi_action(self, init_viewer2D)
⋮----
def test_add_roi(self, init_viewer2D)
⋮----
def test_remove_roi(self, init_viewer2D)
⋮----
def test_update_color_roi(self, init_viewer2D)
⋮----
def test_data_from_roi(self, init_viewer2D)
⋮----
data_to_export: data_mod.DataToExport = blocker.args[0]
⋮----
hlineout = data_to_export.get_data_from_name(f'Hlineout_{ROIManager.roi_format(index_roi)}')
vlineout = data_to_export.get_data_from_name(f'Vlineout_{ROIManager.roi_format(index_roi)}')
intlineout = data_to_export.get_data_from_name(f'Integrated_{ROIManager.roi_format(index_roi)}')
⋮----
def test_data_from_roi_spread(self, init_viewer2D)
⋮----
data = init_data(uniform=False)
⋮----
data_to_export = blocker.args[0]
⋮----
def test_show_roi(self, init_viewer2D)
⋮----
class TestIsocurve
⋮----
def test_isocurve_action(self, init_viewer2D)
⋮----
@pytest.mark.parametrize('histo', ['blue', 'green', 'red'])
@pytest.mark.parametrize('im_source', ['blue', 'green', 'red'])
    def test_isocurve_parent(self, init_viewer2D, im_source, histo)
⋮----
def test_change_isoline(self, init_viewer2D)
⋮----
ISOLEVEL = 0.1
⋮----
class TestAspectRatio
⋮----
def test_aspect_ratio_action(self, init_viewer2D)
⋮----
class TestCrosshair
⋮----
def test_crosshair_action(self, init_viewer2D)
⋮----
prog.view.get_action('roi').trigger()  # will keep lineout_widgets visible so we can check
# if crosshair lineouts are still visible
⋮----
def test_setpos_crosshair(self, init_viewer2D)
⋮----
XCROSS = 24
YCROSS = 75
⋮----
def test_crosshair_doubleclicked(self, init_viewer2D)
⋮----
class TestRoiSelect
⋮----
def test_ROIselect_action(self, init_viewer2D)
⋮----
SIZE = [20, 35]
POS = [45, 123]
⋮----
class TestImageDisplayer
⋮----
def test_get_image(self, init_viewer2D)
⋮----
def test_update_display_items(self, init_viewer2D)
⋮----
class TestModifyImages
⋮----
def test_FlipUD_action(self, init_viewer2D)
⋮----
def test_FlipLR_action(self, init_viewer2D)
⋮----
def test_rotate_action(self, init_viewer2D)
⋮----
class TestMiscellanous
⋮----
def test_double_clicked(self, init_viewer2D)
</file>

<file path="tests/plotting_test/data_viewers_test/viewerND_test.py">
@pytest.fixture
def init_viewernd(qtbot)
⋮----
widget = QtWidgets.QWidget()
prog = ViewerND(widget)
⋮----
class TestSpread
⋮----
def test_linear_spread(self, init_viewernd)
⋮----
viewer = init_viewernd
⋮----
xaxis = data_mod.Axis(label='xaxis', data=np.array([0., 1, 2]), index=0, spread_order=0)
yaxis = data_mod.Axis(label='yaxis', data=np.array([0., 1, 2]), index=0, spread_order=1)
data = np.array([10, 12, 8])
⋮----
data_spread = data_mod.DataRaw(name='spread',
⋮----
def test_2D_spread_1D_signal(self, init_viewernd)
⋮----
# Parameter
param = np.linspace(1, 10, 10)
⋮----
# generating Npts of spread 2D data
N = 200
⋮----
x_axis_array = np.random.randint(-20, 50, size=N)
y_axis_array = np.random.randint(20, 40, size=N)
⋮----
x_axis = data_mod.Axis('xaxis', 'm', data=x_axis_array, index=0, spread_order=0)
y_axis = data_mod.Axis('yaxis', 'm', data=y_axis_array, index=0, spread_order=1)
param_axis = data_mod.Axis('Param', 'eV', data=param, index=1)
⋮----
data_spread_1x2 = []
⋮----
data_list = []
⋮----
data_array = np.squeeze(np.array(data_list))
⋮----
data_spread_1x2 = np.array(data_spread_1x2).T
⋮----
data_2D_1x2_spread = data_mod.DataRaw('data2DSpread', data=[data_spread_1x2],
⋮----
def test_data_5d(init_viewernd)
⋮----
data_array = np.random.rand(5, 11, 15, 6, 20)
dwa = data_mod.DataRaw('random', data=[data_array])
</file>

<file path="tests/plotting_test/utils/lineout_test.py">
# -*- coding: utf-8 -*-
"""
Created the 03/11/2022

@author: Sebastien Weber
"""
⋮----
@pytest.fixture
def init_qt(qtbot)
⋮----
class TestCurveFactory
⋮----
@pytest.mark.parametrize('pen', list(COLORS_DICT.keys())+COLOR_LIST)
    def test_create_curve(self, init_qt, pen)
⋮----
curve = curve_item_factory(pen=pen)
⋮----
def test_wrong_pen(self, init_qt)
⋮----
curve = curve_item_factory(pen='this is not a valid color key')
⋮----
class TestLineoutPlotter
</file>

<file path="tests/plotting_test/utils/plot_utils_test.py">
# -*- coding: utf-8 -*-
"""
Created the 03/11/2022

@author: Sebastien Weber
"""
⋮----
class TestPoint
⋮----
def test_ini(self)
⋮----
coordinates = 12
p = Point(coordinates)
⋮----
coordinates = [12, 34, 21.2, 10]
p = Point(*coordinates)
⋮----
coordinates = (12, 34, 21.2, 10)
⋮----
coordinates = np.array([12, 34, 21.2])
⋮----
def test_operation(self)
⋮----
p1_coordinates = np.array([12, 34, 21.2, 10])
p1 = Point(*p1_coordinates)
⋮----
p2_coordinates = np.array([12, 34, 21.2])
p2 = Point(*p2_coordinates)
⋮----
p2_coordinates = np.array([12, 34, 21.2, 12.5])
p2 = Point(p2_coordinates)
⋮----
p_plus = p1 + p2
⋮----
p_minus = p1 - p2
⋮----
class TestVector
⋮----
def test_init(self)
⋮----
def test_get_sub_segmented_positions()
⋮----
start = 0
stop = 2
step = 0.15
⋮----
points = [Point(start), Point(stop)]
positions = np.array(get_sub_segmented_positions(step, points))
⋮----
points = [Point(0, 0), Point(1, 0), Point(1, -1), Point(0, 0)]
⋮----
class TestInfoFromROI
⋮----
origin = Point(23)
width = 40
height = 25
⋮----
roi_info = RoiInfo(origin)
⋮----
roi_info = RoiInfo(origin, width)
⋮----
def test_create_from_linear_roi(self, qtbot)
⋮----
pos_linear = [-30, 65]
linear_color = (34, 78, 23)
linear_roi = LinearROI(pos=pos_linear)
⋮----
linear_roi_info = RoiInfo.info_from_linear_roi(linear_roi)
⋮----
def test_create_from_rect_roi(self, qtbot)
⋮----
pos = [-30, 65]
size = [78, 5]
color = (34, 78, 23)
roi = RectROI(pos=pos, size=size)
⋮----
roi_info = RoiInfo.info_from_rect_roi(roi)
⋮----
assert roi_info.size[0] == pytest.approx(size[1])  # ROI takes argument as (x, y) while
# roi_info refers to the index of the numpy data (line, column, ...)
⋮----
assert roi_info.size[1] == pytest.approx(size[0])  # ROI takes argument as (x, y) while
⋮----
def test_get_repr(self, qtbot)
</file>

<file path="tests/plotting_test/navigator_test.py">
# -*- coding: utf-8 -*-
"""
Created the 28/03/2023

@author: Sebastien Weber
"""
⋮----
def test_navigator(qtbot)
⋮----
widg = QtWidgets.QWidget()
prog = Navigator(widg)
</file>

<file path="tests/utils/widgets/spinbox_test.py">
def test_spinbox_shortcut(qtbot)
⋮----
spinbox = QSpinBoxWithShortcut()
def print_spinbox(value)
</file>

<file path="tests/utils/config_test.py">
class CustomConfig(config_mod.BaseConfig)
⋮----
"""Main class to deal with configuration values for this plugin"""
config_template_path = None
config_name = f"custom_settings"
⋮----
class TestGetSet
⋮----
def test_get_set_roi_path(self)
⋮----
local_path = config_mod.get_set_local_dir()
roi_path = get_set_roi_path()
⋮----
class TestConfigSaverLoader
⋮----
params = [
⋮----
def test_init(self, qtbot)
⋮----
settings = Parameter.create(name='settings', type='group', children=self.params)
base_path = ['aparent', 'anotherparent']
config = CustomConfig()
saver_loader = ConfigSaverLoader(settings, config, base_path)
⋮----
def test_modified(self, qtbot)
⋮----
value_before = settings['aparent', 'anotherparam', 'max']
</file>

<file path="tests/utils/dock_test.py">
def test_dock_and_label(qtbot)
⋮----
labelv = DockLabel('mysuperlabel', fontSize='25px')
docky = Dock('MysuperDockLogger', fontSize='30px')
dockx = Dock('MysuperDockLoggerx', fontSize='30px')
area = DockArea()
⋮----
f = labelv.font()
</file>

<file path="tests/utils/utils_test.py">

</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# Compiled python modules.
*.pyc

# Byte-compiled / optimized / DLL files
__pycache__/


*.py[cod]
*$py.class

# C extensions
*.so
.idea/*

# Distribution / packaging
.Python
documentation/_*
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

*.idea

# Translations
*.mo
*.pot


# Django stuff:
*.log
local_settings.py
db.sqlite3

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# VS code project settings
.vscode/*

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.idea/workspace.xml

*.iml


.tox
*.h5
!data.h5

*yacctab.py
*lextab.py

.mu_repo
src/pymodaq_gui/QtDesigner_Ressources/QtDesigner_ressources_rc.py.bak
</file>

<file path="CITATION.cff">
cff-version: 1.2.0
message: "If you use this software, please cite it as below."
authors:
- family-names: "Weber"
  given-names: "Sébastien J."
  orcid: "https://orcid.org/0000-0001-8531-5551"
title: "PyMoDAQ: An open-source Python-based software for modular data acquisition"
version: 4.2.4
doi: 10.1063/5.0032116
date-released: 2024-07-15
url: "https://github.com/PyMoDAQ/PyMoDAQ"
preferred-citation:
  type: article
  authors:
  - family-names: "Weber"
    given-names: "Sébastien J."
    orcid: "https://orcid.org/0000-0001-8531-5551"
  doi: "10.1063/5.0032116"
  journal: "Review of Scientific Instruments"
  month: 4
  start: 045104 # First page number
  end: 11 # Last page number
  title: "PyMoDAQ: An open-source Python-based software for modular data acquisition"
  issue: 4
  volume: 92
  year: 2021
</file>

<file path="CREDITS.md">
This software includes images licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0):
- [Checkboxes & Arrow icons from QDarkStyleSheet by Colin Duquesnoy and Daniel Cosmo Pizetta](https://github.com/ColinDuquesnoy/QDarkStyleSheet) | License: CC BY 4.0
</file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2021 Sebastien Weber <sebastien.weber@cemes.fr>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</file>

<file path="MANIFEST.in">
graft src
include README.rst
include LICENSE
</file>

<file path="pyproject.toml">
[build-system]
requires = ["hatchling>=1.9.0", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "pymodaq_gui"
dynamic = [
    "version",
]
description = "User Interface components for PyMoDAQ"
readme = "README.rst"
license = { file="LICENSE" }
requires-python = ">=3.8"
authors = [
    { name = "Sébastien Weber", email = "sebastien.weber@cemes.fr" },
]

classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Environment :: Other Environment",
    "Intended Audience :: Science/Research",
    "License :: OSI Approved :: MIT License",
    "Natural Language :: English",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Scientific/Engineering :: Human Machine Interfaces",
    "Topic :: Scientific/Engineering :: Visualization",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Software Development :: User Interfaces",
]
dependencies = [
    "easydict",
    "importlib_metadata; python_version<\"3.8\"",
    "multipledispatch",
    "numpy < 2.0.0",
    "packaging",
    "pint",
    "pyqtgraph>=0.12",
    "python-dateutil",
    "qtpy",
    "scipy",
    "setuptools>=60",
    "toml",
    "pymodaq_utils>=0.0.8",
    "pymodaq_data>=5.0.13",
]

[project.optional-dependencies]
dev = [
    "hatch", 
    "flake8",
    "h5py",
    "pytest",
    "pytest-cov",
    "pytest-xdist",
    
    "pyqt5",
    "pyqt6",
    "pyside6",
    "pytest-qt",
    "pytest-xvfb",

]


[project.scripts]
h5browser = "pymodaq_gui.h5modules.h5browser:main"
parameter_example = "pymodaq_gui.examples.parameter_ex:main"

[project.urls]
Homepage = "http://pymodaq.cnrs.fr"
Source = "https://github.com/PyMoDAQ/pymodaq_gui"
Tracker = "https://github.com/PyMoDAQ/pymodaq_gui/issues"

[tool.hatch.version]
source = "vcs"
fallback-version = "5.0.0"

[tool.hatch.build.targets.sdist]
include = [
    "/src",
]

[tool.coverage.run]
omit = [
    "*/examples/*",
]
</file>

<file path="README.rst">
PyMoDAQ GUI
###########

.. image:: https://img.shields.io/pypi/v/pymodaq_gui.svg
   :target: https://pypi.org/project/pymodaq_gui/
   :alt: Latest Version

.. image:: https://readthedocs.org/projects/pymodaq/badge/?version=latest
   :target: https://pymodaq.readthedocs.io/en/stable/?badge=latest
   :alt: Documentation Status

.. image:: https://codecov.io/gh/PyMoDAQ/pymodaq_gui/branch/5.0.x_dev/graph/badge.svg?token=dCg4zaWeBa 
 :target: https://codecov.io/gh/PyMoDAQ/pymodaq_gui



+-------------+-------------------+------------------+---------------------+
|  Linux      | PyQt5             | PyQt6            | PySide6             |
+=============+===================+==================+=====================+
| Python 3.9  | |39-linux-pyqt5|  | |39-linux-pyqt6| | |39-linux-pyside6|  |
+-------------+-------------------+------------------+---------------------+
| Python 3.10 | |310-linux-pyqt5| ||310-linux-pyqt6| | |310-linux-pyside6| |
+-------------+-------------------+------------------+---------------------+
| Python 3.11 | |311-linux-pyqt5| ||311-linux-pyqt6| | |311-linux-pyside6| |
+-------------+-------------------+------------------+---------------------+
| Python 3.12 | |312-linux-pyqt5| ||312-linux-pyqt6| | |312-linux-pyside6| |
+-------------+-------------------+------------------+---------------------+


.. |39-linux-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.9_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |39-linux-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.9_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |39-linux-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.9_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |310-linux-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.10_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |310-linux-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.10_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |310-linux-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.10_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |311-linux-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.11_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |311-linux-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.11_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |311-linux-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.11_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |312-linux-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.12_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |312-linux-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.12_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |312-linux-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Linux_3.12_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml


+-------------+---------------------+--------------------+-----------------------+
|  Windows    | PyQt5               | PyQt6              | PySide6               |
+=============+=====================+====================+=======================+
| Python 3.9  | |39-windows-pyqt5|  | |39-windows-pyqt6| | |39-windows-pyside6|  |
+-------------+---------------------+--------------------+-----------------------+
| Python 3.10 | |310-windows-pyqt5| ||310-windows-pyqt6| | |310-windows-pyside6| |
+-------------+---------------------+--------------------+-----------------------+
| Python 3.11 | |311-windows-pyqt5| ||311-windows-pyqt6| | |311-windows-pyside6| |
+-------------+---------------------+--------------------+-----------------------+
| Python 3.12 | |312-windows-pyqt5| ||312-windows-pyqt6| | |312-windows-pyside6| |
+-------------+---------------------+--------------------+-----------------------+

.. |39-windows-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.9_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |39-windows-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.9_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |39-windows-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.9_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |310-windows-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.10_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |310-windows-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.10_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |310-windows-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.10_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |311-windows-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.11_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |311-windows-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.11_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |311-windows-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.11_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |312-windows-pyqt5| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.12_pyqt5.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |312-windows-pyqt6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.12_pyqt6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml

.. |312-windows-pyside6| image:: https://raw.githubusercontent.com/PyMoDAQ/pymodaq_gui/badges/5.0.x_dev/tests_Windows_3.12_pyside6.svg
    :target: https://github.com/PyMoDAQ/pymodaq_gui/actions/workflows/tests.yml


.. figure:: http://pymodaq.cnrs.fr/en/latest/_static/splash.png
   :alt: shortcut

PyMoDAQ__, Modular Data Acquisition with Python, is a set of **python** modules used to interface any kind of
experiments. It simplifies the interaction with detector and actuator hardware to go straight to the data acquisition
of interest.

__ https://pymodaq.readthedocs.io/en/stable/?badge=latest

`PyMoDAQ GUI` is a set of utilities (constants, methods and classes) and graphical components
based on the Qt framework that are used to create high level user interfaces.

It contains both simple components to create GUI but also high level ones, for instance to display data objects
such as the one generated using the `pymodaq_data` package.


For instance, you'll find data viewers available out of the box:

.. figure:: https://pymodaq.cnrs.fr/en/latest/_images/data_femto_fs.png

    Specific GUI component to view and manipulate 2D data.



Published under the MIT FREE SOFTWARE LICENSE

GitHub repo: https://github.com/PyMoDAQ

Documentation: http://pymodaq.cnrs.fr/
</file>

<file path="readthedocs.yml">
# .readthedocs.yml
# Read the Docs configuration file
# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details

# Required
version: 2

build:
  os: "ubuntu-22.04"
  tools:
    python: "3.8"


# Build documentation in the docs/ directory with Sphinx
sphinx:
  configuration: docs/src/conf.py


# Optionally build your docs in additional formats such as PDF and ePub
formats: all

# Optionally set the version of Python and requirements required to build your docs
python:
  install:
    - requirements: docs/requirements.txt
    - method: pip
      path: .
</file>

</files>
