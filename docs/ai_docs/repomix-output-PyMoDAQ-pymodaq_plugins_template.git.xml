This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    python-publish.yml
    Test.yml
    Testbase.yml
src/
  pymodaq_plugins_template/
    app/
      custom_app_template.py
    daq_move_plugins/
      __init__.py
      daq_move_Template.py
    daq_viewer_plugins/
      plugins_0D/
        __init__.py
        daq_0Dviewer_Template.py
      plugins_1D/
        __init__.py
        daq_1Dviewer_Template.py
      plugins_2D/
        __init__.py
        daq_2Dviewer_Template.py
      plugins_ND/
        __init__.py
      __init__.py
    exporters/
      __init__.py
    extensions/
      __init__.py
      custom_extension_template.py
    models/
      __init__.py
      PIDModelTemplate.py
    resources/
      config_template.toml
      VERSION
    scanners/
      __init__.py
    __init__.py
    utils.py
tests/
  test_plugin_package_structure.py
.gitattributes
.gitignore
LICENSE
MANIFEST.in
plugin_info.toml
README.rst
setup.py
tox.ini
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/python-publish.yml">
# This workflow will upload a Python Package using Twine when a release is created
# For more information see: https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#publishing-to-package-registries

name: Upload Python Package

on:
  release:
    types: [created]

jobs:
  deploy:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install setuptools wheel twine toml "pymodaq>=4.1.0" pyqt5

    - name: create local pymodaq folder and setting permissions
      run: |
        sudo mkdir /etc/.pymodaq
        sudo chmod uo+rw /etc/.pymodaq
        
    - name: Build and publish
      env:
        TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}
        TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}
      run: |
        python setup.py sdist bdist_wheel
        twine check dist/*
        twine upload dist/*
</file>

<file path=".github/workflows/Test.yml">
name: 'Tests'

on: [push]

jobs:
  call_workflow:
    uses: ./.github/workflows/Testbase.yml
    with:
      python: '3.10'
      qt5: 'pyqt5'
</file>

<file path=".github/workflows/Testbase.yml">
name: Base

on:
    workflow_call:
      inputs:
        python:
          required: true
          type: string
        qt5:
          required: true
          type: string

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      DISPLAY: ':99.0'
      QT_DEBUG_PLUGINS: 1
    steps:
      - name: Set up Python ${{ inputs.python }}
        uses: actions/checkout@v3
      - name: Install dependencies
        uses: actions/setup-python@v4
        with:
          python-version: ${{ inputs.python }}
      - name: Install package
        run: |
          sudo apt install libxkbcommon-x11-0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 libxcb-xinerama0 libxcb-xfixes0 x11-utils
          python -m pip install --upgrade pip
          export QT_DEBUG_PLUGINS=1
          pip install flake8 pytest pytest-cov pytest-qt pytest-xdist pytest-xvfb setuptools wheel numpy h5py ${{ inputs.qt5 }} toml
          pip install pymodaq
          pip install -e .
      - name: create local pymodaq folder and setting permissions
        run: |
          sudo mkdir /etc/.pymodaq
          sudo chmod uo+rw /etc/.pymodaq
      - name: Linting with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=src/pymodaq/resources/QtDesigner_Ressources,docs
      - name: Test with pytest
        run: |
          pytest -n auto
</file>

<file path="src/pymodaq_plugins_template/app/custom_app_template.py">
# todo: replace here *pymodaq_plugins_template* by your plugin package name
⋮----
logger = set_logger(get_module_name(__file__))
⋮----
main_config = Config()
plugin_config = PluginConfig()
⋮----
# todo: modify the name of this class to reflect its application and change the name in the main
# method at the end of the script
class CustomAppTemplate(gutils.CustomApp)
⋮----
# todo: if you wish to create custom Parameter and corresponding widgets. These will be
# automatically added as children of self.settings. Morevover, the self.settings_tree will
# render the widgets in a Qtree. If you wish to see it in your app, add is into a Dock
params = []
⋮----
def __init__(self, parent: gutils.DockArea)
⋮----
def setup_docks(self)
⋮----
"""Mandatory method to be subclassed to setup the docks layout

        Examples
        --------
        >>>self.docks['ADock'] = gutils.Dock('ADock name')
        >>>self.dockarea.addDock(self.docks['ADock'])
        >>>self.docks['AnotherDock'] = gutils.Dock('AnotherDock name')
        >>>self.dockarea.addDock(self.docks['AnotherDock'''], 'bottom', self.docks['ADock'])

        See Also
        --------
        pyqtgraph.dockarea.Dock
        """
# todo: create docks and add them here to hold your widgets
# reminder, the attribute self.settings_tree will  render the widgets in a Qtree.
# If you wish to see it in your app, add is into a Dock
⋮----
def setup_actions(self)
⋮----
"""Method where to create actions to be subclassed. Mandatory

        Examples
        --------
        >>> self.add_action('quit', 'Quit', 'close2', "Quit program")
        >>> self.add_action('grab', 'Grab', 'camera', "Grab from camera", checkable=True)
        >>> self.add_action('load', 'Load', 'Open', "Load target file (.h5, .png, .jpg) or data from camera"
            , checkable=False)
        >>> self.add_action('save', 'Save', 'SaveAs', "Save current data", checkable=False)

        See Also
        --------
        ActionManager.add_action
        """
⋮----
def connect_things(self)
⋮----
"""Connect actions and/or other widgets signal to methods"""
⋮----
def setup_menu(self)
⋮----
"""Non mandatory method to be subclassed in order to create a menubar

        create menu for actions contained into the self._actions, for instance:

        Examples
        --------
        >>>file_menu = self.mainwindow.menuBar().addMenu('File')
        >>>self.affect_to('load', file_menu)
        >>>self.affect_to('save', file_menu)

        >>>file_menu.addSeparator()
        >>>self.affect_to('quit', file_menu)

        See Also
        --------
        pymodaq.utils.managers.action_manager.ActionManager
        """
# todo create and populate menu using actions defined above in self.setup_actions
⋮----
def value_changed(self, param)
⋮----
""" Actions to perform when one of the param's value in self.settings is changed from the
        user interface

        For instance:
        if param.name() == 'do_something':
            if param.value():
                print('Do something')
                self.settings.child('main_settings', 'something_done').setValue(False)

        Parameters
        ----------
        param: (Parameter) the parameter whose value just changed
        """
⋮----
def main()
⋮----
app = mkQApp('CustomApp')
⋮----
mainwindow = QtWidgets.QMainWindow()
dockarea = gutils.DockArea()
⋮----
# todo: change the name here to be the same as your app class
prog = CustomAppTemplate(dockarea)
</file>

<file path="src/pymodaq_plugins_template/daq_move_plugins/__init__.py">
logger = set_logger('move_plugins', add_to_console=False)
</file>

<file path="src/pymodaq_plugins_template/daq_move_plugins/daq_move_Template.py">
DataActuator  # common set of parameters for all actuators
from pymodaq.utils.daq_utils import ThreadCommand # object used to send info back to the main thread
⋮----
class PythonWrapperOfYourInstrument
⋮----
#  TODO Replace this fake class with the import of the real python wrapper of your instrument
⋮----
# TODO:
# (1) change the name of the following class to DAQ_Move_TheNameOfYourChoice
# (2) change the name of this file to daq_move_TheNameOfYourChoice ("TheNameOfYourChoice" should be the SAME
#     for the class name and the file name.)
# (3) this file should then be put into the right folder, namely IN THE FOLDER OF THE PLUGIN YOU ARE DEVELOPING:
#     pymodaq_plugins_my_plugin/daq_move_plugins
class DAQ_Move_Template(DAQ_Move_base)
⋮----
""" Instrument plugin class for an actuator.
    
    This object inherits all functionalities to communicate with PyMoDAQ’s DAQ_Move module through inheritance via
    DAQ_Move_base. It makes a bridge between the DAQ_Move module and the Python wrapper of a particular instrument.

    TODO Complete the docstring of your plugin with:
        * The set of controllers and actuators that should be compatible with this instrument plugin.
        * With which instrument and controller it has been tested.
        * The version of PyMoDAQ during the test.
        * The version of the operating system.
        * Installation instructions: what manufacturer’s drivers should be installed to make it run?

    Attributes:
    -----------
    controller: object
        The particular object that allow the communication with the hardware, in general a python wrapper around the
         hardware library.
         
    # TODO add your particular attributes here if any

    """
is_multiaxes = False  # TODO for your plugin set to True if this plugin is controlled for a multiaxis controller
_axis_names: Union[List[str], Dict[str, int]] = ['Axis1', 'Axis2']  # TODO for your plugin: complete the list
_controller_units: Union[str, List[str]] = 'mm'  # TODO for your plugin: put the correct unit here, it could be
# TODO  a single str (the same one is applied to all axes) or a list of str (as much as the number of axes)
_epsilon: Union[float, List[float]] = 0.1  # TODO replace this by a value that is correct depending on your controller
# TODO it could be a single float of a list of float (as much as the number of axes)
data_actuator_type = DataActuatorType.DataActuator  # wether you use the new data style for actuator otherwise set this
# as  DataActuatorType.float  (or entirely remove the line)
⋮----
params = [   # TODO for your custom plugin: elements to be added here as dicts in order to control your custom stage
# _epsilon is the initial default value for the epsilon parameter allowing pymodaq to know if the controller reached
# the target value. It is the developer responsibility to put here a meaningful value
⋮----
def ini_attributes(self)
⋮----
#  TODO declare the type of the wrapper (and assign it to self.controller) you're going to use for easy
#  autocompletion
⋮----
#TODO declare here attributes you want/need to init with a default value
⋮----
def get_actuator_value(self)
⋮----
"""Get the current value from the hardware with scaling conversion.

        Returns
        -------
        float: The position obtained after scaling conversion.
        """
## TODO for your custom plugin
raise NotImplemented  # when writing your own plugin remove this line
pos = DataActuator(data=self.controller.your_method_to_get_the_actuator_value())  # when writing your own plugin replace this line
pos = self.get_position_with_scaling(pos)
⋮----
def user_condition_to_reach_target(self) -> bool
⋮----
""" Implement a condition for exiting the polling mechanism and specifying that the
        target value has been reached

       Returns
        -------
        bool: if True, PyMoDAQ considers the target value has been reached
        """
# TODO either delete this method if the usual polling is fine with you, but if need you can
#  add here some other condition to be fullfilled either a completely new one or
#  using or/and operations between the epsilon_bool and some other custom booleans
#  for a usage example see DAQ_Move_brushlessMotor from the Thorlabs plugin
⋮----
def close(self)
⋮----
"""Terminate the communication protocol"""
⋮----
#  self.controller.your_method_to_terminate_the_communication()  # when writing your own plugin replace this line
⋮----
def commit_settings(self, param: Parameter)
⋮----
"""Apply the consequences of a change of value in the detector settings

        Parameters
        ----------
        param: Parameter
            A given parameter (within detector_settings) whose value has been changed by the user
        """
⋮----
# do this only if you can and if the units are not known beforehand, for instance
# if the motors connected to the controller are of different type (mm, µm, nm, , etc...)
# see BrushlessDCMotor from the thorlabs plugin for an exemple
⋮----
def ini_stage(self, controller=None)
⋮----
"""Actuator communication initialization

        Parameters
        ----------
        controller: (object)
            custom object of a PyMoDAQ plugin (Slave case). None if only one actuator by controller (Master case)

        Returns
        -------
        info: str
        initialized: bool
            False if initialization failed otherwise True
        """
raise NotImplemented  # TODO when writing your own plugin remove this line and modify the ones below
self.ini_stage_init(slave_controller=controller)  # will be useful when controller is slave
⋮----
if self.is_master:  # is needed when controller is master
self.controller = PythonWrapperOfYourInstrument(arg1, arg2, ...) #  arguments for instantiation!)
# todo: enter here whatever is needed for your controller initialization and eventual
#  opening of the communication channel
⋮----
info = "Whatever info you want to log"
initialized = self.controller.a_method_or_atttribute_to_check_if_init()  # todo
⋮----
def move_abs(self, value: DataActuator)
⋮----
""" Move the actuator to the absolute target defined by value

        Parameters
        ----------
        value: (float) value of the absolute target positioning
        """
⋮----
value = self.check_bound(value)  #if user checked bounds, the defined bounds are applied here
⋮----
value = self.set_position_with_scaling(value)  # apply scaling if the user specified one
⋮----
self.controller.your_method_to_set_an_absolute_value(value.value())  # when writing your own plugin replace this line
⋮----
def move_rel(self, value: DataActuator)
⋮----
""" Move the actuator to the relative target actuator value defined by value

        Parameters
        ----------
        value: (float) value of the relative target positioning
        """
value = self.check_bound(self.current_position + value) - self.current_position
⋮----
value = self.set_position_relative_with_scaling(value)
⋮----
self.controller.your_method_to_set_a_relative_value(value.value())  # when writing your own plugin replace this line
⋮----
def move_home(self)
⋮----
"""Call the reference method of the controller"""
⋮----
self.controller.your_method_to_get_to_a_known_reference()  # when writing your own plugin replace this line
⋮----
def stop_motion(self)
⋮----
"""Stop the actuator and emits move_done signal"""
⋮----
## TODO for your custom plugin
raise NotImplemented  # when writing your own plugin remove this line
self.controller.your_method_to_stop_positioning()  # when writing your own plugin replace this line
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/plugins_0D/__init__.py">
logger = set_logger('viewer0D_plugins', add_to_console=False)
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/plugins_0D/daq_0Dviewer_Template.py">
class PythonWrapperOfYourInstrument
⋮----
#  TODO Replace this fake class with the import of the real python wrapper of your instrument
⋮----
# TODO:
# (1) change the name of the following class to DAQ_0DViewer_TheNameOfYourChoice
# (2) change the name of this file to daq_0Dviewer_TheNameOfYourChoice ("TheNameOfYourChoice" should be the SAME
#     for the class name and the file name.)
# (3) this file should then be put into the right folder, namely IN THE FOLDER OF THE PLUGIN YOU ARE DEVELOPING:
#     pymodaq_plugins_my_plugin/daq_viewer_plugins/plugins_0D
class DAQ_0DViewer_Template(DAQ_Viewer_base)
⋮----
""" Instrument plugin class for a OD viewer.
    
    This object inherits all functionalities to communicate with PyMoDAQ’s DAQ_Viewer module through inheritance via
    DAQ_Viewer_base. It makes a bridge between the DAQ_Viewer module and the Python wrapper of a particular instrument.

    TODO Complete the docstring of your plugin with:
        * The set of instruments that should be compatible with this instrument plugin.
        * With which instrument it has actually been tested.
        * The version of PyMoDAQ during the test.
        * The version of the operating system.
        * Installation instructions: what manufacturer’s drivers should be installed to make it run?

    Attributes:
    -----------
    controller: object
        The particular object that allow the communication with the hardware, in general a python wrapper around the
         hardware library.
         
    # TODO add your particular attributes here if any

    """
params = comon_parameters+[
⋮----
## TODO for your custom plugin: elements to be added here as dicts in order to control your custom stage
⋮----
def ini_attributes(self)
⋮----
#  TODO declare the type of the wrapper (and assign it to self.controller) you're going to use for easy
#  autocompletion
⋮----
#TODO declare here attributes you want/need to init with a default value
⋮----
def commit_settings(self, param: Parameter)
⋮----
"""Apply the consequences of a change of value in the detector settings

        Parameters
        ----------
        param: Parameter
            A given parameter (within detector_settings) whose value has been changed by the user
        """
## TODO for your custom plugin
⋮----
self.controller.your_method_to_apply_this_param_change()  # when writing your own plugin replace this line
#        elif ...
##
⋮----
def ini_detector(self, controller=None)
⋮----
"""Detector communication initialization

        Parameters
        ----------
        controller: (object)
            custom object of a PyMoDAQ plugin (Slave case). None if only one actuator/detector by controller
            (Master case)

        Returns
        -------
        info: str
        initialized: bool
            False if initialization failed otherwise True
        """
⋮----
raise NotImplemented  # TODO when writing your own plugin remove this line and modify the one below
⋮----
self.controller = PythonWrapperOfYourInstrument()  #instantiate you driver with whatever arguments are needed
self.controller.open_communication() # call eventual methods
⋮----
# TODO for your custom plugin (optional) initialize viewers panel with the future type of data
⋮----
info = "Whatever info you want to log"
initialized = self.controller.a_method_or_atttribute_to_check_if_init()  # TODO
⋮----
def close(self)
⋮----
"""Terminate the communication protocol"""
⋮----
raise NotImplemented  # when writing your own plugin remove this line
#  self.controller.your_method_to_terminate_the_communication()  # when writing your own plugin replace this line
⋮----
def grab_data(self, Naverage=1, **kwargs)
⋮----
"""Start a grab from the detector

        Parameters
        ----------
        Naverage: int
            Number of hardware averaging (if hardware averaging is possible, self.hardware_averaging should be set to
            True in class preamble and you should code this implementation)
        kwargs: dict
            others optionals arguments
        """
## TODO for your custom plugin: you should choose EITHER the synchrone or the asynchrone version following
⋮----
# synchrone version (blocking function)
⋮----
data_tot = self.controller.your_method_to_start_a_grab_snap()
⋮----
#########################################################
⋮----
# asynchrone version (non-blocking function with callback)
⋮----
self.controller.your_method_to_start_a_grab_snap(self.callback)  # when writing your own plugin replace this line
⋮----
def callback(self)
⋮----
"""optional asynchrone method called when the detector has finished its acquisition of data"""
data_tot = self.controller.your_method_to_get_data_from_buffer()
⋮----
def stop(self)
⋮----
"""Stop the current grab hardware wise if necessary"""
⋮----
self.controller.your_method_to_stop_acquisition()  # when writing your own plugin replace this line
⋮----
##############################
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/plugins_1D/__init__.py">
logger = set_logger('viewer1D_plugins', add_to_console=False)
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/plugins_1D/daq_1Dviewer_Template.py">
class PythonWrapperOfYourInstrument
⋮----
#  TODO Replace this fake class with the import of the real python wrapper of your instrument
⋮----
# TODO:
# (1) change the name of the following class to DAQ_1DViewer_TheNameOfYourChoice
# (2) change the name of this file to daq_1Dviewer_TheNameOfYourChoice ("TheNameOfYourChoice" should be the SAME
#     for the class name and the file name.)
# (3) this file should then be put into the right folder, namely IN THE FOLDER OF THE PLUGIN YOU ARE DEVELOPING:
#     pymodaq_plugins_my_plugin/daq_viewer_plugins/plugins_1D
class DAQ_1DViewer_Template(DAQ_Viewer_base)
⋮----
""" Instrument plugin class for a 1D viewer.
    
    This object inherits all functionalities to communicate with PyMoDAQ’s DAQ_Viewer module through inheritance via
    DAQ_Viewer_base. It makes a bridge between the DAQ_Viewer module and the Python wrapper of a particular instrument.

    TODO Complete the docstring of your plugin with:
        * The set of instruments that should be compatible with this instrument plugin.
        * With which instrument it has actually been tested.
        * The version of PyMoDAQ during the test.
        * The version of the operating system.
        * Installation instructions: what manufacturer’s drivers should be installed to make it run?

    Attributes:
    -----------
    controller: object
        The particular object that allow the communication with the hardware, in general a python wrapper around the
         hardware library.
         
    # TODO add your particular attributes here if any

    """
params = comon_parameters+[
⋮----
## TODO for your custom plugin
# elements to be added here as dicts in order to control your custom stage
############
⋮----
def ini_attributes(self)
⋮----
#  TODO declare the type of the wrapper (and assign it to self.controller) you're going to use for easy
#  autocompletion
⋮----
# TODO declare here attributes you want/need to init with a default value
⋮----
def commit_settings(self, param: Parameter)
⋮----
"""Apply the consequences of a change of value in the detector settings

        Parameters
        ----------
        param: Parameter
            A given parameter (within detector_settings) whose value has been changed by the user
        """
⋮----
#        elif ...
##
⋮----
def ini_detector(self, controller=None)
⋮----
"""Detector communication initialization

        Parameters
        ----------
        controller: (object)
            custom object of a PyMoDAQ plugin (Slave case). None if only one actuator/detector by controller
            (Master case)

        Returns
        -------
        info: str
        initialized: bool
            False if initialization failed otherwise True
        """
⋮----
raise NotImplemented  # TODO when writing your own plugin remove this line and modify the one below
⋮----
self.controller = PythonWrapperOfYourInstrument()  #instantiate you driver with whatever arguments are needed
self.controller.open_communication() # call eventual methods
⋮----
# get the x_axis (you may want to to this also in the commit settings if x_axis may have changed
data_x_axis = self.controller.your_method_to_get_the_x_axis()  # if possible
⋮----
# TODO for your custom plugin. Initialize viewers pannel with the future type of data
⋮----
info = "Whatever info you want to log"
initialized = True
⋮----
def close(self)
⋮----
"""Terminate the communication protocol"""
⋮----
raise NotImplemented  # when writing your own plugin remove this line
#  self.controller.your_method_to_terminate_the_communication()  # when writing your own plugin replace this line
⋮----
def grab_data(self, Naverage=1, **kwargs)
⋮----
"""Start a grab from the detector

        Parameters
        ----------
        Naverage: int
            Number of hardware averaging (if hardware averaging is possible, self.hardware_averaging should be set to
            True in class preamble and you should code this implementation)
        kwargs: dict
            others optionals arguments
        """
## TODO for your custom plugin: you should choose EITHER the synchrone or the asynchrone version following
⋮----
##synchrone version (blocking function)
data_tot = self.controller.your_method_to_start_a_grab_snap()
⋮----
##asynchrone version (non-blocking function with callback)
⋮----
#########################################################
⋮----
def callback(self)
⋮----
"""optional asynchrone method called when the detector has finished its acquisition of data"""
data_tot = self.controller.your_method_to_get_data_from_buffer()
⋮----
def stop(self)
⋮----
"""Stop the current grab hardware wise if necessary"""
⋮----
self.controller.your_method_to_stop_acquisition()  # when writing your own plugin replace this line
⋮----
##############################
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/plugins_2D/__init__.py">
logger = set_logger('viewer2D_plugins', add_to_console=False)
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/plugins_2D/daq_2Dviewer_Template.py">
class PythonWrapperOfYourInstrument
⋮----
#  TODO Replace this fake class with the import of the real python wrapper of your instrument
⋮----
# TODO:
# (1) change the name of the following class to DAQ_2DViewer_TheNameOfYourChoice
# (2) change the name of this file to daq_2Dviewer_TheNameOfYourChoice ("TheNameOfYourChoice" should be the SAME
#     for the class name and the file name.)
# (3) this file should then be put into the right folder, namely IN THE FOLDER OF THE PLUGIN YOU ARE DEVELOPING:
#     pymodaq_plugins_my_plugin/daq_viewer_plugins/plugins_2D
class DAQ_2DViewer_Template(DAQ_Viewer_base)
⋮----
""" Instrument plugin class for a 2D viewer.
    
    This object inherits all functionalities to communicate with PyMoDAQ’s DAQ_Viewer module through inheritance via
    DAQ_Viewer_base. It makes a bridge between the DAQ_Viewer module and the Python wrapper of a particular instrument.

    TODO Complete the docstring of your plugin with:
        * The set of instruments that should be compatible with this instrument plugin.
        * With which instrument it has actually been tested.
        * The version of PyMoDAQ during the test.
        * The version of the operating system.
        * Installation instructions: what manufacturer’s drivers should be installed to make it run?

    Attributes:
    -----------
    controller: object
        The particular object that allow the communication with the hardware, in general a python wrapper around the
         hardware library.
         
    # TODO add your particular attributes here if any

    """
params = comon_parameters + [
⋮----
## TODO for your custom plugin
# elements to be added here as dicts in order to control your custom stage
############
⋮----
def ini_attributes(self)
⋮----
#  TODO declare the type of the wrapper (and assign it to self.controller) you're going to use for easy
#  autocompletion
⋮----
# TODO declare here attributes you want/need to init with a default value
⋮----
def commit_settings(self, param: Parameter)
⋮----
"""Apply the consequences of a change of value in the detector settings

        Parameters
        ----------
        param: Parameter
            A given parameter (within detector_settings) whose value has been changed by the user
        """
# TODO for your custom plugin
⋮----
#elif ...
⋮----
def ini_detector(self, controller=None)
⋮----
"""Detector communication initialization

        Parameters
        ----------
        controller: (object)
            custom object of a PyMoDAQ plugin (Slave case). None if only one actuator/detector by controller
            (Master case)

        Returns
        -------
        info: str
        initialized: bool
            False if initialization failed otherwise True
        """
raise NotImplemented  # TODO when writing your own plugin remove this line and modify the one below
⋮----
self.controller = PythonWrapperOfYourInstrument()  #instantiate you driver with whatever arguments are needed
self.controller.open_communication() # call eventual methods
⋮----
# get the x_axis (you may want to to this also in the commit settings if x_axis may have changed
data_x_axis = self.controller.your_method_to_get_the_x_axis()  # if possible
⋮----
# get the y_axis (you may want to to this also in the commit settings if y_axis may have changed
data_y_axis = self.controller.your_method_to_get_the_y_axis()  # if possible
⋮----
## TODO for your custom plugin. Initialize viewers pannel with the future type of data
⋮----
info = "Whatever info you want to log"
initialized = True
⋮----
def close(self)
⋮----
"""Terminate the communication protocol"""
⋮----
raise NotImplemented  # when writing your own plugin remove this line
#  self.controller.your_method_to_terminate_the_communication()  # when writing your own plugin replace this line
⋮----
def grab_data(self, Naverage=1, **kwargs)
⋮----
"""Start a grab from the detector

        Parameters
        ----------
        Naverage: int
            Number of hardware averaging (if hardware averaging is possible, self.hardware_averaging should be set to
            True in class preamble and you should code this implementation)
        kwargs: dict
            others optionals arguments
        """
## TODO for your custom plugin: you should choose EITHER the synchrone or the asynchrone version following
⋮----
##synchrone version (blocking function)
data_tot = self.controller.your_method_to_start_a_grab_snap()
⋮----
##asynchrone version (non-blocking function with callback)
⋮----
#########################################################
⋮----
def callback(self)
⋮----
"""optional asynchrone method called when the detector has finished its acquisition of data"""
data_tot = self.controller.your_method_to_get_data_from_buffer()
⋮----
def stop(self)
⋮----
"""Stop the current grab hardware wise if necessary"""
⋮----
self.controller.your_method_to_stop_acquisition()  # when writing your own plugin replace this line
⋮----
##############################
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/plugins_ND/__init__.py">
logger = set_logger('viewerND_plugins', add_to_console=False)
</file>

<file path="src/pymodaq_plugins_template/daq_viewer_plugins/__init__.py">

</file>

<file path="src/pymodaq_plugins_template/exporters/__init__.py">
# -*- coding: utf-8 -*-
"""
Created the 01/06/2023

@author: Sebastien Weber
"""
</file>

<file path="src/pymodaq_plugins_template/extensions/__init__.py">
# -*- coding: utf-8 -*-
"""
Created the 01/06/2023

@author: Sebastien Weber
"""
</file>

<file path="src/pymodaq_plugins_template/extensions/custom_extension_template.py">
# todo: replace here *pymodaq_plugins_template* by your plugin package name
⋮----
logger = set_logger(get_module_name(__file__))
⋮----
main_config = Config()
plugin_config = PluginConfig()
⋮----
# todo: modify this as you wish
EXTENSION_NAME = 'MY_EXTENSION_NAME'  # the name that will be displayed in the extension list in the
# dashboard
CLASS_NAME = 'CustomExtensionTemplate'  # this should be the name of your class defined below
⋮----
# todo: modify the name of this class to reflect its application and change the name in the main
# method at the end of the script
class CustomExtensionTemplate(gutils.CustomApp)
⋮----
# todo: if you wish to create custom Parameter and corresponding widgets. These will be
# automatically added as children of self.settings. Morevover, the self.settings_tree will
# render the widgets in a Qtree. If you wish to see it in your app, add is into a Dock
params = []
⋮----
def __init__(self, parent: gutils.DockArea, dashboard)
⋮----
# info: in an extension, if you want to interact with ControlModules you have to use the
# object: self.modules_manager which is a ModulesManager instance from the dashboard
⋮----
def setup_docks(self)
⋮----
"""Mandatory method to be subclassed to setup the docks layout

        Examples
        --------
        >>>self.docks['ADock'] = gutils.Dock('ADock name')
        >>>self.dockarea.addDock(self.docks['ADock'])
        >>>self.docks['AnotherDock'] = gutils.Dock('AnotherDock name')
        >>>self.dockarea.addDock(self.docks['AnotherDock'''], 'bottom', self.docks['ADock'])

        See Also
        --------
        pyqtgraph.dockarea.Dock
        """
# todo: create docks and add them here to hold your widgets
# reminder, the attribute self.settings_tree will  render the widgets in a Qtree.
# If you wish to see it in your app, add is into a Dock
⋮----
def setup_actions(self)
⋮----
"""Method where to create actions to be subclassed. Mandatory

        Examples
        --------
        >>> self.add_action('quit', 'Quit', 'close2', "Quit program")
        >>> self.add_action('grab', 'Grab', 'camera', "Grab from camera", checkable=True)
        >>> self.add_action('load', 'Load', 'Open', "Load target file (.h5, .png, .jpg) or data from camera"
            , checkable=False)
        >>> self.add_action('save', 'Save', 'SaveAs', "Save current data", checkable=False)

        See Also
        --------
        ActionManager.add_action
        """
⋮----
def connect_things(self)
⋮----
"""Connect actions and/or other widgets signal to methods"""
⋮----
def setup_menu(self)
⋮----
"""Non mandatory method to be subclassed in order to create a menubar

        create menu for actions contained into the self._actions, for instance:

        Examples
        --------
        >>>file_menu = self.mainwindow.menuBar().addMenu('File')
        >>>self.affect_to('load', file_menu)
        >>>self.affect_to('save', file_menu)

        >>>file_menu.addSeparator()
        >>>self.affect_to('quit', file_menu)

        See Also
        --------
        pymodaq.utils.managers.action_manager.ActionManager
        """
# todo create and populate menu using actions defined above in self.setup_actions
⋮----
def value_changed(self, param)
⋮----
""" Actions to perform when one of the param's value in self.settings is changed from the
        user interface

        For instance:
        if param.name() == 'do_something':
            if param.value():
                print('Do something')
                self.settings.child('main_settings', 'something_done').setValue(False)

        Parameters
        ----------
        param: (Parameter) the parameter whose value just changed
        """
⋮----
def main()
⋮----
app = mkQApp(EXTENSION_NAME)
⋮----
preset_file_name = plugin_config('presets', f'preset_for_{CLASS_NAME.lower()}')
</file>

<file path="src/pymodaq_plugins_template/models/__init__.py">
# -*- coding: utf-8 -*-
"""
Created the 01/06/2023

@author: Sebastien Weber
"""
</file>

<file path="src/pymodaq_plugins_template/models/PIDModelTemplate.py">
def some_function_to_convert_the_pid_outputs(outputs: List[float], dt: float, stab=True)
⋮----
""" Should be replaced here or in the model class to process the outputs """
⋮----
def some_function_to_convert_the_data(measurements: DataToExport)
⋮----
""" Should be replaced here or in the model class to process the measurement """
a = 0
b = 1
⋮----
class PIDModelTemplate(PIDModelGeneric)
⋮----
limits = dict(max=dict(state=False, value=100),
konstants = dict(kp=0.1, ki=0.000, kd=0.0000)
⋮----
Nsetpoints = 2  # number of setpoints
setpoint_ini = [128, 128]  # number and values of initial setpoints
setpoints_names = ['Xaxis', 'Yaxis']  # number and names of setpoints
⋮----
actuators_name = ["Xpiezo", "Ypiezo"]  # names of actuator's control modules involved in the PID
detectors_name = ['Camera']  # names of detector's control modules involved in the PID
⋮----
params = []  # list of dict to initialize specific Parameters
⋮----
def __init__(self, pid_controller)
⋮----
def update_settings(self, param)
⋮----
"""
        Get a parameter instance whose value has been modified by a user on the UI
        Parameters
        ----------
        param: (Parameter) instance of Parameter object
        """
⋮----
def ini_model(self)
⋮----
# add here other specifics initialization if needed
⋮----
def convert_input(self, measurements: DataToExport)
⋮----
"""
        Convert the measurements in the units to be fed to the PID (same dimensionality as the setpoint)
        Parameters
        ----------
        measurements: DataToExport
            Data from the declared detectors from which the model extract a value of the same units as the setpoint

        Returns
        -------
        InputFromDetector: the converted input in the setpoints units

        """
⋮----
def convert_output(self, outputs: List[float], dt: float, stab=True)
⋮----
"""
        Convert the output of the PID in units to be fed into the actuator
        Parameters
        ----------
        outputs: List of float
            output value from the PID from which the model extract a value of the same units as the actuator
        dt: float
            Ellapsed time since the last call to this function
        stab: bool

        Returns
        -------
        OutputToActuator: the converted output

        """
outputs = some_function_to_convert_the_pid_outputs(outputs, dt, stab)
⋮----
main("BeamSteeringMockNoModel.xml")  # some preset configured with the right actuators and detectors
</file>

<file path="src/pymodaq_plugins_template/resources/config_template.toml">
#this is the configuration file of the plugin
</file>

<file path="src/pymodaq_plugins_template/resources/VERSION">
0.0.1
</file>

<file path="src/pymodaq_plugins_template/scanners/__init__.py">
# -*- coding: utf-8 -*-
"""
Created the 01/06/2023

@author: Sebastien Weber
"""
</file>

<file path="src/pymodaq_plugins_template/__init__.py">
from pymodaq.utils.logger import set_logger  # to be imported by other modules.
⋮----
config = Config()
⋮----
__version__ = fvers.read().strip()
</file>

<file path="src/pymodaq_plugins_template/utils.py">
# -*- coding: utf-8 -*-
"""
Created the 31/08/2023

@author: Sebastien Weber
"""
⋮----
class Config(BaseConfig)
⋮----
"""Main class to deal with configuration values for this plugin"""
config_template_path = Path(__file__).parent.joinpath('resources/config_template.toml')
config_name = f"config_{__package__.split('pymodaq_plugins_')[1]}"
</file>

<file path="tests/test_plugin_package_structure.py">
# -*- coding: utf-8 -*-
"""
Created the 17/10/2023

@author: Sebastien Weber
"""
⋮----
MANDATORY_MOVE_METHODS = ['ini_attributes', 'get_actuator_value', 'close', 'commit_settings',
MANDATORY_VIEWER_METHODS = ['ini_attributes', 'grab_data', 'close', 'commit_settings',
⋮----
def get_package_name()
⋮----
here = Path(__file__).parent
package_name = here.parent.stem
⋮----
def get_move_plugins()
⋮----
pkg_name = get_package_name()
⋮----
move_mod = importlib.import_module(f'{pkg_name}.daq_move_plugins')
plugin_list = [mod for mod in [mod[1] for mod in
⋮----
plugin_list = []
move_mod = None
⋮----
def get_viewer_plugins(dim='0D')
⋮----
viewer_mod = importlib.import_module(f'{pkg_name}.daq_viewer_plugins.plugins_{dim}')
⋮----
viewer_mod = None
⋮----
def test_package_name_ok()
⋮----
def test_imports()
⋮----
mod = importlib.import_module(pkg_name)
⋮----
move_mod = importlib.import_module(f'{pkg_name}', 'daq_move_plugins')
⋮----
def test_move_inst_plugins_name()
⋮----
name = plug.split('daq_move_')[1]
⋮----
def test_move_has_mandatory_methods()
⋮----
klass = getattr(getattr(move_mod, plug), f'DAQ_Move_{name}')
⋮----
@pytest.mark.parametrize('dim', ('0D', '1D', '2D', 'ND'))
def test_viewer_has_mandatory_methods(dim)
⋮----
name = plug.split(f'daq_{dim}viewer_')[1]
⋮----
module = importlib.import_module(f'.{plug}', mod.__package__)
⋮----
klass = getattr(module, f'DAQ_{dim}Viewer_{name}')
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# Compiled python modules.
*.pyc

# Byte-compiled / optimized / DLL files
__pycache__/

*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/

# pycharm
.idea/
.idea/*

*yacctab.py
*lextab.py
</file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2021 Sebastien Weber <sebastien.weber@cemes.fr>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</file>

<file path="MANIFEST.in">
include README.rst
include LICENSE
graft src
</file>

<file path="plugin_info.toml">
## To modify by developer(s) of the plugin

[plugin-info]
SHORT_PLUGIN_NAME = 'template'  #to be modified, for instance daqmx then rename the module name:
# (pymodaq_plugins_template become pymodaq_plugins_daqmx for instance)

package-url = 'https://github.com/PyMoDAQ/pymodaq_plugins_template' #to modify
description = 'some word about your plugin'

author = 'Author Name'
author-email = 'Author email'
license = 'MIT'

[plugin-install]
#packages required for your plugin:
packages-required = ['pymodaq>=4.3.6']

[features]  # defines the plugin features contained into this plugin
instruments = true  # true if plugin contains instrument classes (else false, notice the lowercase for toml files)
extensions = false  # true if plugins contains dashboard extensions
models = false  # true if plugins contains pid models or other models (optimisation...)
h5exporters = false  # true if plugin contains custom h5 file exporters
scanners = false  # true if plugin contains custom scan layout (daq_scan extensions)
</file>

<file path="README.rst">
pymodaq_plugins_template
########################

.. the following must be adapted to your developed package, links to pypi, github  description...

.. image:: https://img.shields.io/pypi/v/pymodaq_plugins_template.svg
   :target: https://pypi.org/project/pymodaq_plugins_template/
   :alt: Latest Version

.. image:: https://readthedocs.org/projects/pymodaq/badge/?version=latest
   :target: https://pymodaq.readthedocs.io/en/stable/?badge=latest
   :alt: Documentation Status

.. image:: https://github.com/PyMoDAQ/pymodaq_plugins_template/workflows/Upload%20Python%20Package/badge.svg
   :target: https://github.com/PyMoDAQ/pymodaq_plugins_template
   :alt: Publication Status

.. image:: https://github.com/PyMoDAQ/pymodaq_plugins_template/actions/workflows/Test.yml/badge.svg
    :target: https://github.com/PyMoDAQ/pymodaq_plugins_template/actions/workflows/Test.yml


Use this template to create a repository on your account and start the development of your own PyMoDAQ plugin!


Authors
=======

* First Author  (myemail@xxx.org)
* Other author (myotheremail@xxx.org)

.. if needed use this field

    Contributors
    ============

    * First Contributor
    * Other Contributors

.. if needed use this field

  Depending on the plugin type, delete/complete the fields below


Instruments
===========

Below is the list of instruments included in this plugin

Actuators
+++++++++

* **yyy**: control of yyy actuators
* **xxx**: control of xxx actuators

Viewer0D
++++++++

* **yyy**: control of yyy 0D detector
* **xxx**: control of xxx 0D detector

Viewer1D
++++++++

* **yyy**: control of yyy 1D detector
* **xxx**: control of xxx 1D detector


Viewer2D
++++++++

* **yyy**: control of yyy 2D detector
* **xxx**: control of xxx 2D detector


PID Models
==========


Extensions
==========


Installation instructions
=========================

* PyMoDAQ’s version.
* Operating system’s version.
* What manufacturer’s drivers should be installed to make this plugin run?
</file>

<file path="setup.py">

</file>

<file path="tox.ini">
[flake8]
exclude = .git,__pycache__,build,dist,pymodaq/QtDesigner_Ressources
ignore = E501, F401, F841, F811, F403
</file>

</files>
